---
phase: 21-closure-visualizations
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/Concepts/ClosureLoopGotchaViz.tsx
autonomous: true

must_haves:
  truths:
    - "User sees var creating single shared binding that all callbacks reference"
    - "User sees let creating per-iteration binding with separate scope for each callback"
    - "Side-by-side comparison shows both behaviors simultaneously"
    - "Final output shows 3,3,3 for var vs 0,1,2 for let"
  artifacts:
    - path: "src/components/Concepts/ClosureLoopGotchaViz.tsx"
      provides: "var vs let loop closure visualization"
      contains: "ClosureLoopGotchaViz"
      min_lines: 300
  key_links:
    - from: "ClosureLoopGotchaViz.tsx"
      to: "Side-by-side layout"
      via: "grid grid-cols-2 with red/green tinting"
      pattern: "grid-cols-2|varBinding|letBinding"
---

<objective>
Create ClosureLoopGotchaViz component showing the classic loop closure bug with var vs let side-by-side comparison.

Purpose: This is THE most common closure interview question. Learners must understand WHY var produces 3,3,3 and let produces 0,1,2 by seeing the scope binding difference visually.

Output: Side-by-side visualization showing var (single binding) vs let (per-iteration bindings) in loops with callbacks.
</objective>

<execution_context>
@/Users/sunnywilson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunnywilson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-closure-visualizations/21-RESEARCH.md
@src/components/Concepts/ClosuresViz.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClosureLoopGotchaViz component</name>
  <files>src/components/Concepts/ClosureLoopGotchaViz.tsx</files>
  <action>
Create ClosureLoopGotchaViz.tsx with SIDE-BY-SIDE comparison layout:

1. Add 'use client' directive
2. Import React hooks and framer-motion

3. Create NEW interface structure for side-by-side:

```typescript
interface LoopStep {
  id: number
  description: string
  iteration: number  // 0, 1, 2, 3 (3 = loop complete)
  phase: 'loop-start' | 'iteration' | 'callback-created' | 'loop-end' | 'callbacks-run'
  varSide: {
    highlightLines: number[]
    scopeLabel: string
    scopeVars: { name: string; value: string }[]
    callbacks: { id: string; label: string; scopeRef: string }[]
  }
  letSide: {
    highlightLines: number[]
    scopes: { id: string; label: string; vars: { name: string; value: string }[] }[]
    callbacks: { id: string; label: string; scopeRef: string }[]
  }
  output: { var: string[]; let: string[] }
}
```

4. Create examples for three levels:

BEGINNER:
- "setTimeout Loop" - classic interview question
  ```javascript
  // VAR side
  for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);
  }
  // Output: 3, 3, 3

  // LET side
  for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);
  }
  // Output: 0, 1, 2
  ```
  Steps:
  1. Loop starts - var hoists i to global, let creates block scope
  2-4. Each iteration: var updates global i, let creates NEW block scope
  5. Loop ends - var: i=3 (single), let: 3 separate scopes (i=0,1,2)
  6. Callbacks run - var: all read 3, let: each reads own i

INTERMEDIATE:
- "Array.push Pattern"
  ```javascript
  const funcs = [];
  for (var/let i = 0; i < 3; i++) {
    funcs.push(() => i);
  }
  funcs.forEach(f => console.log(f()));
  ```
  Show funcs array with callbacks pointing to scopes

ADVANCED:
- "IIFE Workaround" - how to fix var with IIFE
  ```javascript
  for (var i = 0; i < 3; i++) {
    (function(j) {
      setTimeout(() => console.log(j), 100);
    })(i);
  }
  ```
  Show IIFE creating new scope per iteration (simulating let behavior)

5. LAYOUT (this is the key differentiator):

```jsx
<div className="grid grid-cols-2 gap-4">
  {/* var panel - RED tint for "bug" */}
  <div className="rounded-xl border border-red-500/30 bg-red-500/5 p-4">
    <div className="flex items-center gap-2 mb-3">
      <AlertTriangle size={16} className="text-red-400" />
      <span className="text-sm font-semibold text-red-400">var i (Single Binding)</span>
    </div>
    <CodePanel code={varCode} highlightLines={step.varSide.highlightLines} />
    <ScopeVisualization scope={step.varSide} />
    <CallbackList callbacks={step.varSide.callbacks} />
    <OutputPanel output={step.output.var} />
  </div>

  {/* let panel - GREEN tint for "correct" */}
  <div className="rounded-xl border border-emerald-500/30 bg-emerald-500/5 p-4">
    <div className="flex items-center gap-2 mb-3">
      <CheckCircle size={16} className="text-emerald-400" />
      <span className="text-sm font-semibold text-emerald-400">let i (Per-Iteration Binding)</span>
    </div>
    <CodePanel code={letCode} highlightLines={step.letSide.highlightLines} />
    <ScopesVisualization scopes={step.letSide.scopes} />
    <CallbackList callbacks={step.letSide.callbacks} />
    <OutputPanel output={step.output.let} />
  </div>
</div>
```

6. Visual elements:
   - var side: Single scope object (Global/Function) with i, all callbacks pointing to it
   - let side: Multiple block scope objects, each callback pointing to different scope
   - Use arrows/lines to show callback -> scope reference
   - Final step: var callbacks all point to i=3, let callbacks each have own i

7. Level selector and step controls below the grid

8. Key insight per level:
   - Beginner: "var creates ONE i for entire loop. let creates FRESH i per iteration."
   - Intermediate: "Closures capture REFERENCES, not values. var: one ref shared. let: separate refs."
   - Advanced: "IIFE was the ES5 workaround - create new scope manually. let does this automatically."
  </action>
  <verify>
    - File exists: ls -la src/components/Concepts/ClosureLoopGotchaViz.tsx
    - Has side-by-side layout: grep -n "grid-cols-2" src/components/Concepts/ClosureLoopGotchaViz.tsx
    - Has var/let comparison: grep -n "varSide\|letSide" src/components/Concepts/ClosureLoopGotchaViz.tsx
    - No TypeScript errors: npx tsc --noEmit src/components/Concepts/ClosureLoopGotchaViz.tsx 2>&1 | head -20
    - Build passes: npm run build 2>&1 | grep -i error || echo "Build passed"
  </verify>
  <done>
    - ClosureLoopGotchaViz.tsx exists with side-by-side layout
    - var side shows single shared binding (red tint)
    - let side shows per-iteration bindings (green tint)
    - Callbacks visually linked to their scope
    - Output shows 3,3,3 vs 0,1,2 difference
  </done>
</task>

<task type="auto">
  <name>Task 2: Register ClosureLoopGotchaViz in concepts data</name>
  <files>src/data/concepts.ts</files>
  <action>
Add ClosureLoopGotchaViz to concepts.ts:

1. Import ClosureLoopGotchaViz:
   import { ClosureLoopGotchaViz } from '@/components/Concepts/ClosureLoopGotchaViz'

2. Add new concept entry:
   - id: 'closure-loop-gotcha'
   - title: 'Loop Closure Gotcha'
   - description: 'Understanding var vs let in loops with closures'
   - component: ClosureLoopGotchaViz
   - keyPoints: var hoisting, block scope, per-iteration binding
   - interviewTips: THE classic closure interview question
  </action>
  <verify>
    - Concept registered: grep -n "closure-loop-gotcha\|ClosureLoopGotchaViz" src/data/concepts.ts
    - Import present: grep -n "import.*ClosureLoopGotchaViz" src/data/concepts.ts
    - No syntax errors: npx tsc --noEmit src/data/concepts.ts
  </verify>
  <done>
    - ClosureLoopGotchaViz imported and registered
    - Concept navigable via routing
  </done>
</task>

</tasks>

<verification>
1. Side-by-side layout works:
   - grep "grid-cols-2" src/components/Concepts/ClosureLoopGotchaViz.tsx

2. Both var and let visualizations present:
   - grep -c "varSide\|letSide" src/components/Concepts/ClosureLoopGotchaViz.tsx

3. Build passes:
   - npm run build

4. Contains expected output:
   - grep "3.*3.*3\|0.*1.*2" src/components/Concepts/ClosureLoopGotchaViz.tsx
</verification>

<success_criteria>
- Side-by-side var vs let visualization
- var shows single binding with red warning styling
- let shows per-iteration bindings with green success styling
- Output clearly shows 3,3,3 vs 0,1,2
- Three difficulty levels
- Component registered in concepts.ts
</success_criteria>

<output>
After completion, create `.planning/phases/21-closure-visualizations/21-03-SUMMARY.md`
</output>
