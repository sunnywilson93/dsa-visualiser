---
phase: 21-closure-visualizations
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/Concepts/ClosureMemoryLeaksViz.tsx
autonomous: true

must_haves:
  truths:
    - "User sees reference chain from GC root through closure to leaked object"
    - "User sees 'LEAKED' badge on objects that cannot be garbage collected"
    - "User sees prevention technique (nullify, WeakMap) in advanced examples"
    - "Root -> Closure -> Leaked Object path clearly visualized"
  artifacts:
    - path: "src/components/Concepts/ClosureMemoryLeaksViz.tsx"
      provides: "Memory leak visualization with reference chains"
      contains: "ClosureMemoryLeaksViz"
      min_lines: 300
  key_links:
    - from: "ClosureMemoryLeaksViz.tsx"
      to: "Reference chain display"
      via: "referenceChain array with from/to/label"
      pattern: "referenceChain|gcRoot|leaked"
---

<objective>
Create ClosureMemoryLeaksViz component showing how closures can cause memory leaks by keeping references to large objects alive.

Purpose: Teach learners to identify and prevent closure-based memory leaks. Show the GC root reference chain that prevents garbage collection.

Output: Visualization with reference chain paths, leaked object highlighting, and prevention techniques.
</objective>

<execution_context>
@/Users/sunnywilson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunnywilson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-closure-visualizations/21-RESEARCH.md
@src/components/Concepts/ClosuresViz.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClosureMemoryLeaksViz component</name>
  <files>src/components/Concepts/ClosureMemoryLeaksViz.tsx</files>
  <action>
Create ClosureMemoryLeaksViz.tsx with reference chain visualization:

1. Add 'use client' directive
2. Import React hooks, framer-motion, and Lucide icons (AlertTriangle, Trash2, Link2, CheckCircle)

3. Create interface for memory leak steps:

```typescript
interface MemoryLeakStep {
  id: number
  description: string
  phase: 'normal' | 'leak-created' | 'gc-attempt' | 'leak-detected' | 'fixed'
  highlightLines: number[]
  referenceChain: {
    from: string
    to: string
    label: string  // 'variable', '[[Scope]]', 'captured reference'
    blocking?: boolean  // highlights in red if blocking GC
  }[]
  heapObjects: {
    id: string
    label: string
    type: 'root' | 'closure' | 'function' | 'object' | 'dom'
    reachable: boolean
    leaked: boolean
    size?: string  // e.g., '1MB' for visual impact
  }[]
  showWarning: boolean
  showFix?: boolean
}
```

4. Create examples:

BEGINNER:
- "Large Array Leak"
  ```javascript
  function createLeak() {
    const largeData = new Array(1000000).fill('data');  // 1MB
    return function processData() {
      return largeData.length;  // Keeps largeData alive!
    };
  }
  const leakyFn = createLeak();
  // largeData stuck in memory even if leakyFn never called again
  ```
  Steps:
  1. createLeak() called - largeData allocated
  2. Function returned - closure captures reference to largeData
  3. GC runs - cannot collect largeData (reference chain exists)
  4. Memory stays consumed - LEAK!

INTERMEDIATE:
- "Event Listener Leak"
  ```javascript
  function setupHandler() {
    const bigData = loadBigData();  // 10MB
    button.addEventListener('click', () => {
      console.log(bigData.summary);
    });
    // Even if button removed, bigData may persist!
  }
  ```
  Show: DOM -> event listener -> closure -> bigData chain

- "Timer Callback Leak"
  ```javascript
  function startPolling() {
    const cache = new Map();  // Grows over time
    setInterval(() => {
      cache.set(Date.now(), fetchData());
    }, 1000);
    // cache never cleared!
  }
  ```

ADVANCED:
- "Fixed with Nullify"
  ```javascript
  function createSafe() {
    let largeData = new Array(1000000).fill('data');
    return {
      process() {
        const len = largeData.length;
        largeData = null;  // Release reference!
        return len;
      }
    };
  }
  ```
  Show reference chain BREAKING when largeData = null

- "Fixed with WeakMap"
  ```javascript
  const cache = new WeakMap();  // Weak references!
  function process(obj) {
    if (!cache.has(obj)) {
      cache.set(obj, computeExpensive(obj));
    }
    return cache.get(obj);
  }
  // When obj is GC'd, cache entry is auto-removed
  ```

5. LAYOUT - Reference Chain Visualization:

```jsx
{/* Reference Chain Display */}
<div className="flex flex-col items-center gap-2 p-4">
  {/* GC Root */}
  <div className="px-4 py-2 bg-emerald-500/20 border border-emerald-500/40 rounded-lg">
    <span className="text-sm font-semibold text-emerald-400">GC Root (Global)</span>
  </div>

  {/* Chain arrows and nodes */}
  {step.referenceChain.map((ref, i) => (
    <div key={i} className="flex flex-col items-center">
      <div className="h-4 w-px bg-gray-600" />
      <div className={`px-2 py-0.5 rounded text-xs ${
        ref.blocking ? 'bg-red-500/30 text-red-400' : 'bg-purple-500/30 text-purple-400'
      }`}>
        {ref.label}
      </div>
      <div className="h-4 w-px bg-gray-600" />
      <div className={`px-4 py-2 border rounded-lg ${
        step.heapObjects.find(o => o.id === ref.to)?.leaked
          ? 'bg-red-500/20 border-red-500/40'
          : 'bg-amber-500/20 border-amber-500/40'
      }`}>
        <span className="text-sm font-mono">{ref.to}</span>
        {step.heapObjects.find(o => o.id === ref.to)?.size && (
          <span className="ml-2 text-xs text-gray-500">
            ({step.heapObjects.find(o => o.id === ref.to)?.size})
          </span>
        )}
      </div>
    </div>
  ))}
</div>

{/* Leaked Object Warning */}
{step.showWarning && (
  <motion.div
    className="flex items-center gap-2 px-4 py-2 bg-red-500/20 border border-red-500/40 rounded-lg"
    initial={{ scale: 0.9, opacity: 0 }}
    animate={{ scale: 1, opacity: 1 }}
  >
    <AlertTriangle className="text-red-500" size={20} />
    <span className="text-red-400 font-medium">Memory Leak Detected!</span>
  </motion.div>
)}

{/* Fix Applied Indicator */}
{step.showFix && (
  <motion.div
    className="flex items-center gap-2 px-4 py-2 bg-emerald-500/20 border border-emerald-500/40 rounded-lg"
    initial={{ scale: 0.9, opacity: 0 }}
    animate={{ scale: 1, opacity: 1 }}
  >
    <CheckCircle className="text-emerald-500" size={20} />
    <span className="text-emerald-400 font-medium">Reference Released - GC Can Collect</span>
  </motion.div>
)}
```

6. Additional visual elements:
   - Size badges on objects (1MB, 10MB) to emphasize impact
   - Pulsing red glow on leaked objects
   - Broken chain animation when reference is nullified
   - Trash2 icon when GC successfully collects

7. Key insights:
   - Beginner: "Closures keep variables alive by holding references. Large objects = large leaks."
   - Intermediate: "Event listeners and timers are common leak sources - always clean up!"
   - Advanced: "Nullify references when done. Use WeakMap for caches that shouldn't block GC."
  </action>
  <verify>
    - File exists: ls -la src/components/Concepts/ClosureMemoryLeaksViz.tsx
    - Has reference chain: grep -n "referenceChain" src/components/Concepts/ClosureMemoryLeaksViz.tsx
    - Has leak detection: grep -n "leaked\|LEAK" src/components/Concepts/ClosureMemoryLeaksViz.tsx
    - Has fix patterns: grep -n "null\|WeakMap" src/components/Concepts/ClosureMemoryLeaksViz.tsx
    - No TypeScript errors: npx tsc --noEmit src/components/Concepts/ClosureMemoryLeaksViz.tsx
    - Build passes: npm run build 2>&1 | grep -i error || echo "Build passed"
  </verify>
  <done>
    - ClosureMemoryLeaksViz.tsx exists with reference chain visualization
    - GC Root -> Closure -> Leaked Object path displayed
    - "LEAKED" / warning indicators on objects that cannot be collected
    - Prevention techniques shown in advanced examples
    - Three difficulty levels with appropriate examples
  </done>
</task>

<task type="auto">
  <name>Task 2: Register ClosureMemoryLeaksViz in concepts data</name>
  <files>src/data/concepts.ts</files>
  <action>
Add ClosureMemoryLeaksViz to concepts.ts:

1. Import ClosureMemoryLeaksViz:
   import { ClosureMemoryLeaksViz } from '@/components/Concepts/ClosureMemoryLeaksViz'

2. Add new concept entry:
   - id: 'closure-memory-leaks'
   - title: 'Closure Memory Leaks'
   - description: 'Understanding and preventing memory leaks caused by closures'
   - component: ClosureMemoryLeaksViz
   - keyPoints: reference chains, GC roots, cleanup patterns
   - interviewTips: common in senior interviews, debugging production issues
  </action>
  <verify>
    - Concept registered: grep -n "closure-memory-leaks\|ClosureMemoryLeaksViz" src/data/concepts.ts
    - Import present: grep -n "import.*ClosureMemoryLeaksViz" src/data/concepts.ts
    - No syntax errors: npx tsc --noEmit src/data/concepts.ts
  </verify>
  <done>
    - ClosureMemoryLeaksViz imported and registered
    - Concept navigable via routing
  </done>
</task>

</tasks>

<verification>
1. Reference chain visualization:
   - grep "referenceChain" src/components/Concepts/ClosureMemoryLeaksViz.tsx

2. Leak detection:
   - grep -c "leaked\|LEAK" src/components/Concepts/ClosureMemoryLeaksViz.tsx

3. Fix patterns included:
   - grep "null\|WeakMap" src/components/Concepts/ClosureMemoryLeaksViz.tsx

4. Build passes:
   - npm run build
</verification>

<success_criteria>
- Reference chain from GC root to leaked object clearly visualized
- "LEAKED" badge and warning indicators on blocked objects
- Prevention techniques (nullify, WeakMap) in advanced examples
- Size badges showing memory impact
- Three difficulty levels with progressive examples
- Component registered in concepts.ts
</success_criteria>

<output>
After completion, create `.planning/phases/21-closure-visualizations/21-04-SUMMARY.md`
</output>
