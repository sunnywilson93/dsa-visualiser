---
phase: 19-async-await-queues
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/Concepts/AsyncAwaitSyntaxViz.tsx
  - src/components/Concepts/index.ts
  - src/app/concepts/[conceptId]/ConceptPageClient.tsx
autonomous: true

must_haves:
  truths:
    - "User can see where async functions pause at await keywords"
    - "User can see async function state indicator (running/suspended/completed)"
    - "User can see continuation scheduled in microtask queue after await"
    - "User can switch between beginner/intermediate/advanced difficulty levels"
  artifacts:
    - path: "src/components/Concepts/AsyncAwaitSyntaxViz.tsx"
      provides: "Async/await suspension point visualization"
      min_lines: 300
      exports: ["AsyncAwaitSyntaxViz"]
  key_links:
    - from: "src/app/concepts/[conceptId]/ConceptPageClient.tsx"
      to: "AsyncAwaitSyntaxViz"
      via: "dynamic import"
      pattern: "async-await-basics.*AsyncAwaitSyntaxViz"
---

<objective>
Create AsyncAwaitSyntaxViz component showing where async functions pause at await and how continuations are scheduled as microtasks.

Purpose: Users understand that await pauses execution and schedules the rest of the function as a microtask continuation.
Output: AsyncAwaitSyntaxViz.tsx with suspension indicators and microtask queue visualization.
</objective>

<execution_context>
@/Users/sunnywilson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunnywilson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-async-await-queues/19-CONTEXT.md
@.planning/phases/19-async-await-queues/19-RESEARCH.md
@src/components/Concepts/EventLoopViz.tsx
@src/components/SharedViz/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AsyncAwaitSyntaxViz component</name>
  <files>src/components/Concepts/AsyncAwaitSyntaxViz.tsx</files>
  <action>
Create AsyncAwaitSyntaxViz.tsx following established patterns:

1. Structure:
   - 'use client' directive at top
   - Import useState, motion/AnimatePresence, Lucide icons (Play, Pause, CheckCircle)
   - Import SharedViz components (CodePanel, StepProgress, StepControls)
   - Define interfaces per research:
   ```typescript
   interface AsyncFunction {
     name: string
     state: 'running' | 'suspended' | 'completed'
     awaitLine?: number
   }

   interface Step {
     description: string
     codeLine: number
     asyncFunctions: AsyncFunction[]
     callStack: string[]
     microQueue: string[]
     output: string[]
     phase: 'sync' | 'await' | 'resume' | 'complete'
   }
   ```

2. Examples by level:
   - Beginner: Single async function with one await, shows "start", await, "end" order
     ```javascript
     async function fetchData() {
       console.log('fetching');
       await Promise.resolve();
       console.log('done');
     }
     console.log('start');
     fetchData();
     console.log('end');
     // Output: start, fetching, end, done
     ```
   - Intermediate: Nested async calls, multiple awaits in sequence
   - Advanced: Shows implicit promise creation at await point (progressive disclosure)

3. Visual layout:
   - Left: Code panel with current line highlighted
   - Center: Async function state indicator (running=green, suspended=yellow with "SUSPENDED" badge, completed=gray)
   - Right: Call stack and microtask queue (use EventLoopViz queue styling)

4. Key visual elements:
   - "Async Function State" panel showing function name + state badge
   - Microtask queue showing continuation entry when await suspends
   - Call stack showing function pushed/popped
   - Output console at bottom

5. Key insights to demonstrate:
   - Code before first await runs synchronously
   - await pauses function, schedules continuation as microtask
   - Synchronous code after function call runs before "done"
   - Multiple awaits create multiple suspension points

6. Use existing queue animation pattern from EventLoopViz (AnimatePresence with slide-out).
  </action>
  <verify>npm run build passes with no TypeScript errors</verify>
  <done>AsyncAwaitSyntaxViz.tsx exists with suspension indicators and microtask queue</done>
</task>

<task type="auto">
  <name>Task 2: Wire AsyncAwaitSyntaxViz to routing</name>
  <files>src/components/Concepts/index.ts, src/app/concepts/[conceptId]/ConceptPageClient.tsx</files>
  <action>
1. In src/components/Concepts/index.ts:
   - Add export: `export { AsyncAwaitSyntaxViz } from './AsyncAwaitSyntaxViz'`

2. In src/app/concepts/[conceptId]/ConceptPageClient.tsx:
   - Update the 'async-await-basics' mapping (currently points to AsyncPatternsViz) to:
     `'async-await-basics': dynamic(() => import('@/components/Concepts/AsyncAwaitSyntaxViz').then(m => m.AsyncAwaitSyntaxViz))`
  </action>
  <verify>npm run dev, navigate to /concepts/async-await-basics, component renders without errors</verify>
  <done>async-await-basics route renders AsyncAwaitSyntaxViz component</done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. `npm run lint` produces no new warnings
3. Navigate to /concepts/async-await-basics - component loads
4. Step through beginner example - verify suspension indicator shows when hitting await
5. Verify microtask queue shows continuation entry
6. Verify output order matches expected (start, fetching, end, done)
</verification>

<success_criteria>
- AsyncAwaitSyntaxViz.tsx exists with suspension point visualization
- 3 difficulty levels with progressive disclosure
- Async function state indicator (running/suspended/completed) visible
- Microtask queue shows continuation after await
- Code highlighting synced with execution step
- Mobile responsive layout
</success_criteria>

<output>
After completion, create `.planning/phases/19-async-await-queues/19-02-SUMMARY.md`
</output>
