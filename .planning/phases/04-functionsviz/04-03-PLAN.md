---
phase: 04-functionsviz
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/components/Concepts/FunctionsViz.tsx
  - src/components/Concepts/FunctionsViz.module.css
autonomous: true

must_haves:
  truths:
    - "User can see how this binding differs between regular and arrow functions"
    - "Method invocation shows this bound to the object"
    - "Standalone function shows this as window/undefined"
    - "call/apply/bind examples show explicit this binding"
    - "Arrow function shows lexical this (inherited from parent)"
    - "Side-by-side comparison makes difference clear"
  artifacts:
    - path: "src/components/Concepts/FunctionsViz.tsx"
      provides: "This binding visualization and advanced examples"
      contains: "ThisBindingState"
    - path: "src/components/Concepts/FunctionsViz.module.css"
      provides: "This binding panel styles"
      contains: "thisBinding"
  key_links:
    - from: "FunctionsViz.tsx"
      to: "currentStep.thisBinding"
      via: "render"
      pattern: "thisBinding.*rule"
---

<objective>
Add this binding visualization with advanced examples covering all binding scenarios

Purpose: Help learners understand how `this` binding works differently for regular vs arrow functions, including methods, standalone calls, and explicit binding
Output: Advanced examples with this binding visualization showing binding rules and side-by-side comparisons
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-functionsviz/04-02-SUMMARY.md
@src/components/Concepts/FunctionsViz.tsx
@src/components/Concepts/FunctionsViz.module.css
@src/components/Concepts/ThisKeywordViz.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ThisBindingState type and advanced examples</name>
  <files>src/components/Concepts/FunctionsViz.tsx</files>
  <action>
Add ThisBindingState interface to track this binding:

```typescript
interface ThisBindingState {
  value: string           // e.g., "user object", "window", "undefined"
  rule: 'implicit' | 'explicit' | 'new' | 'default' | 'lexical'
  explanation: string     // Why this has this value
  isArrow: boolean        // Is this an arrow function?
  comparisonValue?: string // For side-by-side: what would the other type be?
}
```

Update FunctionStep interface to include optional thisBinding:
```typescript
interface FunctionStep {
  // ... existing fields
  thisBinding?: ThisBindingState
}
```

Create 5 advanced examples:

**Example 1: "Method invocation (implicit binding)"**
```javascript
const user = {
  name: 'Alice',
  greet() {
    console.log('Hi, ' + this.name)
  }
}
user.greet()
```
- Steps show: object created, method called, this bound to `user` object
- ThisBinding: `{ value: 'user { name: "Alice" }', rule: 'implicit', explanation: 'Called as object method: obj.method()' }`

**Example 2: "Standalone function (default binding)"**
```javascript
function sayName() {
  console.log(this)
}
sayName()  // this = window (browser) or undefined (strict mode)
```
- Steps show: function defined, called without object, this = window/undefined
- ThisBinding: `{ value: 'window (or undefined in strict)', rule: 'default', explanation: 'Called without object context' }`

**Example 3: "call/apply/bind (explicit binding)"**
```javascript
function greet() {
  console.log('Hi, ' + this.name)
}
const person = { name: 'Bob' }
greet.call(person)  // this = person
```
- Steps show: function defined, call() used to set this explicitly
- ThisBinding: `{ value: 'person { name: "Bob" }', rule: 'explicit', explanation: 'Explicitly set via .call(person)' }`

**Example 4: "Arrow vs Regular (side-by-side)"**
```javascript
const obj = {
  name: 'Carol',
  regularFn: function() {
    console.log('Regular:', this.name)
  },
  arrowFn: () => {
    console.log('Arrow:', this.name)
  }
}
obj.regularFn()  // this = obj
obj.arrowFn()    // this = window (lexical)
```
- Steps show both calls, highlighting the difference
- Regular: `{ value: 'obj', rule: 'implicit', isArrow: false, comparisonValue: 'window (arrow would inherit)' }`
- Arrow: `{ value: 'window (lexical)', rule: 'lexical', isArrow: true, comparisonValue: 'obj (regular would get)' }`

**Example 5: "Callback losing this (pitfall)"**
```javascript
const user = {
  name: 'Dan',
  greet() {
    console.log('Hi, ' + this.name)
  }
}
setTimeout(user.greet, 100)  // this = window, NOT user!
// Fix: setTimeout(() => user.greet(), 100)
// Or: setTimeout(user.greet.bind(user), 100)
```
- Steps show: method extracted, passed to setTimeout, this lost
- Show the bug, then show fixes
- ThisBinding: `{ value: 'window (BUG!)', rule: 'default', explanation: 'Method extracted loses object context' }`

Each step during function execution should have thisBinding showing current binding rule and value.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit` passes</verify>
  <done>ThisBindingState interface added. 5 advanced examples created covering implicit, default, explicit, lexical binding, and the callback-losing-this pitfall.</done>
</task>

<task type="auto">
  <name>Task 2: Implement this binding visualization panel</name>
  <files>src/components/Concepts/FunctionsViz.tsx, src/components/Concepts/FunctionsViz.module.css</files>
  <action>
Add this binding visualization panel that shows when `currentStep.thisBinding` exists:

**Component structure:**
```tsx
{currentStep.thisBinding && (
  <div className={styles.thisBindingPanel}>
    <div className={styles.panelHeader}>this Binding</div>

    <div className={styles.thisDisplay}>
      <div className={styles.thisLabel}>this =</div>
      <AnimatePresence mode="wait">
        <motion.div
          key={currentStep.thisBinding.value}
          className={`${styles.thisValue} ${styles[currentStep.thisBinding.rule]}`}
          initial={{ scale: 0.9, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.9, opacity: 0 }}
        >
          {currentStep.thisBinding.value}
        </motion.div>
      </AnimatePresence>
    </div>

    <div className={styles.thisRule}>
      <span className={`${styles.ruleBadge} ${styles[currentStep.thisBinding.rule]}`}>
        {currentStep.thisBinding.rule} binding
      </span>
      {currentStep.thisBinding.isArrow && (
        <span className={styles.arrowBadge}>Arrow Function</span>
      )}
    </div>

    <div className={styles.thisExplanation}>
      {currentStep.thisBinding.explanation}
    </div>

    {/* Side-by-side comparison for arrow vs regular */}
    {currentStep.thisBinding.comparisonValue && (
      <div className={styles.thisComparison}>
        <div className={styles.comparisonLabel}>
          {currentStep.thisBinding.isArrow ? 'If regular function:' : 'If arrow function:'}
        </div>
        <div className={styles.comparisonValue}>
          this = {currentStep.thisBinding.comparisonValue}
        </div>
      </div>
    )}
  </div>
)}
```

**CSS styling for this binding:**
```css
.thisBindingPanel {
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(139, 92, 246, 0.2);
  border-radius: var(--radius-xl);
  padding: var(--space-lg);
}

.thisDisplay {
  display: flex;
  align-items: center;
  gap: var(--space-md);
  margin-bottom: var(--space-md);
}

.thisLabel {
  font-size: var(--text-lg);
  font-weight: var(--font-semibold);
  color: var(--gray-400);
}

.thisValue {
  font-family: 'Fira Code', monospace;
  font-size: var(--text-lg);
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--radius-md);
  border: 2px solid;
}

/* Rule-based coloring */
.thisValue.implicit {
  background: rgba(16, 185, 129, 0.15);
  border-color: #10b981;
  color: #10b981;
}

.thisValue.explicit {
  background: rgba(59, 130, 246, 0.15);
  border-color: #3b82f6;
  color: #3b82f6;
}

.thisValue.default {
  background: rgba(245, 158, 11, 0.15);
  border-color: #f59e0b;
  color: #f59e0b;
}

.thisValue.lexical {
  background: rgba(139, 92, 246, 0.15);
  border-color: #8b5cf6;
  color: #8b5cf6;
}

.thisValue.new {
  background: rgba(236, 72, 153, 0.15);
  border-color: #ec4899;
  color: #ec4899;
}

.thisRule {
  display: flex;
  gap: var(--space-sm);
  margin-bottom: var(--space-md);
}

.ruleBadge {
  padding: 0.2rem 0.5rem;
  border-radius: var(--radius-full);
  font-size: var(--text-xs);
  font-weight: var(--font-semibold);
  text-transform: uppercase;
}

.ruleBadge.implicit { background: rgba(16, 185, 129, 0.2); color: #10b981; }
.ruleBadge.explicit { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
.ruleBadge.default { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
.ruleBadge.lexical { background: rgba(139, 92, 246, 0.2); color: #8b5cf6; }
.ruleBadge.new { background: rgba(236, 72, 153, 0.2); color: #ec4899; }

.arrowBadge {
  padding: 0.2rem 0.5rem;
  border-radius: var(--radius-full);
  font-size: var(--text-xs);
  font-weight: var(--font-semibold);
  background: rgba(139, 92, 246, 0.2);
  color: #8b5cf6;
}

.thisExplanation {
  font-size: var(--text-base);
  color: var(--gray-300);
  margin-bottom: var(--space-md);
}

.thisComparison {
  padding: var(--space-md);
  background: rgba(255, 255, 255, 0.03);
  border: 1px dashed rgba(255, 255, 255, 0.1);
  border-radius: var(--radius-md);
}

.comparisonLabel {
  font-size: var(--text-sm);
  color: var(--gray-500);
  margin-bottom: var(--space-xs);
}

.comparisonValue {
  font-family: 'Fira Code', monospace;
  font-size: var(--text-base);
  color: var(--gray-400);
}
```
  </action>
  <verify>
1. `npm run build` passes
2. Visit `/concepts/functions`, select Advanced level
3. Example 1 (Method): this shows bound to object with green (implicit) styling
4. Example 2 (Standalone): this shows window/undefined with yellow (default) styling
5. Example 3 (call/apply): this shows explicit binding with blue styling
6. Example 4 (Arrow vs Regular): Side-by-side comparison shows what other type would be
7. Example 5 (Callback pitfall): Shows bug with warning and fix suggestions
  </verify>
  <done>
This binding visualization implemented with:
- This value display with animated transitions
- Rule badges (implicit, explicit, default, lexical, new)
- Color-coded by binding rule
- Arrow function indicator badge
- Side-by-side comparison for arrow vs regular functions
- Explanation text for each binding rule
- 5 advanced examples covering all this binding scenarios
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles
2. Build passes
3. Advanced level enabled with 5 examples
4. This binding panel appears during execution steps
5. This value animates on change
6. Rule badges show correct binding type with color
7. Arrow function examples show lexical binding with purple
8. Side-by-side comparison clearly shows difference
9. Callback pitfall example shows bug and fixes
</verification>

<success_criteria>
- This binding visualization clearly shows what `this` is bound to
- Different binding rules have distinct colors (implicit=green, explicit=blue, default=yellow, lexical=purple)
- Arrow function examples show lexical inheritance with comparison to regular function
- Side-by-side comparison makes the difference obvious
- Callback-losing-this pitfall demonstrates common bug and solutions
- All 5 advanced examples work with smooth animations
</success_criteria>

<output>
After completion, create `.planning/phases/04-functionsviz/04-03-SUMMARY.md`
</output>
