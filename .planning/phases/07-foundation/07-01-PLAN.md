---
phase: 07-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/DSAPatterns/index.ts
  - src/components/DSAPatterns/types.ts
  - src/data/dsaPatterns.ts
autonomous: true

must_haves:
  truths:
    - "DSAPatterns directory exists with barrel export"
    - "Shared types exist for DSA pattern visualizations"
    - "dsaPatterns.ts exports pattern metadata for two-pointers, hash-map, and bit-manipulation"
    - "Each pattern has id, name, description, whenToUse, and variants fields"
  artifacts:
    - path: "src/components/DSAPatterns/index.ts"
      provides: "Barrel export for DSAPatterns directory"
      exports: ["// placeholder for future viz components"]
    - path: "src/components/DSAPatterns/types.ts"
      provides: "Shared types for DSA pattern visualizations"
      exports: ["DSAPattern", "DSAPatternVariant", "PatternDifficulty"]
    - path: "src/data/dsaPatterns.ts"
      provides: "Pattern metadata for all DSA patterns"
      exports: ["dsaPatterns", "getPatternById", "DSA_PATTERN_IDS"]
  key_links:
    - from: "dsaPatterns.ts"
      to: "DSAPatterns/types.ts"
      via: "import DSAPattern type"
      pattern: "import.*DSAPattern.*from"
---

<objective>
Create DSAPatterns directory structure with shared types and dsaPatterns.ts data file.

Purpose: Establish the foundation for DSA pattern pages with consistent typing and metadata. The types align with existing ConceptStep/ConceptVisualState from src/types/index.ts. The data file follows the pattern of concepts.ts for JS concepts.

Output: Directory with barrel export, shared types file, and pattern metadata file with two-pointers, hash-map, and bit-manipulation patterns.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/SUMMARY.md
@.planning/phases/07-foundation/07-CONTEXT.md
@src/types/index.ts
@src/data/concepts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DSAPatterns directory with types</name>
  <files>
    src/components/DSAPatterns/types.ts
    src/components/DSAPatterns/index.ts
  </files>
  <action>
Create the DSAPatterns component directory with shared types:

**types.ts:**
Define types that complement existing types in src/types/index.ts (ConceptStep, ConceptVisualState):

```typescript
// Pattern difficulty levels (matches JS concepts pattern)
export type PatternDifficulty = 'beginner' | 'intermediate' | 'advanced'

// Pattern variant (e.g., converging vs same-direction for two-pointers)
export interface DSAPatternVariant {
  id: string
  name: string
  description: string
  whenToUse: string
}

// Main pattern definition
export interface DSAPattern {
  id: string
  name: string
  slug: string  // URL-safe identifier (e.g., 'two-pointers')
  description: string
  whenToUse: string[]
  variants: DSAPatternVariant[]
  complexity: {
    time: string
    space: string
  }
  relatedProblems?: string[]  // Problem IDs from examples.ts
}
```

Note: Step data (ConceptStep[]) will be embedded in individual visualizer components (like LoopsViz), not in the data file. This matches the v1.0 pattern.

**index.ts:**
```typescript
// DSA Pattern Visualizers
// Visualization components will be added in Phases 8-10

// Re-export types for convenience
export * from './types'
```
  </action>
  <verify>
    - Directory exists: `ls -la src/components/DSAPatterns/`
    - TypeScript compiles: `npx tsc --noEmit`
    - Types exported: `grep -E "export.*DSAPattern|PatternDifficulty" src/components/DSAPatterns/types.ts`
  </verify>
  <done>
    - DSAPatterns directory exists
    - types.ts exports DSAPattern, DSAPatternVariant, PatternDifficulty
    - index.ts re-exports types
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dsaPatterns.ts data file</name>
  <files>
    src/data/dsaPatterns.ts
  </files>
  <action>
Create the pattern metadata file following concepts.ts pattern:

**dsaPatterns.ts:**
```typescript
import type { DSAPattern } from '@/components/DSAPatterns/types'

export const DSA_PATTERN_IDS = ['two-pointers', 'hash-map', 'bit-manipulation'] as const
export type DSAPatternId = typeof DSA_PATTERN_IDS[number]

export const dsaPatterns: DSAPattern[] = [
  {
    id: 'two-pointers',
    name: 'Two Pointers',
    slug: 'two-pointers',
    description: 'Use two pointers to traverse an array or string, reducing time complexity from O(nÂ²) to O(n) for problems involving pairs or subarrays.',
    whenToUse: [
      'Finding pairs that satisfy a condition (sum, product)',
      'Removing duplicates from sorted array',
      'Reversing or partitioning arrays in-place',
      'Detecting cycles in linked lists (slow/fast)',
    ],
    variants: [
      {
        id: 'converging',
        name: 'Converging Pointers',
        description: 'Start pointers at opposite ends, move toward each other based on comparison.',
        whenToUse: 'Sorted arrays, pair sum problems, palindrome checks',
      },
      {
        id: 'same-direction',
        name: 'Same Direction (Slow/Fast)',
        description: 'Both pointers start at beginning, fast pointer moves ahead to find patterns.',
        whenToUse: 'Remove duplicates, cycle detection, find middle element',
      },
      {
        id: 'partition',
        name: 'Partition (Dutch Flag)',
        description: 'Three-way partition using two pointers to separate elements into regions.',
        whenToUse: 'Sort colors (0s, 1s, 2s), partition around pivot',
      },
    ],
    complexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    relatedProblems: ['two-sum', 'three-sum', 'container-with-most-water'],
  },
  {
    id: 'hash-map',
    name: 'Hash Map',
    slug: 'hash-map',
    description: 'Use a hash map for O(1) lookup to track seen elements, frequencies, or complement values during array traversal.',
    whenToUse: [
      'Finding pairs/triplets with target sum',
      'Counting frequency of elements',
      'Checking for duplicates or anagrams',
      'Storing indices for later lookup',
    ],
    variants: [
      {
        id: 'complement-lookup',
        name: 'Complement Lookup',
        description: 'Store complement values (target - current) to find pairs in single pass.',
        whenToUse: 'Two Sum, pair with target sum',
      },
      {
        id: 'frequency-counter',
        name: 'Frequency Counter',
        description: 'Count occurrences of each element for comparison or finding duplicates.',
        whenToUse: 'Valid Anagram, first unique character, majority element',
      },
      {
        id: 'index-storage',
        name: 'Index Storage',
        description: 'Store indices of elements for later reference or constraint checking.',
        whenToUse: 'Contains Duplicate II, finding subarrays with constraints',
      },
    ],
    complexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    relatedProblems: ['two-sum', 'valid-anagram', 'group-anagrams'],
  },
  {
    id: 'bit-manipulation',
    name: 'Bit Manipulation',
    slug: 'bit-manipulation',
    description: 'Use bitwise operations to solve problems efficiently by treating integers as arrays of bits.',
    whenToUse: [
      'Finding single/missing numbers without extra space',
      'Checking if number is power of two',
      'Counting set bits or toggling specific bits',
      'XOR tricks for finding unpaired elements',
    ],
    variants: [
      {
        id: 'xor-tricks',
        name: 'XOR Tricks',
        description: 'Use XOR properties: a ^ a = 0, a ^ 0 = a to find unique elements.',
        whenToUse: 'Single Number, missing number from sequence',
      },
      {
        id: 'bit-masks',
        name: 'Bit Masks',
        description: 'Use AND, OR masks to check, set, or clear specific bit positions.',
        whenToUse: 'Power of two checks, counting bits, subset generation',
      },
      {
        id: 'shift-operations',
        name: 'Shift Operations',
        description: 'Use left/right shifts to multiply/divide by powers of 2 or extract bits.',
        whenToUse: 'Reverse bits, counting leading zeros, bit extraction',
      },
    ],
    complexity: {
      time: 'O(1) or O(log n)',
      space: 'O(1)',
    },
    relatedProblems: ['single-number', 'counting-bits', 'reverse-bits'],
  },
]

export function getPatternById(id: string): DSAPattern | undefined {
  return dsaPatterns.find(pattern => pattern.id === id)
}

export function getPatternBySlug(slug: string): DSAPattern | undefined {
  return dsaPatterns.find(pattern => pattern.slug === slug)
}
```

The pattern structure mirrors concepts.ts but is tailored for algorithm patterns with variants and complexity info.
  </action>
  <verify>
    - File exists: `ls src/data/dsaPatterns.ts`
    - TypeScript compiles: `npx tsc --noEmit`
    - All patterns present: `grep -c "id:" src/data/dsaPatterns.ts` should show 3+ (patterns + variants)
    - Exports work: `grep -E "export const dsaPatterns|export function getPatternById" src/data/dsaPatterns.ts`
  </verify>
  <done>
    - dsaPatterns.ts exports array of 3 DSAPattern objects
    - Each pattern has id, name, slug, description, whenToUse, variants, complexity
    - getPatternById and getPatternBySlug helper functions exist
    - DSA_PATTERN_IDS type-safe constant array exists
  </done>
</task>

</tasks>

<verification>
1. `ls -la src/components/DSAPatterns/` shows types.ts and index.ts
2. `ls src/data/dsaPatterns.ts` confirms file exists
3. `npx tsc --noEmit` passes with no errors
4. `npm run lint` passes (or has only pre-existing warnings)
</verification>

<success_criteria>
- DSAPatterns directory exists with types.ts and index.ts
- DSAPattern type has id, name, slug, description, whenToUse, variants, complexity fields
- dsaPatterns.ts exports metadata for two-pointers, hash-map, and bit-manipulation
- getPatternById and getPatternBySlug helper functions work correctly
- All TypeScript imports resolve without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation/07-01-SUMMARY.md`
</output>
