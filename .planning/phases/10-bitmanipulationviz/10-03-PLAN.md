---
phase: 10-bitmanipulationviz
plan: 03
type: execute
wave: 3
depends_on: ["10-02"]
files_modified:
  - src/components/DSAPatterns/BitManipulationViz/BitManipulationViz.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can step through Missing Number XOR example (intermediate)"
    - "User can step through Counting Bits example (intermediate)"
    - "User can step through advanced bit manipulation example"
    - "All difficulty levels have at least one example per variant"
  artifacts:
    - path: "src/components/DSAPatterns/BitManipulationViz/BitManipulationViz.tsx"
      provides: "Intermediate and advanced examples for all variants"
      contains: "intermediate.*Missing Number|advanced"
  key_links:
    - from: "BitManipulationViz component"
      to: "intermediate/advanced examples"
      via: "examples data structure"
      pattern: "\\['intermediate'\\]|\\['advanced'\\]"
---

<objective>
Add intermediate and advanced examples for bit manipulation patterns.

Purpose: Complete the learning progression with more complex bit manipulation techniques.
Output: Intermediate and advanced examples for XOR tricks, bit masks, and shift operations.
</objective>

<execution_context>
@/Users/sunnywilson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunnywilson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-bitmanipulationviz/10-RESEARCH.md
@.planning/phases/10-bitmanipulationviz/10-01-SUMMARY.md
@.planning/phases/10-bitmanipulationviz/10-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add intermediate examples</name>
  <files>
    src/components/DSAPatterns/BitManipulationViz/BitManipulationViz.tsx
  </files>
  <action>
Add intermediate examples for each variant.

**XOR Tricks Intermediate: Missing Number**
Find missing number from 0 to n sequence.
- Input: [3, 0, 1] (missing 2 from 0,1,2,3)
- XOR all numbers with indices 0..n, missing one remains

```javascript
function missingNumber(nums) {
  let result = nums.length

  for (let i = 0; i < nums.length; i++) {
    result ^= i ^ nums[i]
  }

  return result
}
```

Steps (~12-14 steps, 8-bit):
1. Explain: XOR array values with indices cancels paired values
2. result = 3 (nums.length)
3. i=0: result ^= 0 ^ 3 (show each XOR)
4. i=1: result ^= 1 ^ 0
5. i=2: result ^= 2 ^ 1
6. Final: result = 2 (the missing number)

Insight: "XOR all indices 0..n with all values. Paired numbers cancel, leaving the missing one."

**Bit Masks Intermediate: Count Set Bits (Hamming Weight)**
Count number of 1-bits in a number.

```javascript
function hammingWeight(n) {
  let count = 0

  while (n !== 0) {
    count += n & 1
    n = n >> 1
  }

  return count
}
```

Steps (~12 steps, 8-bit):
- n = 11 (binary: 00001011)
- Loop: check n & 1, shift right, repeat
- Show each bit being "popped off" and counted
- Final count: 3

Insight: "Check lowest bit with & 1, shift right to check next bit. Count until n is 0."

**Shift Operations Intermediate: Reverse Bits**
Reverse the bits of a number.

```javascript
function reverseBits(n) {
  let result = 0

  for (let i = 0; i < 8; i++) {
    result = (result << 1) | (n & 1)
    n = n >> 1
  }

  return result
}
```

Steps (~10-12 steps, 8-bit):
- n = 13 (binary: 00001101)
- Each iteration: extract lowest bit, shift into result from left
- Show parallel: original bits shifting right, result bits shifting left
- Final: reversed binary

Insight: "Extract bits from right of input, insert from left into result. Shift both each iteration."
  </action>
  <verify>
    - examples['xor-tricks']['intermediate'] has Missing Number
    - examples['bit-masks']['intermediate'] has Count Set Bits
    - examples['shift-operations']['intermediate'] has Reverse Bits
    - Each example has 10+ steps
    - Steps show clear bit manipulation progression
  </verify>
  <done>
    Intermediate examples added for all three variants.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add advanced examples</name>
  <files>
    src/components/DSAPatterns/BitManipulationViz/BitManipulationViz.tsx
  </files>
  <action>
Add advanced examples for each variant.

**XOR Tricks Advanced: Single Number II (appears 3x, one appears 1x)**
Every element appears three times except one.

```javascript
function singleNumber(nums) {
  let ones = 0, twos = 0

  for (const num of nums) {
    ones = (ones ^ num) & ~twos
    twos = (twos ^ num) & ~ones
  }

  return ones
}
```

Steps (~12-15 steps, 8-bit):
- Input: [2, 2, 3, 2]
- Track bits seen once (ones) and twice (twos)
- Show how num cycles through: 1st appearance -> ones, 2nd -> twos, 3rd -> cleared
- Final: ones = 3

Insight: "Track bits seen once and twice. Third appearance clears both. After all nums, ones holds the single number."

**Bit Masks Advanced: Subset Generation**
Generate all subsets using bit masking.

```javascript
function subsets(nums) {
  const n = nums.length
  const result = []

  for (let mask = 0; mask < (1 << n); mask++) {
    const subset = []
    for (let i = 0; i < n; i++) {
      if (mask & (1 << i)) subset.push(nums[i])
    }
    result.push(subset)
  }

  return result
}
```

Steps (~12-14 steps, 4-bit width for clarity):
- nums = [a, b, c]
- mask = 0 (000) -> []
- mask = 1 (001) -> [a]
- mask = 2 (010) -> [b]
- mask = 3 (011) -> [a, b]
- Continue through all 8 combinations
- Show which bits correspond to which elements

Insight: "Each bit position represents include/exclude for that element. 2^n masks = 2^n subsets."

**Shift Operations Advanced: Find Two Non-Repeating Numbers**
Array where every element appears twice except two.

```javascript
function findTwoNumbers(nums) {
  let xorAll = 0
  for (const num of nums) xorAll ^= num

  const diffBit = xorAll & -xorAll  // lowest set bit

  let a = 0, b = 0
  for (const num of nums) {
    if (num & diffBit) a ^= num
    else b ^= num
  }

  return [a, b]
}
```

Steps (~14-16 steps, 8-bit):
- Input: [1, 2, 1, 3, 2, 5]
- XOR all -> 3 ^ 5 = 6 (binary: 110)
- Find lowest set bit: 6 & -6 = 2 (bit position 1)
- Partition: numbers with bit 1 set vs not set
- XOR each partition -> [3, 5]

Insight: "XOR all gives a^b. Find a bit where they differ. Partition by that bit to separate a and b, then XOR each group."
  </action>
  <verify>
    - examples['xor-tricks']['advanced'] has Single Number II
    - examples['bit-masks']['advanced'] has Subset Generation
    - examples['shift-operations']['advanced'] has Find Two Numbers
    - Each example has 12+ steps
    - npm run build passes
    - npm run lint passes
  </verify>
  <done>
    Advanced examples added for all three variants.
    All 9 variant/level combinations now have examples.
    BitManipulationViz phase complete.
  </done>
</task>

</tasks>

<verification>
- npm run build passes
- npm run lint passes
- Navigate to /concepts/dsa/patterns/bit-manipulation
- All 9 combinations (3 variants x 3 levels) have examples:
  - XOR Tricks: Single Number (B), Missing Number (I), Single Number II (A)
  - Bit Masks: Power of Two (B), Counting Bits (I), Subset Generation (A)
  - Shift Ops: Multiply/Divide (B), Reverse Bits (I), Find Two Numbers (A)
- Each example can be stepped through completely
- Code highlighting syncs with steps
- Binary grid shows operations correctly
- Active bits highlight appropriately
</verification>

<success_criteria>
- 6 new examples added (2 per variant: intermediate + advanced)
- Total 9 examples across all variant/level combinations
- All examples have code, steps, and insight
- Complexity increases appropriately per level
- All success criteria from Phase 10 roadmap met:
  1. User navigates to /concepts/dsa/patterns/bit-manipulation - CHECK
  2. Switch between beginner/intermediate/advanced - CHECK
  3. Binary representation with configurable bit width - CHECK (4, 8 per example)
  4. Active bit highlighting - CHECK
  5. Bit-by-bit operation animation - CHECK
  6. Operation result with explanation - CHECK
- Build and lint pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-bitmanipulationviz/10-03-SUMMARY.md`
</output>
