---
phase: 05-arraysbasicsviz
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/components/Concepts/ArraysBasicsViz.tsx
  - src/components/Concepts/ArraysBasicsViz.module.css
autonomous: true

must_haves:
  truths:
    - "Spread operator creates visually distinct NEW array"
    - "Spread elements animate flying out of source into new array"
    - "User can distinguish true copy from reference copy"
    - "Warning badge appears when mutation affects shared references"
  artifacts:
    - path: "src/components/Concepts/ArraysBasicsViz.tsx"
      provides: "Intermediate examples for spread operator"
      contains: "spread"
    - path: "src/components/Concepts/ArraysBasicsViz.module.css"
      provides: "Spread animation styles"
      contains: "spreadElement"
  key_links:
    - from: "intermediate examples"
      to: "heap display"
      via: "multiple heap objects with different ids"
      pattern: "id:.*array2"
---

<objective>
Add intermediate examples demonstrating spread operator and true copy vs reference copy.

Purpose: Learners understand how [...arr] creates a genuinely new array in heap (independent), contrasted with arr2 = arr1 (shared reference).

Output: Intermediate examples with spread operator visualization and warning badges for shared reference mutations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-arraysbasicsviz/05-CONTEXT.md
@.planning/phases/05-arraysbasicsviz/05-RESEARCH.md
@.planning/phases/05-arraysbasicsviz/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create intermediate examples for spread operator</name>
  <files>src/components/Concepts/ArraysBasicsViz.tsx</files>
  <action>
Add intermediate examples array with 3 examples demonstrating spread operator and copy behavior:

**Example 1: "Spread creates a copy"**
Code:
```javascript
let arr1 = [1, 2, 3]
let arr2 = [...arr1]

arr2.push(4)

console.log(arr1)
console.log(arr2)
```

Steps:
1. setup: Script starts
2. reference: `let arr1 = [1,2,3]` - array in heap as #1
3. reference: `let arr2 = [...arr1]` - NEW array in heap as #2, highlight 'new'. Both have same elements but different ids.
4. mutate: `arr2.push(4)` - only #2 mutated, #1 unchanged
5. result: console.log shows arr1=[1,2,3], arr2=[1,2,3,4]

Insight: "The spread operator [...arr] creates a NEW array in memory. Changes to the copy don't affect the original!"

**Example 2: "Reference copy vs Spread copy"**
Code comparing both side by side:
```javascript
let original = [1, 2, 3]

// Reference copy (shared)
let refCopy = original
refCopy.push(4)

// Spread copy (independent)
let spreadCopy = [...original]
spreadCopy.push(5)

console.log(original)
```

Steps showing:
- After refCopy.push(4): original AND refCopy both have [1,2,3,4]
- After spreadCopy.push(5): only spreadCopy has [1,2,3,4,5], original still [1,2,3,4]

Insight: "Reference copy (=) shares the same array. Spread copy ([...]) creates an independent array."

**Example 3: "Shallow copy warning"**
Code showing nested arrays:
```javascript
let matrix = [[1, 2], [3, 4]]
let copy = [...matrix]

copy[0].push(99)

console.log(matrix[0])
```

Steps demonstrating that spread only does shallow copy - nested arrays are still shared.

Insight: "Spread creates a SHALLOW copy. Nested arrays/objects are still shared references!"

Each step should use the phase field appropriately:
- 'setup' for initial declarations
- 'reference' for creating references/copies
- 'mutate' for modifications
- 'result' for console.log output
  </action>
  <verify>`npm run build` passes, intermediate array has 3 examples</verify>
  <done>3 intermediate examples demonstrating spread operator vs reference copy</done>
</task>

<task type="auto">
  <name>Task 2: Add spread animation and warning badge styling</name>
  <files>src/components/Concepts/ArraysBasicsViz.tsx, src/components/Concepts/ArraysBasicsViz.module.css</files>
  <action>
**Add spread element animation in component:**

When a step involves spread operator (detect via description containing "spread" or "[...]"):
1. Show source array elements with subtle "flying out" animation
2. Show target array with elements "flying in" animation

Use Framer Motion for this:
- Elements in source array briefly scale up and shift right
- Elements in new heap array animate in from left with stagger delay

**Add warning badge for shared reference mutation:**

When currentStep.phase === 'mutate' AND multiple stack items have same refId:
- Display warning badge above the heap section or inline
- Text: "Both {var1} and {var2} affected!" (derive from stack items with matching refId)
- Style: amber/orange background, warning icon optional

**CSS additions:**

```css
/* Spread animation */
.spreadSource .element {
  animation: spreadOut 0.4s ease-out forwards;
}

@keyframes spreadOut {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1) translateX(10px); opacity: 0.8; }
  100% { transform: scale(1); opacity: 1; }
}

.spreadTarget .element {
  animation: spreadIn 0.4s ease-out forwards;
  animation-delay: calc(var(--index) * 0.1s);
}

@keyframes spreadIn {
  0% { transform: translateX(-20px); opacity: 0; }
  100% { transform: translateX(0); opacity: 1; }
}

/* Warning badge */
.warningBadge {
  background: rgba(245, 158, 11, 0.15);
  border: 1px solid #f59e0b;
  color: #f59e0b;
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  font-weight: 500;
  margin-bottom: 0.75rem;
  text-align: center;
}
```

**Component logic for warning badge:**

```typescript
const getSharedReferenceVars = () => {
  if (currentStep.phase !== 'mutate') return null
  const refCounts: Record<string, string[]> = {}
  currentStep.stack.forEach(item => {
    if (item.isReference && item.refId) {
      if (!refCounts[item.refId]) refCounts[item.refId] = []
      refCounts[item.refId].push(item.name)
    }
  })
  for (const [refId, vars] of Object.entries(refCounts)) {
    if (vars.length > 1) return vars
  }
  return null
}

// In render:
const sharedVars = getSharedReferenceVars()
{sharedVars && (
  <div className={styles.warningBadge}>
    Both {sharedVars.join(' and ')} affected!
  </div>
)}
```
  </action>
  <verify>
- `npm run build` passes
- `npm run dev` - intermediate examples visible
- Spread operator steps show animation effect
- Mutation steps with shared references show warning badge
  </verify>
  <done>Spread animation effects implemented, warning badge appears for shared reference mutations</done>
</task>

</tasks>

<verification>
Run after all tasks:
- [ ] `npm run build` completes without errors
- [ ] `npm run lint` passes
- [ ] Intermediate level accessible and shows 3 examples
- [ ] Spread operator example shows TWO separate heap objects
- [ ] Spread animation visible (elements animate)
- [ ] Warning badge appears: "Both refCopy and original affected!"
- [ ] Shallow copy example demonstrates nested array sharing
</verification>

<success_criteria>
1. 3 intermediate examples added and working
2. Spread operator creates visibly distinct heap objects
3. Spread animation provides visual "unpacking" effect
4. Warning badge appears on shared reference mutations
5. Shallow copy gotcha demonstrated clearly
</success_criteria>

<output>
After completion, create `.planning/phases/05-arraysbasicsviz/05-02-SUMMARY.md`
</output>
