---
phase: 06-objectsbasicsviz
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/components/Concepts/ObjectsBasicsViz.tsx
autonomous: true

must_haves:
  truths:
    - "User can step through object spread creating shallow copy"
    - "User can step through property addition and deletion examples"
    - "User can step through nested object examples showing shared inner references"
    - "Warning badge appears when mutation affects multiple references"
    - "Shallow copy warning visible when nested objects share references after spread"
  artifacts:
    - path: "src/components/Concepts/ObjectsBasicsViz.tsx"
      provides: "Intermediate examples with spread, property mutation, nested objects"
      contains: "spread"
  key_links:
    - from: "intermediate examples"
      to: "warningBadge"
      via: "getSharedRefWarning during mutate phase"
      pattern: "sharedRefVars.*warningBadge"
---

<objective>
Add intermediate examples demonstrating object spread, property operations, and nested object behavior.

Purpose: Teach shallow copy semantics, property addition/deletion, and the gotcha where nested objects remain shared after spread.
Output: 3 intermediate examples with complete step data and warning badge integration.
</objective>

<execution_context>
@/Users/sunnywilson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunnywilson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-objectsbasicsviz/06-RESEARCH.md
@.planning/phases/06-objectsbasicsviz/06-01-SUMMARY.md
@src/components/Concepts/ArraysBasicsViz.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add spread operator example</name>
  <files>src/components/Concepts/ObjectsBasicsViz.tsx</files>
  <action>
Add to intermediate array in examples:

Example: "Spread creates a copy"
```javascript
const original = { name: 'Alice', age: 25 }
const copy = { ...original }

copy.name = 'Bob'

console.log(original.name)
console.log(copy.name)
```

Steps:
1. Setup: Script starts, stack/heap empty
2. Create original object in heap #1, original -> #1 in stack
3. Spread creates NEW object #2 in heap, copy -> #2 in stack. Description: "{ ...original } - Spread creates a NEW object with copied properties"
4. Mutate copy.name = 'Bob' - only #2 changes, #1 unaffected
5. console.log(original.name) outputs "Alice" - original unchanged
6. console.log(copy.name) outputs "Bob" - only copy changed

Insight: "Spread { ...obj } creates a NEW object. Changes to the copy don't affect the original!"

Use phase: 'spread' for spread step, phase: 'mutate' for mutation step.
  </action>
  <verify>Example compiles, navigate to intermediate level shows tab</verify>
  <done>Spread copy example with 6+ steps demonstrating independent objects</done>
</task>

<task type="auto">
  <name>Task 2: Add property operations example</name>
  <files>src/components/Concepts/ObjectsBasicsViz.tsx</files>
  <action>
Add to intermediate array:

Example: "Adding and deleting properties"
```javascript
const user = { name: 'Alice' }
const ref = user

user.email = 'alice@test.com'
delete user.name

console.log(ref)
```

Steps:
1. Setup: Script starts
2. Create user object in heap #1 with {name: 'Alice'}
3. ref = user - ref -> #1, both point to same object
4. user.email = 'alice@test.com' - Add property with highlight: 'new' on email property
5. delete user.name - Show name property with highlight: 'deleted' (strikethrough)
6. After delete - Show object without name property, only email remains
7. console.log(ref) outputs {email: 'alice@test.com'} - ref sees both changes

Insight: "Adding and deleting properties modifies the object. All references see the changes!"

For delete step, first show property with highlight: 'deleted', then in next step remove it from properties array.
  </action>
  <verify>Example compiles, property deletion shows strikethrough then removal</verify>
  <done>Property operations example with add/delete visualization</done>
</task>

<task type="auto">
  <name>Task 3: Add shallow copy warning example</name>
  <files>src/components/Concepts/ObjectsBasicsViz.tsx</files>
  <action>
Add to intermediate array:

Example: "Shallow copy warning"
```javascript
const person = {
  name: 'Alice',
  address: { city: 'NYC' }
}
const copy = { ...person }

copy.address.city = 'LA'

console.log(person.address.city)
```

Steps:
1. Setup: Script starts
2. Create person object #1 with name: 'Alice' and address: '-> #2' (reference to nested object)
3. Create address object #2 with city: 'NYC' in heap
4. Spread creates NEW outer object #3, copy -> #3. Key insight: address property still shows '-> #2' - nested object NOT copied!
5. copy.address.city = 'LA' - Mutates #2. Both person AND copy share this nested object. Show warning badge: "Both person.address and copy.address affected!"
6. console.log(person.address.city) outputs "LA" - person sees the change despite using spread!

Insight: "Spread creates a SHALLOW copy. Nested objects are still shared references!"

Make sure getSharedRefWarning also checks heap object properties for shared refIds, not just stack items. Update if needed:
```typescript
const getSharedRefWarning = () => {
  if (!currentStep || currentStep.phase !== 'mutate') return null

  const refCounts = new Map<string, string[]>()

  // Check stack references
  currentStep.stack.forEach(item => {
    if (item.isReference && item.refId) {
      const existing = refCounts.get(item.refId) || []
      existing.push(item.name)
      refCounts.set(item.refId, existing)
    }
  })

  // Check heap property references (for nested objects)
  currentStep.heap.forEach(obj => {
    obj.properties.forEach(prop => {
      if (prop.isReference && prop.refId) {
        const existing = refCounts.get(prop.refId) || []
        existing.push(`${obj.label}.${prop.key}`)
        refCounts.set(prop.refId, existing)
      }
    })
  })

  for (const [, names] of refCounts) {
    if (names.length > 1) {
      return names
    }
  }
  return null
}
```
  </action>
  <verify>Shallow copy example shows nested object shared reference, warning badge appears on nested mutation</verify>
  <done>Shallow copy warning example with nested object visualization and enhanced getSharedRefWarning</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - no errors
2. Navigate to /concepts/objects-basics
3. Select "Intermediate" level
4. Test "Spread creates a copy":
   - Step through to see #1 and #2 as separate objects
   - Confirm mutation only affects one
   - Verify independent output values
5. Test "Adding and deleting properties":
   - See email property added with green highlight
   - See name property with strikethrough before removal
   - Confirm ref sees all changes
6. Test "Shallow copy warning":
   - See nested address object as #2 referenced by both #1 and #3
   - Mutation step shows warning badge about shared references
   - Output confirms person.address.city changed
</verification>

<success_criteria>
- 3 intermediate examples render and step through correctly
- Spread creates visually separate heap objects with same property values
- Property addition shows 'new' highlight, deletion shows strikethrough
- Shallow copy example clearly shows nested object still shared
- Warning badge appears for nested object mutation
</success_criteria>

<output>
After completion, create `.planning/phases/06-objectsbasicsviz/06-02-SUMMARY.md`
</output>
