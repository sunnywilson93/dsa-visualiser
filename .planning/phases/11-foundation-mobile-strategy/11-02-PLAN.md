---
phase: 11-foundation-mobile-strategy
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/getCrossLinks.ts
autonomous: true

must_haves:
  truths:
    - "getRelatedPatterns returns pattern links for a given problem ID"
    - "getRelatedProblems returns problem links for a given pattern ID"
    - "getCrossLinks provides unified interface for both directions"
    - "Functions handle missing/unknown IDs gracefully (return empty array)"
  artifacts:
    - path: "src/utils/getCrossLinks.ts"
      provides: "Cross-link utility functions"
      exports: ["CrossLink", "getRelatedPatterns", "getRelatedProblems", "getCrossLinks"]
      min_lines: 50
  key_links:
    - from: "src/utils/getCrossLinks.ts"
      to: "src/data/dsaPatterns.ts"
      via: "import dsaPatterns"
      pattern: "import.*dsaPatterns"
    - from: "src/utils/getCrossLinks.ts"
      to: "src/data/algorithmConcepts.ts"
      via: "import problemConcepts"
      pattern: "import.*problemConcepts"
---

<objective>
Create cross-link utility functions for pattern-problem relationships.

Purpose: Phase 13 (Cross-Linking) will use these utilities to render "Practice this pattern" and "Learn the pattern" sections. Building utilities now keeps Phase 13 focused on UI components.

Output:
- getCrossLinks.ts with getRelatedPatterns, getRelatedProblems, getCrossLinks functions
- CrossLink type for consistent link structure
</objective>

<execution_context>
@/Users/sunnywilson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunnywilson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-foundation-mobile-strategy/11-RESEARCH.md

@src/data/dsaPatterns.ts
@src/data/algorithmConcepts.ts
@src/data/examples.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cross-link utility module</name>
  <files>src/utils/getCrossLinks.ts</files>
  <action>
Create src/utils directory if needed, then create getCrossLinks.ts with cross-linking utilities.

**Analysis of existing data structures:**

1. `dsaPatterns` (from dsaPatterns.ts):
   - Has `id`, `name`, `slug`, `description`
   - Has `relatedProblems?: string[]` with problem IDs

2. `problemConcepts` (from algorithmConcepts.ts):
   - Record<string, ProblemConcept>
   - Each ProblemConcept has `pattern: ConceptType` (e.g., 'two-pointers-converge')

3. `codeExamples` (from examples.ts):
   - Array of problems with `id`, `name`, `category`, `description`

**Create src/utils/getCrossLinks.ts:**

```typescript
import { dsaPatterns } from '@/data/dsaPatterns'
import { problemConcepts } from '@/data/algorithmConcepts'
import { codeExamples } from '@/data/examples'

export interface CrossLink {
  type: 'pattern' | 'problem'
  id: string
  name: string
  href: string
  description?: string
}

/**
 * Get related patterns for a problem
 * Uses problemConcepts to find which pattern a problem belongs to
 */
export function getRelatedPatterns(problemId: string): CrossLink[] {
  const concept = problemConcepts[problemId]
  if (!concept) return []

  // Extract base pattern from concept.pattern (e.g., 'two-pointers-converge' -> 'two-pointers')
  const patternBase = concept.pattern.split('-').slice(0, 2).join('-')

  // Find matching patterns
  return dsaPatterns
    .filter(pattern =>
      pattern.id === patternBase ||
      concept.pattern.startsWith(pattern.id) ||
      pattern.relatedProblems?.includes(problemId)
    )
    .map(pattern => ({
      type: 'pattern' as const,
      id: pattern.id,
      name: pattern.name,
      href: `/concepts/dsa/patterns/${pattern.slug}`,
      description: pattern.description,
    }))
}

/**
 * Get related problems for a pattern
 * Uses both explicit relatedProblems and problemConcepts pattern matching
 */
export function getRelatedProblems(patternId: string): CrossLink[] {
  const pattern = dsaPatterns.find(p => p.id === patternId)
  if (!pattern) return []

  // Find problems that use this pattern via problemConcepts
  const problemsByPattern = Object.entries(problemConcepts)
    .filter(([_, concept]) => concept.pattern.startsWith(patternId))
    .map(([id]) => id)

  // Combine with explicitly listed related problems
  const allRelatedIds = new Set([
    ...problemsByPattern,
    ...(pattern.relatedProblems || [])
  ])

  return Array.from(allRelatedIds)
    .map(problemId => {
      const problem = codeExamples.find(p => p.id === problemId)
      if (!problem) return null

      return {
        type: 'problem' as const,
        id: problem.id,
        name: problem.name,
        href: `/${problem.category}/${problem.id}`,
        description: problem.description,
      }
    })
    .filter((link): link is CrossLink => link !== null)
}

/**
 * Unified cross-link getter for any context
 */
export function getCrossLinks(
  context: { type: 'problem' | 'pattern'; id: string }
): { patterns: CrossLink[]; problems: CrossLink[] } {
  if (context.type === 'problem') {
    return {
      patterns: getRelatedPatterns(context.id),
      problems: [],
    }
  }

  return {
    patterns: [],
    problems: getRelatedProblems(context.id),
  }
}
```

Key implementation notes:
- Pattern matching extracts base pattern ID from concept.pattern (handles 'two-pointers-converge' -> 'two-pointers')
- Uses both explicit relatedProblems AND derived relationships from problemConcepts
- Returns empty arrays for unknown IDs (graceful handling)
- href generation uses existing URL patterns from the project
  </action>
  <verify>
1. mkdir -p src/utils (ensure directory exists)
2. cat src/utils/getCrossLinks.ts (verify file contents)
3. Check imports resolve: npm run build
  </verify>
  <done>getCrossLinks.ts exports CrossLink type and three functions: getRelatedPatterns, getRelatedProblems, getCrossLinks</done>
</task>

<task type="auto">
  <name>Task 2: Add basic test verification for cross-link functions</name>
  <files>src/utils/getCrossLinks.ts</files>
  <action>
Verify the cross-link functions work correctly by testing with known data.

Run quick verification commands in the build:

1. Verify TypeScript compiles:
```bash
npx tsc --noEmit
```

2. Verify the module can be imported (no runtime errors):
```bash
npm run build
```

The functions should handle:
- getRelatedPatterns('two-sum-ii') -> returns two-pointers pattern link
- getRelatedProblems('two-pointers') -> returns two-sum, three-sum, etc.
- getRelatedPatterns('unknown-problem') -> returns []
- getRelatedProblems('unknown-pattern') -> returns []

No formal test file needed for this utility - TypeScript types ensure interface correctness, and manual verification confirms data relationships work.
  </action>
  <verify>
1. npm run build succeeds
2. npx tsc --noEmit passes
3. grep "export function" src/utils/getCrossLinks.ts shows all three functions
  </verify>
  <done>Cross-link utilities compile and build successfully, ready for Phase 13 consumption</done>
</task>

</tasks>

<verification>
1. npm run build completes without errors
2. npm run lint passes
3. src/utils/getCrossLinks.ts exports CrossLink, getRelatedPatterns, getRelatedProblems, getCrossLinks
4. Imports from @/data/ resolve correctly
</verification>

<success_criteria>
- getCrossLinks.ts exists in src/utils/
- Exports CrossLink interface with type, id, name, href, description fields
- getRelatedPatterns(problemId) returns pattern links or empty array
- getRelatedProblems(patternId) returns problem links or empty array
- getCrossLinks(context) provides unified interface
- Build and lint pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-foundation-mobile-strategy/11-02-SUMMARY.md`
</output>
