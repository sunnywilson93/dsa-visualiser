---
phase: 02-loopsviz
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/components/Concepts/LoopsViz.tsx
  - src/components/Concepts/LoopsViz.module.css
autonomous: true

must_haves:
  truths:
    - "User can select intermediate level and see 4 examples (break, continue, complex while, for...of with index)"
    - "User can select advanced level and see 4 examples (nested loop, var closure bug, let closure fix, do-while)"
    - "Closure capture bug example shows setTimeout callbacks all logging same value with var"
    - "Closure capture fix example shows setTimeout callbacks each logging different value with let"
    - "Binding visualization shows single shared binding (var) vs per-iteration bindings (let)"
  artifacts:
    - path: "src/components/Concepts/LoopsViz.tsx"
      provides: "Complete LoopsViz with all 12 examples across 3 difficulty levels"
      contains: "closure"
    - path: "src/components/Concepts/LoopsViz.module.css"
      provides: "Closure binding visualization styles"
      contains: "bindingsPanel"
  key_links:
    - from: "intermediate examples"
      to: "examples Record"
      via: "array population"
      pattern: "intermediate:.*LoopExample"
    - from: "advanced examples"
      to: "examples Record"
      via: "array population"
      pattern: "advanced:.*LoopExample"
---

<objective>
Add intermediate and advanced examples to LoopsViz, including the critical closure capture bug demonstration. Intermediate examples cover control flow (break, continue) and more complex patterns. Advanced examples include nested loops, the var vs let closure bug (common interview topic), and do-while.

Purpose: Complete the LoopsViz example coverage across all difficulty levels, with special attention to the closure capture bug which is frequently asked in interviews and commonly misunderstood.

Output: All 12 loop examples populated (4 beginner + 4 intermediate + 4 advanced), with closure binding visualization panel for var vs let comparison.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-loopsviz/02-CONTEXT.md
@.planning/phases/02-loopsviz/02-RESEARCH.md
@.planning/phases/02-loopsviz/02-01-SUMMARY.md (created by prior plan)
@src/components/Concepts/LoopsViz.tsx (updated by prior plan)
@src/components/Concepts/LoopsViz.module.css (updated by prior plan)
@src/components/Concepts/ClosuresViz.tsx (reference for closure visualization pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add intermediate example data</name>
  <files>src/components/Concepts/LoopsViz.tsx</files>
  <action>
Add 4 intermediate examples to the `examples.intermediate` array:

**Example 1: for loop with break**
```javascript
const nums = [1, 2, 3, 4, 5]

for (let i = 0; i < nums.length; i++) {
  if (nums[i] === 3) break
  console.log(nums[i])
}
```
Steps show: iteration 0 (log 1), iteration 1 (log 2), iteration 2 (condition check for break - true, exits). Intermediate descriptions: more concise than beginner.
Key insight: "break immediately exits the entire loop, not just the current iteration"

**Example 2: for loop with continue**
```javascript
const nums = [1, 2, 3, 4, 5]

for (let i = 0; i < nums.length; i++) {
  if (nums[i] === 3) continue
  console.log(nums[i])
}
```
Steps show: each iteration, with iteration 2 skipping the log. Show continue skipping to update phase.
Key insight: "continue skips to the next iteration, not breaking out of the loop"

**Example 3: while with complex condition**
```javascript
let count = 0
let found = false

while (count < 5 && !found) {
  if (count === 3) found = true
  console.log(count)
  count++
}
```
Steps show: both parts of the condition evaluated, found changing state mid-loop.
Key insight: "Multiple conditions can control loop termination - useful for search patterns"

**Example 4: for...of with index**
```javascript
const fruits = ['apple', 'banana', 'cherry']

for (const [index, fruit] of fruits.entries()) {
  console.log(index, fruit)
}
```
Steps show: entries() providing [index, value] pairs, destructuring in loop header.
Key insight: "entries() gives you both index and value - best of both worlds"

Intermediate descriptions should be more technical and terse:
- "break encountered: loop exits immediately"
- "continue: skip remaining body, proceed to update"
- "Condition: count < 5 (true) && !found (true) = true"
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>4 intermediate examples added with complete step data; intermediate tab now shows 4 examples</done>
</task>

<task type="auto">
  <name>Task 2: Add advanced example data including closure capture</name>
  <files>src/components/Concepts/LoopsViz.tsx</files>
  <action>
Add 4 advanced examples to the `examples.advanced` array:

**Example 1: Nested for loop**
```javascript
for (let i = 0; i < 2; i++) {
  for (let j = 0; j < 2; j++) {
    console.log(i, j)
  }
}
```
Steps show: outer loop iteration 0, inner loop completes all iterations, outer loop iteration 1, inner loop completes again. Keep iterations minimal (2x2 = 4 outputs) to avoid step overload.
Key insight: "Inner loop completes ALL iterations for EACH outer iteration"

**Example 2: Closure capture bug (var)**
```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i)
  }, 100)
}
// Later: 3, 3, 3
```
Steps:
1. Loop init: i = 0, callback 1 created (captures i by reference)
2. i = 1, callback 2 created (same i reference)
3. i = 2, callback 3 created (same i reference)
4. i = 3, loop condition false, loop exits
5. "All 3 callbacks share ONE binding to i, which is now 3"
6. Callback 1 fires: logs 3 (not 0!)
7. Callback 2 fires: logs 3 (not 1!)
8. Callback 3 fires: logs 3 (not 2!)
9. Done - "This is the classic closure bug!"

Add `bindings` field to steps showing single shared binding.

Key insight: "var creates ONE binding for the entire loop - all callbacks share it"

**Example 3: Closure capture fix (let)**
```javascript
for (let i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i)
  }, 100)
}
// Later: 0, 1, 2
```
Steps mirror the var example but show SEPARATE bindings:
1. Loop init: i = 0, callback 1 created, binding 0 created
2. i = 1, callback 2 created, binding 1 created
3. i = 2, callback 3 created, binding 2 created
4. Loop exits
5. "Each callback has its OWN binding capturing the value at that iteration"
6. Callback 1 fires: logs 0 (correct!)
7. Callback 2 fires: logs 1 (correct!)
8. Callback 3 fires: logs 2 (correct!)

Add `bindings` field showing 3 separate bindings.

Key insight: "let creates a NEW binding for EACH iteration - each callback gets its own"

**Example 4: do-while**
```javascript
let i = 5

do {
  console.log(i)
  i++
} while (i < 3)

// Logs 5 (body runs once even though condition is false)
```
Steps:
1. i = 5 initialized
2. Body executes FIRST (logs 5)
3. i++ (i = 6)
4. Condition check: 6 < 3 = false
5. Loop exits after ONE iteration
Key insight: "do-while ALWAYS executes the body at least once, then checks condition"

Advanced descriptions: Terse, assumes full understanding:
- "Callback created, captures i by reference"
- "All 3 timeouts fired: each logs current i (3)"
- "Per-iteration binding: callback 1 -> i_0 = 0"
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>4 advanced examples added including closure capture var/let comparison with bindings data</done>
</task>

<task type="auto">
  <name>Task 3: Add closure binding visualization panel and CSS</name>
  <files>
    src/components/Concepts/LoopsViz.tsx
    src/components/Concepts/LoopsViz.module.css
  </files>
  <action>
**In LoopsViz.tsx:**

1. Extend the LoopStep interface if needed:
```typescript
interface LoopBinding {
  iteration: number
  variableName: string
  value: number | string
  callbacks?: string[]  // Which callbacks reference this binding
}

// In LoopStep:
bindings?: LoopBinding[]
```

2. Add bindings panel to the component JSX (conditionally rendered when step.bindings exists):
```tsx
{currentStep.bindings && (
  <div className={styles.bindingsPanel}>
    <div className={styles.boxHeader}>
      {currentStep.bindings.length === 1 ? 'Shared Binding (var)' : 'Per-Iteration Bindings (let)'}
    </div>
    <div className={styles.bindingsGrid}>
      {currentStep.bindings.map((binding, i) => (
        <motion.div
          key={`${binding.iteration}-${binding.value}`}
          className={`${styles.bindingBox} ${currentStep.bindings!.length === 1 ? styles.sharedBinding : styles.separateBinding}`}
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
        >
          <div className={styles.bindingIteration}>
            {currentStep.bindings!.length === 1 ? 'All iterations' : `Iteration ${binding.iteration}`}
          </div>
          <div className={styles.bindingValue}>
            {binding.variableName} = {binding.value}
          </div>
          {binding.callbacks && binding.callbacks.length > 0 && (
            <div className={styles.callbackRefs}>
              {binding.callbacks.map(cb => (
                <span key={cb} className={styles.callbackRef}>{cb}</span>
              ))}
            </div>
          )}
        </motion.div>
      ))}
    </div>
  </div>
)}
```

**In LoopsViz.module.css:**

Add styles for the binding visualization:
```css
.bindingsPanel {
  background: rgba(0, 0, 0, 0.4);
  border: 1px solid var(--js-viz-border);
  border-radius: var(--radius-xl);
  overflow: hidden;
  margin-top: var(--space-md);
}

.bindingsGrid {
  display: flex;
  gap: var(--space-sm);
  padding: var(--space-md);
  flex-wrap: wrap;
  justify-content: center;
}

.bindingBox {
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--radius-lg);
  min-width: 100px;
  text-align: center;
}

.sharedBinding {
  background: rgba(239, 68, 68, 0.15);
  border: 1px solid rgba(239, 68, 68, 0.3);
}

.separateBinding {
  background: rgba(16, 185, 129, 0.15);
  border: 1px solid rgba(16, 185, 129, 0.3);
}

.bindingIteration {
  font-size: var(--text-xs);
  color: var(--gray-500);
  margin-bottom: var(--space-xs);
}

.bindingValue {
  font-family: 'Fira Code', monospace;
  font-size: var(--text-sm);
  font-weight: var(--font-semibold);
  color: var(--color-white);
}

.callbackRefs {
  display: flex;
  gap: var(--space-xs);
  margin-top: var(--space-xs);
  justify-content: center;
  flex-wrap: wrap;
}

.callbackRef {
  font-size: var(--text-2xs);
  color: var(--gray-400);
  padding: 2px 6px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: var(--radius-sm);
}
```

Visual distinction:
- var (shared binding): Red-tinted box, shows "All iterations" header
- let (separate bindings): Green-tinted boxes, shows "Iteration N" header for each
  </action>
  <verify>
1. `npm run dev` runs without errors
2. Navigate to LoopsViz, select Advanced level
3. Click "Closure Bug (var)" example - see red single binding box
4. Click "Closure Fix (let)" example - see green multiple binding boxes
5. Step through both to see bindings panel update
  </verify>
  <done>Binding visualization panel renders for closure examples; var shows single red box, let shows multiple green boxes; callbacks listed under bindings</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run dev` - no errors
2. Level selector: All 3 levels now enabled (not grayed out)
3. Beginner: 4 examples (from 02-01)
4. Intermediate: 4 examples (break, continue, complex while, for...of with index)
5. Advanced: 4 examples (nested, var closure, let closure, do-while)
6. Step through "Closure Bug (var)":
   - Callbacks created, all reference same i
   - Loop exits with i=3
   - All callbacks log 3
   - Red "Shared Binding" panel shows single box
7. Step through "Closure Fix (let)":
   - Each callback gets its own binding
   - Green "Per-Iteration Bindings" panel shows 3 boxes
   - Callbacks log 0, 1, 2 respectively
8. `npm run lint` passes
</verification>

<success_criteria>
- [ ] Intermediate level shows 4 examples
- [ ] Advanced level shows 4 examples
- [ ] Closure bug (var) example has ~9 steps showing shared binding problem
- [ ] Closure fix (let) example has ~9 steps showing per-iteration bindings
- [ ] Binding visualization panel appears for closure examples
- [ ] var binding = red/shared visual treatment
- [ ] let bindings = green/separate visual treatment
- [ ] All 12 examples steppable without errors
- [ ] Difficulty-adapted descriptions (terse for intermediate/advanced)
</success_criteria>

<output>
After completion, create `.planning/phases/02-loopsviz/02-02-SUMMARY.md`
</output>
