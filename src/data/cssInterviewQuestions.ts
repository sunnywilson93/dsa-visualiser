export type CSSInterviewTopic =
  | 'core-fundamentals'
  | 'layout-systems'
  | 'modern-css'
  | 'architecture-performance'

export interface CSSInterviewQuestion {
  id: number
  title: string
  difficulty: 'easy' | 'medium' | 'hard'
  topic: CSSInterviewTopic
  subtopic: string
  answer: string
  codeExample?: string
  followUp: string
  keyTakeaway: string
}

export interface CSSTopicConfig {
  id: CSSInterviewTopic
  label: string
  description: string
}

export const cssTopics: CSSTopicConfig[] = [
  {
    id: 'core-fundamentals',
    label: 'Core Fundamentals',
    description: 'Box model, specificity, cascade, positioning, units',
  },
  {
    id: 'layout-systems',
    label: 'Layout Systems',
    description: 'Flexbox, Grid, responsive design, container queries',
  },
  {
    id: 'modern-css',
    label: 'Modern CSS',
    description: 'Selectors, variables, animations, pseudo-elements',
  },
  {
    id: 'architecture-performance',
    label: 'Architecture & Perf',
    description: 'Methodologies, render pipeline, specificity management',
  },
]

export const cssTopicMap: Record<CSSInterviewTopic, CSSTopicConfig> =
  Object.fromEntries(cssTopics.map((t) => [t.id, t])) as Record<CSSInterviewTopic, CSSTopicConfig>

export const cssInterviewQuestions: CSSInterviewQuestion[] = [
{
  id: 1,
  title: 'What is the CSS box model?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'box-model',
  answer: 'The CSS box model describes the rectangular boxes generated for every element in the document tree. It consists of four areas: content (the actual text or image), padding (transparent space around the content), border (a line around the padding), and margin (transparent space outside the border). These four layers wrap around every element, and together they determine the total space an element occupies on the page. Understanding the box model is essential because it governs how elements are sized and how they interact with neighboring elements.',
  codeExample: '/* Total width = content + padding + border + margin */\n.box {\n  width: 200px;\n  padding: 20px;\n  border: 5px solid black;\n  margin: 10px;\n  /* Total horizontal space = 10 + 5 + 20 + 200 + 20 + 5 + 10 = 270px */\n}',
  followUp: 'How does `box-sizing: border-box` change the way width and height are calculated?',
  keyTakeaway: 'Every element is a box made of content, padding, border, and margin — total size is the sum of all four.',
},
{
  id: 2,
  title: 'What is the difference between `box-sizing: content-box` and `box-sizing: border-box`?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'box-model',
  answer: 'With `content-box` (the default), the `width` and `height` properties set only the content area size, so padding and border are added on top, increasing the total rendered size. With `border-box`, the `width` and `height` include content, padding, and border, so adding padding or border shrinks the content area instead of expanding the total size. This makes layout math much simpler because the element never exceeds its declared width. Most modern CSS resets apply `box-sizing: border-box` to all elements via the universal selector.',
  codeExample: '*, *::before, *::after {\n  box-sizing: border-box;\n}\n\n.card {\n  width: 300px;\n  padding: 20px;\n  border: 2px solid gray;\n  /* With border-box: total width stays 300px */\n  /* With content-box: total width = 300 + 40 + 4 = 344px */\n}',
  followUp: 'Does `box-sizing` affect the margin calculation?',
  keyTakeaway: '`border-box` means the declared width IS the final width — padding and border eat inward, not outward.',
},
{
  id: 3,
  title: 'What is margin collapsing and when does it occur?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'box-model',
  answer: 'Margin collapsing is a behavior where the vertical margins of adjacent block-level elements combine into a single margin equal to the larger of the two margins, rather than adding them together. It occurs in three scenarios: adjacent siblings (the bottom margin of one and the top margin of the next collapse), parent and first/last child (if there is no border, padding, or inline content separating them), and empty blocks (top and bottom margins on the same element collapse). Horizontal margins never collapse. This behavior only applies in normal block flow — elements in flex or grid containers do not experience margin collapsing.',
  codeExample: '.box-a {\n  margin-bottom: 30px;\n}\n.box-b {\n  margin-top: 20px;\n}\n/* The gap between them is 30px, NOT 50px */\n/* The larger margin wins */.',
  followUp: 'Name three ways to prevent margin collapsing between a parent and its first child.',
  keyTakeaway: 'Vertical margins of adjacent block elements merge — the larger margin wins, they do not add up.',
},
{
  id: 4,
  title: 'How do negative margins work, and how do they differ from positive margins?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'box-model',
  answer: 'Negative margins pull an element (or its neighbors) in the opposite direction from what a positive margin would do. A negative `margin-top` pulls the element upward, while a negative `margin-left` pulls it to the left. When applied to the bottom or right, a negative margin pulls subsequent siblings closer rather than moving the element itself. Negative margins do participate in margin collapsing: when one margin is positive and the other is negative, the negative value is subtracted from the positive one. Unlike `transform: translate`, negative margins affect the document flow and shift surrounding elements.',
  codeExample: '.overlap {\n  margin-top: -20px; /* Pulls element 20px upward */\n}\n\n.pull-sibling {\n  margin-bottom: -20px; /* Pulls the next sibling 20px closer */\n}',
  followUp: 'What happens when two negative margins collapse?',
  keyTakeaway: 'Negative margins pull elements toward the margin direction and affect the flow of surrounding content.',
},
{
  id: 5,
  title: 'Explain how percentage-based padding is calculated. Why does `padding-top: 50%` not reference the height?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'box-model',
  answer: 'Percentage-based padding in CSS is always resolved against the width of the containing block, regardless of whether the padding is vertical or horizontal. So `padding-top: 50%` means 50% of the parent\'s width, not its height. This behavior exists because the CSS specification needed a consistent reference dimension to avoid circular dependency: an element\'s height often depends on its content, and if vertical padding depended on height, you would get a circular calculation. This behavior is commonly exploited to create aspect-ratio boxes by setting `padding-top` as a percentage on a zero-height container.',
  codeExample: '.aspect-ratio-16-9 {\n  width: 100%;\n  height: 0;\n  padding-top: 56.25%; /* 9/16 = 0.5625 */\n  position: relative;\n}\n\n.aspect-ratio-16-9 > * {\n  position: absolute;\n  inset: 0;\n}',
  followUp: 'How does the `aspect-ratio` CSS property compare to the padding-top hack?',
  keyTakeaway: 'Percentage padding always resolves against the containing block\'s width — even for top and bottom.',
},
{
  id: 6,
  title: 'What happens when you set `width: 100%` on an element with padding and no `border-box`? How can this cause overflow?',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'box-model',
  answer: 'With the default `content-box` sizing, `width: 100%` sets the content area to exactly the parent\'s content width. Padding and border are then added outside of that, causing the element\'s total rendered width to exceed its parent, resulting in horizontal overflow. For example, if the parent is 500px wide and the child has `width: 100%` plus `padding: 20px`, the child occupies 540px total. This is one of the most common CSS layout bugs. The fix is to use `box-sizing: border-box`, which causes `width: 100%` to include padding and border within that 100%. Alternatively, you can avoid explicit `width: 100%` entirely — block elements naturally stretch to fill their parent without needing a declared width.',
  codeExample: '/* BUG: overflows parent */\n.child-broken {\n  box-sizing: content-box;\n  width: 100%;\n  padding: 20px;\n  /* Total = parent-width + 40px */\n}\n\n/* FIX 1: border-box */\n.child-fixed {\n  box-sizing: border-box;\n  width: 100%;\n  padding: 20px;\n}\n\n/* FIX 2: let block flow handle it */\n.child-better {\n  /* No width declaration — block stretches naturally */\n  padding: 20px;\n}',
  followUp: 'Why does a block-level element without an explicit width not overflow in the same situation?',
  keyTakeaway: '`width: 100%` with `content-box` adds padding on top — use `border-box` or omit the width entirely.',
},
{
  id: 7,
  title: 'What is CSS specificity and why does it matter?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'specificity',
  answer: 'Specificity is the algorithm browsers use to decide which CSS rule applies when multiple rules target the same element and set the same property. It is calculated as a tuple of three components: the number of ID selectors, the number of class/attribute/pseudo-class selectors, and the number of element/pseudo-element selectors. A rule with higher specificity always wins regardless of source order. If two rules have equal specificity, the one that appears last in the stylesheet wins. Understanding specificity prevents frustrating debugging sessions where styles seem to be "ignored" when they are actually being overridden by a more specific selector.',
  codeExample: '/* Specificity: (0, 0, 1) — one element */\np { color: black; }\n\n/* Specificity: (0, 1, 0) — one class */\n.text { color: blue; }\n\n/* Specificity: (1, 0, 0) — one ID */\n#intro { color: red; }\n\n/* For <p class="text" id="intro">, color is red */',
  followUp: 'Where does inline style specificity fit in the hierarchy?',
  keyTakeaway: 'Specificity is a three-part score (IDs, classes, elements) that determines which competing rule wins.',
},
{
  id: 8,
  title: 'How do you calculate the specificity of a complex selector?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'specificity',
  answer: 'You count the number of ID selectors (column A), class selectors, attribute selectors, and pseudo-classes (column B), and element selectors and pseudo-elements (column C). The universal selector `*`, combinators (`>`, `+`, `~`, ` `), and the `:where()` pseudo-class contribute zero specificity. The `:not()` and `:is()` pseudo-classes themselves add no specificity, but the most specific argument inside them does count. You then compare tuples left to right: a higher A always beats any B or C value, and a higher B always beats any C value. Inline styles sit above all selector-based specificity, and `!important` overrides everything except another `!important` with higher specificity.',
  codeExample: '/* (0, 1, 1) — one class, one element */\ndiv.container { }\n\n/* (1, 1, 1) — one ID, one class, one element */\n#main .sidebar p { }\n\n/* (0, 2, 1) — two classes, one element */\n.nav .active a { }\n\n/* (0, 1, 0) — :not() is zero, .active counts */\n:not(.active) { }\n\n/* (0, 0, 0) — :where() always zero */\n:where(.sidebar, #main) { }',
  followUp: 'What is the difference in specificity behavior between `:is()` and `:where()`?',
  keyTakeaway: 'Count IDs, then classes/attributes/pseudo-classes, then elements — compare left to right like version numbers.',
},
{
  id: 9,
  title: 'Why is using `!important` considered bad practice, and when might it be justified?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'specificity',
  answer: '`!important` overrides normal specificity rules, which breaks the predictable cascade and makes styles extremely difficult to debug and maintain. When two declarations are both `!important`, normal specificity comparison resumes between them, leading to an arms race of increasingly specific `!important` rules. It is generally justified in only two scenarios: utility-first CSS frameworks like Tailwind use it to ensure utility classes always win, and when overriding third-party CSS that you cannot modify (e.g., widget or library styles). In your own codebase, if you feel the need for `!important`, it usually signals that your selector architecture needs refactoring.',
  followUp: 'If two `!important` rules conflict, how does the browser decide which one wins?',
  keyTakeaway: '`!important` breaks the natural cascade — reserve it for overriding third-party styles you cannot control.',
},
{
  id: 10,
  title: 'Explain the difference in specificity between `:is()`, `:not()`, `:has()`, and `:where()`. How does each affect the cascade?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'specificity',
  answer: '`:where()` always contributes zero specificity regardless of its arguments, making it ideal for creating easily overridable base styles. `:is()`, `:not()`, and `:has()` all take on the specificity of their most specific argument. So `:is(.foo, #bar)` has the specificity of an ID selector even when matching through `.foo`. The functional difference is that `:where()` was designed specifically for reset/default stylesheets where you want zero specificity impact, while `:is()` was designed for convenience grouping where you want the full specificity. `:has()` is unique as a parent selector but follows the same specificity rule as `:is()`.',
  codeExample: '/* (0, 0, 0) — :where() zeroes everything */\n:where(#sidebar .nav a) { color: gray; }\n\n/* (1, 0, 0) — :is() takes highest argument */\n:is(.nav, #sidebar) a { color: blue; }\n\n/* (1, 0, 0) — :not() takes argument specificity */\n:not(#nonexistent) { color: red; }\n\n/* (0, 1, 0) — :has() takes argument specificity */\ndiv:has(.active) { border: 1px solid; }',
  followUp: 'How would you use `:where()` to write a CSS reset that is trivially overridable?',
  keyTakeaway: '`:where()` has zero specificity; `:is()`, `:not()`, and `:has()` inherit the specificity of their strongest argument.',
},
{
  id: 11,
  title: 'How does specificity interact with the CSS cascade layers (`@layer`) introduced in CSS Cascade Layers?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'specificity',
  answer: 'Cascade layers introduce a new level of priority above specificity but below `!important` and inline styles. Within a single layer, normal specificity rules apply. However, rules in a later-declared layer always beat rules in an earlier layer, regardless of specificity. Unlayered styles beat all layered styles. This means a simple element selector in an unlayered stylesheet will override an ID selector inside a layer. For `!important` declarations, the priority inverts: `!important` rules in earlier layers beat those in later layers. This layering system lets authors manage large codebases by grouping styles into predictable priority tiers without selector specificity wars.',
  codeExample: '@layer base, components, utilities;\n\n@layer base {\n  #sidebar a { color: gray; } /* (1,0,1) but in lowest layer */\n}\n\n@layer utilities {\n  .text-red { color: red; } /* (0,1,0) but in highest layer */\n}\n\n/* .text-red WINS despite lower specificity — layer order trumps */\n\n/* Unlayered styles beat ALL layers */\na { color: blue; } /* This beats both layered rules */',
  followUp: 'How does the `!important` priority inversion work across layers, and why was it designed that way?',
  keyTakeaway: 'Layer order trumps specificity — a class in a later layer beats an ID in an earlier layer.',
},
{
  id: 12,
  title: 'Walk through the full cascade algorithm. In what order does the browser evaluate origin, importance, layer, specificity, and source order?',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'specificity',
  answer: 'The full cascade algorithm evaluates in this order: (1) Origin and importance — user-agent styles lose to author styles, which lose to author `!important`, which loses to user-agent `!important` (transition and animation origins have special placement). (2) Within the same origin, `@layer` order is checked — unlayered styles beat layered styles for normal declarations, but for `!important`, layered styles in earlier layers beat later layers. (3) Within the same layer, specificity is compared as a three-component tuple: IDs, classes/attributes/pseudo-classes, then elements/pseudo-elements. Inline styles beat all selector-based specificity. (4) If specificity is equal, the declaration that appears last in source order wins. (5) Finally, direct targeting beats inherited values regardless of all other factors.',
  followUp: 'Where do CSS animations and transitions fit in the cascade origin model?',
  keyTakeaway: 'The cascade flows: origin/importance, then layer order, then specificity, then source order — each step is a tiebreaker for the previous.',
},
{
  id: 13,
  title: 'How can a selector with no IDs ever override a selector with an ID, without using `!important`?',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'specificity',
  answer: 'Using CSS cascade layers, a selector with no IDs can override one with an ID. If the ID-based rule is placed inside a layer and the class-based rule is either unlayered or in a later layer, the class-based rule wins because layer order takes precedence over specificity. Another approach is using the `:where()` pseudo-class to wrap the ID selector, which zeroes out its specificity entirely, meaning even a single element selector would override it. A third method is placing the ID-based rule in an earlier `@import` that is assigned to a lower-priority layer. These techniques are all valid because the cascade has multiple stages that are evaluated before specificity.',
  codeExample: '/* Method 1: @layer */\n@layer base, overrides;\n@layer base {\n  #header { color: red; }\n}\n@layer overrides {\n  .header { color: blue; } /* Wins — later layer */\n}\n\n/* Method 2: :where() */\n:where(#header) { color: red; } /* Specificity: (0,0,0) */\n.header { color: blue; }         /* Specificity: (0,1,0) — wins */\n',
  followUp: 'Can you think of a scenario where these techniques could cause maintenance issues?',
  keyTakeaway: 'Cascade layers and `:where()` both allow lower-specificity selectors to override higher ones without `!important`.',
},
{
  id: 14,
  title: 'What is the difference between `display: block`, `display: inline`, and `display: inline-block`?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'display-flow',
  answer: 'Block elements take up the full available width, start on a new line, and respect all box model properties including width, height, and vertical margins. Inline elements flow within text, only take up as much width as their content, and ignore `width`, `height`, and vertical `margin` — only horizontal margins, padding, and borders affect layout (vertical padding/borders render but do not push other elements). Inline-block combines both behaviors: elements sit inline with text flow but fully respect width, height, and all margin and padding properties. This makes `inline-block` useful for creating horizontally arranged boxes that need specific dimensions.',
  codeExample: '/* Block: full width, new line */\ndiv { display: block; width: 200px; height: 100px; }\n\n/* Inline: flows with text, ignores width/height */\nspan { display: inline; width: 200px; /* IGNORED */ }\n\n/* Inline-block: inline flow + respects dimensions */\n.badge {\n  display: inline-block;\n  width: 80px;\n  height: 30px;\n  vertical-align: middle;\n}',
  followUp: 'Why does setting `width` on a `<span>` have no effect by default?',
  keyTakeaway: 'Block takes full width on a new line; inline flows with text ignoring size; inline-block is inline flow with block sizing.',
},
{
  id: 15,
  title: 'What is the normal document flow in CSS, and which elements participate in it?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'display-flow',
  answer: 'Normal document flow (also called normal flow) is the default layout algorithm browsers use when no special positioning or display modes are applied. Block-level elements stack vertically from top to bottom, each starting on a new line and stretching to fill the available width. Inline elements flow horizontally within block containers, wrapping to the next line when they run out of space. Elements are removed from normal flow by `float`, `position: absolute`, `position: fixed`, or `position: sticky` (partially). Flex and grid containers create new formatting contexts, but their children are laid out by flex/grid algorithms rather than normal block/inline flow rules.',
  followUp: 'What is a block formatting context (BFC) and how does it relate to normal flow?',
  keyTakeaway: 'Normal flow stacks blocks vertically and runs inline elements horizontally — it is the baseline layout every other mode overrides.',
},
{
  id: 16,
  title: 'What is a Block Formatting Context (BFC) and what are the practical effects of establishing one?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'display-flow',
  answer: 'A Block Formatting Context is an independent layout region where block boxes are laid out. Inside a BFC, floats are contained (the container expands to wrap floated children), margins do not collapse with margins outside the BFC, and the BFC region does not overlap with adjacent floats. A BFC is established by several conditions: the root element, floats, absolutely/fixed positioned elements, `display: inline-block`, `display: flow-root`, `overflow` values other than `visible`, flex/grid items, and table cells. The most common practical use of a BFC is clearing floats without a clearfix hack — using `display: flow-root` on the parent is the modern, semantic approach.',
  codeExample: '/* Float containment without BFC — parent collapses */\n.broken-parent {\n  /* height: 0 because float escapes */\n}\n.broken-parent > .child { float: left; }\n\n/* Fix: establish BFC */\n.fixed-parent {\n  display: flow-root; /* Creates BFC, contains floats */\n}\n\n/* BFC also prevents margin collapsing */\n.bfc-wrapper {\n  display: flow-root;\n  /* Child margins no longer collapse with outside margins */\n}',
  followUp: 'Why was `display: flow-root` introduced when `overflow: hidden` already creates a BFC?',
  keyTakeaway: 'A BFC is a self-contained layout region that traps floats, prevents margin collapsing, and avoids float overlap.',
},
{
  id: 17,
  title: 'Explain how `display: contents` works. What are its use cases and accessibility pitfalls?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'display-flow',
  answer: '`display: contents` makes an element\'s box disappear from the layout tree while keeping its children as if they were direct children of the grandparent. The element itself generates no box — no background, border, padding, or margin — but its children participate in the parent\'s layout context normally. This is useful for wrapper elements that exist for semantic or component-architecture reasons but should not interfere with grid or flex layout. However, it has serious accessibility concerns: in some browsers, applying it to elements with semantic roles (like `<button>`, `<table>`, or elements with ARIA roles) strips those roles from the accessibility tree, making the content invisible to screen readers.',
  codeExample: '.grid-parent {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n}\n\n/* Without contents: .wrapper creates a single grid item */\n/* With contents: .wrapper\'s children become grid items directly */\n.wrapper {\n  display: contents;\n}\n\n/* <div class="grid-parent">\n     <div class="wrapper">\n       <div>A</div>  ← becomes grid item\n       <div>B</div>  ← becomes grid item\n     </div>\n     <div>C</div>\n   </div> */',
  followUp: 'What happens to event listeners on an element with `display: contents`?',
  keyTakeaway: '`display: contents` removes an element\'s box but keeps its children in flow — powerful for layout but dangerous for accessibility.',
},
{
  id: 18,
  title: 'What is the stacking context and how does `display` interact with `z-index` to create one?',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'display-flow',
  answer: 'A stacking context is an independent layering scope for `z-index` ordering. Within a stacking context, children are layered according to their `z-index` values, but they can never escape the parent\'s layer — a child with `z-index: 9999` in a stacking context with `z-index: 1` will still appear below a sibling stacking context with `z-index: 2`. A new stacking context is created by: positioned elements with a `z-index` other than `auto`, flex/grid children with `z-index` other than `auto` (even without explicit positioning), elements with `opacity` less than 1, `transform`, `filter`, `will-change`, `contain: paint`, and several other properties. The key insight is that flex and grid items create stacking contexts with `z-index` alone, whereas block elements require both positioning and `z-index`.',
  codeExample: '.parent {\n  position: relative;\n  z-index: 1; /* Creates stacking context */\n}\n\n.child {\n  position: absolute;\n  z-index: 9999; /* High, but trapped in parent\'s context */\n}\n\n.sibling {\n  position: relative;\n  z-index: 2; /* This appears ABOVE .child */\n}\n\n/* Flex exception: no position needed */\n.flex-parent { display: flex; }\n.flex-child { z-index: 5; /* Creates stacking context without position */ }',
  followUp: 'Why might a modal with `z-index: 10000` still appear behind another element?',
  keyTakeaway: 'A stacking context traps all child z-indices — no child can escape its parent\'s stacking level.',
},
{
  id: 19,
  title: 'What is the difference between `position: relative` and `position: absolute`?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'positioning',
  answer: 'A `position: relative` element remains in the normal document flow and occupies its original space, but can be visually offset using `top`, `right`, `bottom`, and `left` without affecting surrounding elements. A `position: absolute` element is removed from the normal flow entirely — it no longer occupies space, and sibling elements behave as if it does not exist. Absolute elements are positioned relative to their nearest positioned ancestor (an ancestor with `position` set to anything other than `static`). If no positioned ancestor exists, the absolute element is positioned relative to the initial containing block (typically the viewport). A common pattern is to set `position: relative` on a parent so absolute children are positioned within it.',
  codeExample: '.parent {\n  position: relative; /* Establishes containing block */\n}\n\n.child {\n  position: absolute;\n  top: 10px;\n  right: 10px;\n  /* Positioned 10px from parent\'s top-right corner */\n}\n\n.shifted {\n  position: relative;\n  top: -5px; /* Visually moves up 5px, but original space preserved */\n}',
  followUp: 'What happens to an absolutely positioned element if no ancestor has `position` set?',
  keyTakeaway: 'Relative offsets from its own position and stays in flow; absolute is removed from flow and offsets from its positioned ancestor.',
},
{
  id: 20,
  title: 'What does `position: sticky` do, and what are the requirements for it to work?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'positioning',
  answer: 'A sticky element behaves like `position: relative` until the user scrolls past a specified threshold (set by `top`, `right`, `bottom`, or `left`), at which point it behaves like `position: fixed` and sticks in place within its containing block. The element stops sticking when it reaches the boundary of its containing block (its parent). For sticky positioning to work, you must specify at least one offset property (e.g., `top: 0`), and none of the ancestors can have `overflow: hidden`, `overflow: scroll`, or `overflow: auto` set in a way that creates a scrollable container that clips the sticky behavior. The sticky element\'s containing block must also have enough height for scrolling to occur.',
  codeExample: '.sticky-header {\n  position: sticky;\n  top: 0; /* Sticks when reaching viewport top */\n  z-index: 10;\n  background: white;\n}\n\n/* Common gotcha: overflow on parent kills sticky */\n.parent {\n  overflow: hidden; /* This breaks sticky! */\n}',
  followUp: 'Why does `position: sticky` not work when a parent has `overflow: hidden`?',
  keyTakeaway: 'Sticky toggles between relative and fixed at a scroll threshold — it needs an offset property and no `overflow` traps on ancestors.',
},
{
  id: 21,
  title: 'How does `position: fixed` differ from `position: absolute`, and when can `fixed` not be relative to the viewport?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'positioning',
  answer: 'Both `fixed` and `absolute` remove the element from normal flow, but they differ in their containing block. An absolute element is positioned relative to its nearest positioned ancestor, while a fixed element is normally positioned relative to the viewport and does not move when the page scrolls. However, if any ancestor has a `transform`, `perspective`, `filter`, `will-change`, or `contain: paint` property set, that ancestor becomes the containing block for the fixed element instead of the viewport, effectively breaking the fixed behavior. This is a common source of bugs — a fixed modal or sticky header inside a transformed parent will scroll with that parent instead of staying viewport-fixed.',
  codeExample: '/* Normal fixed: viewport-relative */\n.modal {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n/* BROKEN: ancestor with transform captures fixed child */\n.animated-wrapper {\n  transform: scale(1); /* Creates new containing block! */\n}\n.animated-wrapper .modal {\n  position: fixed;\n  /* Now positioned relative to .animated-wrapper, NOT viewport */\n}',
  followUp: 'Name all CSS properties on an ancestor that can break `position: fixed` viewport anchoring.',
  keyTakeaway: '`fixed` targets the viewport unless an ancestor has `transform`, `filter`, or `will-change` — which silently re-parents it.',
},
{
  id: 22,
  title: 'Explain the `inset` shorthand and how `position: absolute; inset: 0` creates a full-coverage overlay.',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'positioning',
  answer: 'The `inset` property is a shorthand for setting `top`, `right`, `bottom`, and `left` simultaneously, following the same clockwise order as `margin` and `padding` shorthands. `inset: 0` sets all four offsets to zero, which means the absolutely positioned element stretches to cover its entire containing block. This works because when both `top` and `bottom` (or `left` and `right`) are set on an absolute element without an explicit width or height, the element\'s dimensions are determined by the offset constraints — it stretches to satisfy both. This pattern is the modern, clean way to create overlays, modals, or full-bleed backgrounds without needing `width: 100%; height: 100%`.',
  codeExample: '.parent {\n  position: relative;\n}\n\n/* Full-coverage overlay */\n.overlay {\n  position: absolute;\n  inset: 0; /* Equivalent to: top: 0; right: 0; bottom: 0; left: 0; */\n  background: rgba(0, 0, 0, 0.5);\n}\n\n/* Inset with different values */\n.padded-overlay {\n  position: absolute;\n  inset: 10px 20px; /* top/bottom: 10px, left/right: 20px */\n}',
  followUp: 'What happens if you set both `inset: 0` and an explicit `width` and `height` on the same element?',
  keyTakeaway: '`inset: 0` on an absolute element stretches it to fill its containing block by anchoring all four edges.',
},
{
  id: 23,
  title: 'What is a containing block, and how does the positioned ancestor chain affect where an absolutely positioned element lands?',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'positioning',
  answer: 'The containing block is the reference rectangle against which an element\'s percentage sizes and position offsets are resolved. For statically and relatively positioned elements, the containing block is the content box of the nearest block-level ancestor. For absolutely positioned elements, it is the padding box of the nearest ancestor with `position` other than `static` (or an ancestor with `transform`, `perspective`, `filter`, `will-change`, or `contain`). For fixed elements, the containing block is normally the viewport. The distinction between content box and padding box matters: absolute children are positioned within the parent\'s padding, not just its content area. If no positioned ancestor exists, the absolute element\'s containing block is the initial containing block, which corresponds to the root element\'s box and has the dimensions of the viewport.',
  codeExample: '.grandparent {\n  position: relative;\n  padding: 40px;\n}\n\n.parent {\n  /* position: static (default) — not a containing block */\n  padding: 20px;\n}\n\n.child {\n  position: absolute;\n  top: 0;\n  left: 0;\n  /* Positioned at .grandparent\'s padding edge, NOT .parent\'s */\n  /* Skips .parent because it is not positioned */\n}',
  followUp: 'Why is the containing block for absolute elements based on the padding box rather than the content box?',
  keyTakeaway: 'The containing block for absolute elements is the padding box of the nearest positioned ancestor — static ancestors are skipped entirely.',
},
{
  id: 24,
  title: 'What is the difference between `px`, `em`, `rem`, and `%` units in CSS?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'units',
  answer: '`px` is an absolute unit representing one CSS pixel (which may not equal a physical pixel on high-DPI screens). `em` is relative to the font size of the current element — if the element\'s font size is 16px, then `1em` equals 16px, and it compounds when nested. `rem` (root em) is always relative to the root element\'s (`<html>`) font size, avoiding the compounding problem of `em`. `%` is relative to the parent element, but what it references depends on the property: `width` percentages resolve against the parent\'s width, `padding` percentages resolve against the parent\'s width (even vertical padding), and `font-size` percentages resolve against the parent\'s font size. Choosing the right unit affects responsive design, accessibility, and maintainability.',
  codeExample: 'html { font-size: 16px; }\n\n.parent {\n  font-size: 20px;\n}\n\n.child {\n  font-size: 1.5em;  /* 30px (1.5 × parent\'s 20px) */\n  padding: 1rem;     /* 16px (1 × root\'s 16px) */\n  width: 50%;        /* 50% of parent\'s width */\n  margin: 2em;       /* 60px (2 × own font-size 30px) */\n}',
  followUp: 'Why is `rem` generally preferred over `em` for spacing and layout?',
  keyTakeaway: '`px` is absolute; `em` compounds relative to the element; `rem` is stable relative to the root; `%` depends on the property and parent.',
},
{
  id: 25,
  title: 'What are viewport units (`vh`, `vw`, `dvh`, `svh`, `lvh`) and when would you choose one over another?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'units',
  answer: '`vw` and `vh` are 1% of the viewport\'s width and height respectively. On mobile browsers, `100vh` can be problematic because it uses the largest possible viewport height (with the URL bar hidden), causing content to overflow when the URL bar is visible. To address this, CSS introduced three variants: `svh` (small viewport height — URL bar visible, smallest possible viewport), `lvh` (large viewport height — URL bar hidden, largest possible viewport), and `dvh` (dynamic viewport height — adjusts in real time as the URL bar appears or disappears). Use `dvh` for full-screen layouts that must respond to mobile browser chrome, `svh` when you want content to always fit without scrolling, and `lvh` for backgrounds where slight overflow is acceptable.',
  codeExample: '/* Classic approach — breaks on mobile */\n.hero-broken {\n  height: 100vh; /* May extend behind mobile URL bar */\n}\n\n/* Modern approach — dynamic viewport */\n.hero-fixed {\n  height: 100dvh; /* Adjusts with browser chrome */\n}\n\n/* Safe minimum — always fits */\n.safe-section {\n  min-height: 100svh;\n}',
  followUp: 'What is `100vw` and why can it cause a horizontal scrollbar?',
  keyTakeaway: 'Use `dvh` for mobile-safe full-height layouts — classic `vh` includes space behind the mobile browser chrome.',
},
{
  id: 26,
  title: 'Explain how `clamp()`, `min()`, and `max()` work. What are their advantages over media query breakpoints for fluid typography?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'units',
  answer: '`min()` returns the smallest value from its arguments, `max()` returns the largest, and `clamp(min, preferred, max)` constrains a preferred value between a minimum and maximum bound — it is equivalent to `max(min, min(preferred, max))`. These functions accept mixed units, so `clamp(1rem, 2.5vw, 2rem)` creates fluid typography that scales with viewport width but never goes below 1rem or above 2rem. Unlike media query breakpoints, which create abrupt jumps at specific widths, `clamp()` provides smooth, continuous scaling. They also reduce code: a single `clamp()` declaration replaces a base value plus two or three media queries. These functions work for any CSS property that accepts a length, not just font size.',
  codeExample: '/* Fluid typography: scales between 1rem and 2.5rem */\nh1 {\n  font-size: clamp(1rem, 1rem + 2vw, 2.5rem);\n}\n\n/* Fluid container: at least 300px, at most 1200px */\n.container {\n  width: min(90%, 1200px);\n}\n\n/* Fluid gap: at least 16px */\n.grid {\n  gap: max(1rem, 2vw);\n}',
  followUp: 'How does `clamp()` interact with the user\'s browser font size setting for accessibility?',
  keyTakeaway: '`clamp(min, preferred, max)` enables smooth fluid scaling between bounds — replacing multiple media queries with one declaration.',
},
{
  id: 27,
  title: 'What happens when you use `em` units for `padding` inside an element that also uses `em` for `font-size`? Explain the resolution chain.',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'units',
  answer: 'When an element uses `em` for both `font-size` and `padding`, the `em` values resolve differently for each property. For `font-size`, `em` is relative to the parent element\'s computed font size. For all other properties (padding, margin, width, etc.), `em` is relative to the element\'s own computed font size. So the resolution chain is: first the browser computes the element\'s font size by multiplying the `em` value by the parent\'s font size, then it uses that computed font size to resolve the padding `em` values. This means `font-size: 2em; padding: 1em` on an element whose parent has `font-size: 16px` results in `font-size: 32px` and `padding: 32px`. This compounding behavior is why deeply nested `em` font sizes can lead to unexpectedly large or small text.',
  codeExample: '.parent { font-size: 16px; }\n\n.child {\n  font-size: 2em;    /* Step 1: 2 × 16px = 32px */\n  padding: 1em;      /* Step 2: 1 × 32px (own font-size) = 32px */\n  margin: 0.5em;     /* Step 2: 0.5 × 32px = 16px */\n}\n\n/* Nested compounding danger */\n.parent { font-size: 1.2em; }   /* 19.2px if root is 16px */\n.child  { font-size: 1.2em; }   /* 23.04px */\n.grand  { font-size: 1.2em; }   /* 27.648px — keeps growing! */\n',
  followUp: 'How would you use `em` units intentionally to create components that scale proportionally with their font size?',
  keyTakeaway: 'For `font-size`, `em` references the parent; for everything else, `em` references the element\'s own computed font size.',
},
{
  id: 28,
  title: 'Which CSS properties are inherited by default, and how do `inherit`, `initial`, `unset`, and `revert` differ?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'inheritance',
  answer: 'Text-related properties are typically inherited: `color`, `font-family`, `font-size`, `font-weight`, `line-height`, `letter-spacing`, `text-align`, `visibility`, `cursor`, and `list-style`, among others. Layout and box properties like `margin`, `padding`, `border`, `display`, `width`, `height`, and `background` are not inherited. The four keywords control how values are resolved: `inherit` forces inheritance from the parent even for non-inherited properties. `initial` resets to the CSS specification\'s default value (not the browser default). `unset` acts as `inherit` for inherited properties and `initial` for non-inherited ones. `revert` rolls back to the browser\'s default stylesheet value, which is often more useful than `initial` because it preserves expected defaults like `display: block` for `<div>` elements.',
  codeExample: '.parent { color: red; border: 1px solid blue; }\n\n.child {\n  /* color: red — inherited automatically */\n  /* border: none — NOT inherited */\n}\n\n/* Force border inheritance */\n.child-inherit { border: inherit; } /* 1px solid blue */\n\n/* initial vs revert on a <div> */\ndiv {\n  display: initial; /* "inline" — spec default, probably not what you want */\n  display: revert;  /* "block" — browser default for <div> */\n  display: unset;   /* "inline" — display is not inherited, so acts as initial */\n}',
  followUp: 'Why would `display: initial` on a `<div>` give you `inline` instead of `block`?',
  keyTakeaway: '`inherit` forces parent value; `initial` uses spec default; `revert` uses browser default; `unset` is `inherit` for inherited properties, `initial` otherwise.',
},
{
  id: 29,
  title: 'Explain how `all: unset` works. What are the dangers of using it, and how does it interact with inherited vs. non-inherited properties?',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'inheritance',
  answer: 'The `all` shorthand targets every CSS property on an element (except `direction` and `unicode-bidi`). When set to `unset`, it resets every inherited property to its parent\'s value and every non-inherited property to its initial (specification default) value. This effectively strips all styling from an element. The danger is that it resets properties you might not expect: `display` becomes `inline` (the spec initial value, not the browser default), `box-sizing` reverts to `content-box`, `cursor` inherits from parent rather than being `default`, and any property set by the user-agent stylesheet is lost. This means a `<div>` with `all: unset` will render as an inline element, and a `<button>` loses all its native button styling. Using `all: revert` instead preserves browser defaults while still stripping author styles, which is usually the safer choice.',
  codeExample: '/* Strips ALL styles — often too aggressive */\n.reset {\n  all: unset;\n  /* div is now inline (initial value of display) */\n  /* Must re-declare: display: block; box-sizing: border-box; */\n}\n\n/* Safer: revert to browser defaults */\n.safe-reset {\n  all: revert;\n  /* div stays block, button keeps native styling */\n}\n\n/* Targeted reset for component isolation */\n.component {\n  all: unset;\n  display: flex; /* Re-establish needed properties */\n  box-sizing: border-box;\n}',
  followUp: 'When would you use `all: revert-layer` instead of `all: revert`?',
  keyTakeaway: '`all: unset` nukes every property to spec defaults — a `<div>` goes inline and a `<button>` loses its identity. Prefer `all: revert` for safety.',
},
{
  id: 30,
  title: 'How does CSS custom property (`--var`) inheritance work differently from normal property inheritance? Can you break inheritance of a custom property?',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'inheritance',
  answer: 'CSS custom properties are inherited by default, similar to `color` or `font-size`, meaning any descendant element can access a custom property set on an ancestor. However, they differ from normal properties in key ways: they have no initial value by default (their initial value is the "guaranteed-invalid value"), they are not subject to normal cascade resolution within the property they are substituted into (the `var()` is resolved at computed-value time, not cascade time), and they can be registered with `@property` to define an initial value, syntax, and crucially, `inherits: false` to disable inheritance. Breaking inheritance is done either by explicitly re-declaring the custom property on a descendant or by registering it with `@property { inherits: false }`. This registration also enables features like transition animation of custom properties, since the browser then understands the value type.',
  codeExample: '/* Normal inheritance — all descendants see this */\n:root {\n  --theme-color: blue;\n}\n\n/* Break inheritance by redeclaring */\n.sidebar {\n  --theme-color: green; /* Children see green, not blue */\n}\n\n/* Break inheritance via @property */\n@property --local-spacing {\n  syntax: "<length>";\n  inherits: false;\n  initial-value: 0px;\n}\n\n.parent { --local-spacing: 20px; }\n.child  { /* --local-spacing is 0px, NOT 20px — inherits: false */ }',
  followUp: 'What happens when a `var()` references a custom property that is the guaranteed-invalid value, and how does the fallback work?',
  keyTakeaway: 'Custom properties inherit by default, but `@property` with `inherits: false` can break the chain — unlocking scoped tokens and animatability.',
},
{
  id: 31,
  title: 'What does `flex: 1` actually expand to?',
  difficulty: 'easy',
  topic: 'layout-systems',
  subtopic: 'flexbox',
  answer: '`flex: 1` is shorthand for `flex-grow: 1`, `flex-shrink: 1`, and `flex-basis: 0%`. This means the item will grow to fill available space, can shrink if needed, and starts from a base size of zero rather than its content size. This is different from `flex: auto` which sets `flex-basis` to `auto`, meaning the item starts from its intrinsic content size before growing.',
  codeExample: '/* flex: 1 expands to: */\n.item {\n  flex-grow: 1;\n  flex-shrink: 1;\n  flex-basis: 0%;\n}\n\n/* flex: auto expands to: */\n.item-auto {\n  flex-grow: 1;\n  flex-shrink: 1;\n  flex-basis: auto;\n}',
  followUp: 'What is the difference between `flex: 1` and `flex: auto` when items have different content widths?',
  keyTakeaway: '`flex: 1` distributes space equally because `flex-basis: 0%` ignores content size; `flex: auto` distributes only the leftover space.',
},
{
  id: 32,
  title: 'What is the difference between `justify-content` and `align-items` in flexbox?',
  difficulty: 'easy',
  topic: 'layout-systems',
  subtopic: 'flexbox',
  answer: '`justify-content` distributes items along the main axis (horizontal by default in `flex-direction: row`), while `align-items` aligns items along the cross axis (vertical by default). Think of `justify-content` as controlling the horizontal spread and `align-items` as controlling the vertical alignment. Common values for `justify-content` include `flex-start`, `center`, `space-between`, and `space-around`. Common values for `align-items` include `stretch`, `center`, `flex-start`, and `baseline`.',
  codeExample: '.container {\n  display: flex;\n  justify-content: space-between; /* horizontal distribution */\n  align-items: center;            /* vertical centering */\n}',
  followUp: 'How do these axes change when you set `flex-direction: column`?',
  keyTakeaway: '`justify-content` controls the main axis; `align-items` controls the cross axis.',
},
{
  id: 33,
  title: 'What does `flex-wrap: wrap` do and when would you use it?',
  difficulty: 'easy',
  topic: 'layout-systems',
  subtopic: 'flexbox',
  answer: 'By default, flex items try to fit on a single line because `flex-wrap` defaults to `nowrap`. Setting `flex-wrap: wrap` allows items to flow onto multiple lines when they exceed the container width. Each new line becomes its own flex line with independent cross-axis sizing. This is commonly used for responsive card grids or tag lists where items should naturally reflow as the viewport narrows.',
  codeExample: '.card-grid {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 1rem;\n}\n\n.card {\n  flex: 1 1 300px; /* grow, shrink, min 300px before wrapping */\n}',
  followUp: 'How does `align-content` differ from `align-items` when `flex-wrap: wrap` creates multiple lines?',
  keyTakeaway: '`flex-wrap: wrap` lets items flow to new lines instead of overflowing or shrinking to zero.',
},
{
  id: 34,
  title: 'How does `flex-shrink` interact with `min-width` and intrinsic content size?',
  difficulty: 'medium',
  topic: 'layout-systems',
  subtopic: 'flexbox',
  answer: '`flex-shrink` controls how much an item reduces in size when the container is too small, but it cannot shrink an item below its `min-width` or its `min-content` size (whichever is larger). By default, `min-width` is `auto` for flex items, which resolves to the `min-content` size. This means a long word or an image can prevent shrinking entirely. To allow full shrinking, you often need to explicitly set `min-width: 0` on the flex item. The shrink factor is also proportional to the item\'s `flex-basis`, so larger items shrink more than smaller ones.',
  codeExample: '/* Text overflows because min-width: auto prevents shrinking */\n.item {\n  flex: 1 1 0%;\n  /* fix: add min-width: 0 to allow shrinking past content size */\n  min-width: 0;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}',
  followUp: 'Why does the flexbox spec define `min-width: auto` instead of `min-width: 0` as the default?',
  keyTakeaway: 'Flex items won\'t shrink below `min-content` unless you explicitly set `min-width: 0`.',
},
{
  id: 35,
  title: 'Explain the difference between `align-items` and `align-self` in flexbox.',
  difficulty: 'medium',
  topic: 'layout-systems',
  subtopic: 'flexbox',
  answer: '`align-items` is set on the flex container and controls cross-axis alignment for all items at once. `align-self` is set on an individual flex item and overrides the container\'s `align-items` value for that specific item. Both accept the same values: `stretch`, `flex-start`, `flex-end`, `center`, and `baseline`. A common pattern is setting `align-items: center` on the container and then using `align-self: stretch` on one item that needs to fill the full cross-axis height.',
  codeExample: '.container {\n  display: flex;\n  align-items: center; /* all items centered */\n}\n\n.sidebar {\n  align-self: stretch; /* this one fills full height */\n}',
  followUp: 'Is there an equivalent `justify-self` property in flexbox, and if not, why?',
  keyTakeaway: '`align-self` overrides `align-items` for a single item — there is no `justify-self` in flexbox.',
},
{
  id: 36,
  title: 'What happens when you use `gap` with flexbox and how does it differ from using margins?',
  difficulty: 'medium',
  topic: 'layout-systems',
  subtopic: 'flexbox',
  answer: 'The `gap` property on a flex container creates consistent spacing between items without affecting the outer edges. Unlike margins, `gap` does not cause doubled spacing where items meet, and it does not add space before the first or after the last item. With margins, you typically need hacks like negative margins on the container or `:first-child`/`:last-child` overrides. `gap` also works correctly with `flex-wrap: wrap`, maintaining consistent row and column gaps. You can set different row and column gaps using `row-gap` and `column-gap` separately.',
  codeExample: '.container {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 1rem;           /* equal row and column gap */\n  /* or: row-gap: 1rem; column-gap: 2rem; */\n}',
  followUp: 'Does `gap` interact with `justify-content: space-between`, and if so, how?',
  keyTakeaway: '`gap` creates gutters between items without affecting outer edges — no more margin hacks.',
},
{
  id: 37,
  title: 'How does `flex-basis` interact with `width` and what takes priority?',
  difficulty: 'medium',
  topic: 'layout-systems',
  subtopic: 'flexbox',
  answer: 'When both `flex-basis` and `width` (or `height` for column layouts) are set, `flex-basis` takes priority as long as it is not `auto`. When `flex-basis` is `auto`, the browser falls back to the `width` property, and if `width` is also `auto`, it uses the item\'s intrinsic content size. The `flex-basis` value defines the initial size of the item before `flex-grow` and `flex-shrink` are applied. One important nuance: `flex-basis` is clamped by `min-width` and `max-width`, just like `width` is.',
  codeExample: '.item {\n  width: 200px;\n  flex-basis: 300px; /* 300px wins, width is ignored */\n}\n\n.item-auto {\n  width: 200px;\n  flex-basis: auto; /* auto means "use width", so 200px */\n}',
  followUp: 'What happens to `flex-basis` when the writing mode is vertical?',
  keyTakeaway: '`flex-basis` beats `width` unless it\'s `auto` — then the browser falls back to `width`.',
},
{
  id: 38,
  title: 'Walk through the flexbox sizing algorithm: how does the browser determine final item sizes?',
  difficulty: 'hard',
  topic: 'layout-systems',
  subtopic: 'flexbox',
  answer: 'The browser first resolves each item\'s hypothetical main size from `flex-basis` (or `width`/content if `auto`). It sums these sizes and compares to the container. If there\'s leftover space, it distributes it proportionally according to each item\'s `flex-grow` factor. If items overflow, it reduces them proportionally by `flex-shrink` multiplied by their `flex-basis` (larger items shrink more). At each step, items are clamped to their `min-width`/`max-width` constraints — if a clamped item cannot grow or shrink further, it\'s "frozen" and the remaining space is redistributed among unfrozen items. This iterative clamping process can run multiple passes until all constraints are satisfied.',
  followUp: 'Why does the shrink algorithm weight by `flex-basis` while the grow algorithm does not?',
  keyTakeaway: 'Flexbox sizing is iterative: distribute space, freeze clamped items, redistribute until stable.',
},
{
  id: 39,
  title: 'How do you handle flexbox layouts where items have unpredictable content lengths without breaking the layout?',
  difficulty: 'hard',
  topic: 'layout-systems',
  subtopic: 'flexbox',
  answer: 'The key is combating the `min-width: auto` default. Set `min-width: 0` on flex items to allow them to shrink below their content size, then use `overflow: hidden` with `text-overflow: ellipsis` for text truncation. For nested flex containers, every flex item in the chain needs `min-width: 0` because the constraint propagates upward. When combining `flex: 1` items with fixed-width items, use `flex: none` (shorthand for `0 0 auto`) on elements that should never shrink. For truly equal columns regardless of content, use `flex: 1 1 0%` so the basis is zero and space is divided evenly.',
  codeExample: '.layout {\n  display: flex;\n  min-width: 0; /* if this is also a flex item */\n}\n\n.truncated-item {\n  flex: 1 1 0%;\n  min-width: 0;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n\n.fixed-item {\n  flex: none; /* never grow or shrink */\n}',
  followUp: 'How does this problem manifest differently in `flex-direction: column` layouts?',
  keyTakeaway: 'Set `min-width: 0` on every flex item in the chain to prevent content from blowing out layouts.',
},
{
  id: 40,
  title: 'What is the `fr` unit in CSS Grid and how does it work?',
  difficulty: 'easy',
  topic: 'layout-systems',
  subtopic: 'grid',
  answer: 'The `fr` unit represents a fraction of the available space in a grid container after fixed-size tracks and gaps are accounted for. If you define `grid-template-columns: 1fr 2fr`, the first column gets one-third and the second gets two-thirds of the remaining space. Unlike percentages, `fr` units automatically account for `gap` values, so you don\'t need to manually subtract gap sizes. The `fr` unit is resolved after all non-flexible tracks (fixed lengths, `auto`, `min-content`, `max-content`) have been sized.',
  codeExample: '.grid {\n  display: grid;\n  grid-template-columns: 200px 1fr 2fr;\n  gap: 1rem;\n  /* 200px fixed, then remaining space split 1:2 */\n}',
  followUp: 'What happens when you combine `fr` with `minmax()` — for example, `minmax(200px, 1fr)`?',
  keyTakeaway: 'The `fr` unit divides leftover space proportionally after fixed tracks and gaps are resolved.',
},
{
  id: 41,
  title: 'How do you place an item in a specific grid cell?',
  difficulty: 'easy',
  topic: 'layout-systems',
  subtopic: 'grid',
  answer: 'You can place a grid item using `grid-column` and `grid-row` properties, which accept line numbers. Grid lines are numbered starting from 1. For example, `grid-column: 2 / 4` places an item from line 2 to line 4, spanning two columns. You can also use the `span` keyword: `grid-column: 2 / span 2` achieves the same result. Named grid areas via `grid-template-areas` offer another approach where you assign an area name to each item with `grid-area`.',
  codeExample: '.item {\n  grid-column: 2 / 4;  /* start at line 2, end at line 4 */\n  grid-row: 1 / 2;     /* first row only */\n}\n\n/* or using span: */\n.item-span {\n  grid-column: 2 / span 2;\n  grid-row: 1;\n}',
  followUp: 'How do negative line numbers like `grid-column: 1 / -1` work?',
  keyTakeaway: 'Use `grid-column` and `grid-row` with line numbers or `span` to place items precisely.',
},
{
  id: 42,
  title: 'What does `grid-template-areas` do and when is it useful?',
  difficulty: 'easy',
  topic: 'layout-systems',
  subtopic: 'grid',
  answer: '`grid-template-areas` lets you define a grid layout using named region strings that visually represent the grid structure. Each row is a quoted string, and each cell name corresponds to a `grid-area` value assigned to child elements. A dot (`.`) denotes an empty cell. This approach is especially useful for page-level layouts like header/sidebar/main/footer because the template reads like an ASCII art diagram of your layout. Named areas also generate implicit line names like `header-start` and `header-end`.',
  codeExample: '.layout {\n  display: grid;\n  grid-template-areas:\n    "header header"\n    "sidebar main"\n    "footer footer";\n  grid-template-columns: 250px 1fr;\n}\n\n.header  { grid-area: header; }\n.sidebar { grid-area: sidebar; }\n.main    { grid-area: main; }\n.footer  { grid-area: footer; }',
  followUp: 'Can you change `grid-template-areas` in a media query to rearrange the layout for mobile?',
  keyTakeaway: '`grid-template-areas` gives you a visual ASCII map of your layout — readable and easy to rearrange.',
},
{
  id: 43,
  title: 'Explain the difference between `auto-fill` and `auto-fit` in `repeat()`.',
  difficulty: 'medium',
  topic: 'layout-systems',
  subtopic: 'grid',
  answer: 'Both `auto-fill` and `auto-fit` create as many tracks as will fit in the container, but they differ in how they handle leftover space when there aren\'t enough items to fill all tracks. `auto-fill` keeps empty tracks — they occupy space even with no content. `auto-fit` collapses empty tracks to zero width, allowing existing items to stretch into the freed space when combined with `fr` or `minmax()`. With `minmax(200px, 1fr)`, `auto-fit` causes items to expand beyond 200px when the row is not full, while `auto-fill` keeps them at or near 200px with empty space at the end.',
  codeExample: '/* Items stay at ~200px, empty tracks take space */\n.grid-fill {\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n}\n\n/* Items stretch when row is not full */\n.grid-fit {\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n}',
  followUp: 'When would you intentionally choose `auto-fill` over `auto-fit`?',
  keyTakeaway: '`auto-fill` preserves empty tracks; `auto-fit` collapses them so items can stretch.',
},
{
  id: 44,
  title: 'How do implicit grid tracks work and how do you control their sizing?',
  difficulty: 'medium',
  topic: 'layout-systems',
  subtopic: 'grid',
  answer: 'When items are placed outside the explicitly defined grid (via `grid-template-columns`/`grid-template-rows`), the browser creates implicit tracks to accommodate them. By default, implicit tracks are sized `auto` (fitting their content). You can control implicit track sizing with `grid-auto-rows` and `grid-auto-columns`. For example, `grid-auto-rows: 200px` ensures any dynamically created rows are 200px tall. The `grid-auto-flow` property controls whether implicit items flow in rows (default) or columns, and adding `dense` enables the packing algorithm to fill gaps.',
  codeExample: '.grid {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-auto-rows: minmax(100px, auto); /* implicit rows at least 100px */\n  grid-auto-flow: dense; /* fill gaps with smaller items */\n}',
  followUp: 'What happens when an item is explicitly placed at row 10 but only 3 rows are defined?',
  keyTakeaway: 'Implicit tracks appear automatically; control their size with `grid-auto-rows` and `grid-auto-columns`.',
},
{
  id: 45,
  title: 'What is `minmax()` in CSS Grid and what are common patterns for using it?',
  difficulty: 'medium',
  topic: 'layout-systems',
  subtopic: 'grid',
  answer: '`minmax(min, max)` defines a track size range — the track will be at least `min` and at most `max`. The most common pattern is `minmax(200px, 1fr)` inside `repeat(auto-fill, ...)` for responsive grids without media queries. You can also use intrinsic sizing keywords: `minmax(min-content, max-content)` makes a track that shows at least the smallest word but can expand to the full unwrapped content. One important constraint: the `fr` unit can only be used as the maximum value, not the minimum. Using `minmax(0, 1fr)` is equivalent to `1fr` but makes the zero minimum explicit.',
  codeExample: '.responsive-grid {\n  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));\n}\n\n.sidebar-layout {\n  grid-template-columns: minmax(200px, 300px) 1fr;\n  /* sidebar: 200-300px, main: rest */\n}',
  followUp: 'What happens if the minimum value is larger than the maximum in `minmax()`?',
  keyTakeaway: '`minmax()` sets a track size range — pair it with `auto-fill` for responsive grids without media queries.',
},
{
  id: 46,
  title: 'How does `grid-column: 1 / -1` work and why is it useful?',
  difficulty: 'medium',
  topic: 'layout-systems',
  subtopic: 'grid',
  answer: 'Negative line numbers count backward from the end of the explicit grid. Line `-1` is the last explicit grid line, `-2` is the second-to-last, and so on. So `grid-column: 1 / -1` spans an item from the first line to the last line, effectively making it full-width regardless of how many columns exist. This is useful for full-bleed elements like headers or banners in a grid layout. However, negative line numbers only reference the explicit grid (defined by `grid-template-columns`), not implicit tracks created by auto-placement.',
  codeExample: '.grid {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n}\n\n.full-width-banner {\n  grid-column: 1 / -1; /* spans all 4 columns */\n}',
  followUp: 'Do negative line numbers work with implicit grid tracks?',
  keyTakeaway: 'Negative line numbers count from the end of the explicit grid — `1 / -1` means full-width.',
},
{
  id: 47,
  title: 'How does the CSS Grid auto-placement algorithm work and what does `dense` packing do?',
  difficulty: 'hard',
  topic: 'layout-systems',
  subtopic: 'grid',
  answer: 'The auto-placement algorithm processes items in DOM order, placing explicitly positioned items first, then filling remaining items into the next available slot. By default (`grid-auto-flow: row`), it scans left-to-right, top-to-bottom, and never backtracks — so if a two-column item skips a one-column gap, that gap stays empty. Adding `dense` changes this: the algorithm restarts from the beginning of the grid for each unplaced item, filling earlier gaps when a smaller item fits. This produces a more compact layout but breaks visual DOM order, which can harm accessibility for keyboard navigation. The `dense` keyword does not reorder the DOM, only the visual placement.',
  codeExample: '.masonry-like {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  grid-auto-flow: dense; /* backtrack to fill gaps */\n}\n\n.wide-item {\n  grid-column: span 2; /* might leave gaps without dense */\n}',
  followUp: 'What accessibility concerns does `grid-auto-flow: dense` introduce and how do you mitigate them?',
  keyTakeaway: '`dense` packing fills visual gaps by backtracking, but breaks DOM order — use with accessibility in mind.',
},
{
  id: 48,
  title: 'How do subgrid works and what problem does it solve?',
  difficulty: 'hard',
  topic: 'layout-systems',
  subtopic: 'grid',
  answer: '`subgrid` allows a nested grid item to inherit its parent\'s track definitions rather than creating independent tracks. Setting `grid-template-columns: subgrid` on a child grid makes its columns align exactly with the parent grid\'s column lines. This solves the longstanding problem of aligning nested content — for example, ensuring card titles, descriptions, and buttons all align across a row of cards even when content lengths vary. Without subgrid, each card is an independent grid, so tracks don\'t coordinate. Subgrid items participate in the parent\'s sizing algorithm, meaning a taller title in one card expands that row for all siblings.',
  codeExample: '.card-grid {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n}\n\n.card {\n  display: grid;\n  grid-row: span 3;\n  grid-template-rows: subgrid; /* inherit parent row tracks */\n  /* card title, body, footer now align across cards */\n}',
  followUp: 'How does subgrid interact with `gap` — does the child inherit the parent\'s gap?',
  keyTakeaway: 'Subgrid lets nested grids inherit parent tracks so content aligns across sibling items.',
},
{
  id: 49,
  title: 'What is a media query and what are the most commonly used breakpoints?',
  difficulty: 'easy',
  topic: 'layout-systems',
  subtopic: 'responsive',
  answer: 'A media query is a CSS conditional rule that applies styles only when certain conditions are met, most commonly viewport width. The syntax `@media (min-width: 768px)` applies styles when the viewport is 768px or wider. Common breakpoints target mobile (< 640px), tablet (768px), laptop (1024px), and desktop (1280px), though exact values vary by design system. Modern best practice is mobile-first: write base styles for small screens and use `min-width` queries to add complexity for larger screens. Range syntax like `@media (640px <= width < 1024px)` is now supported in modern browsers.',
  codeExample: '/* Mobile-first approach */\n.container { padding: 1rem; }\n\n@media (min-width: 768px) {\n  .container { padding: 2rem; max-width: 720px; }\n}\n\n@media (min-width: 1024px) {\n  .container { max-width: 960px; }\n}',
  followUp: 'Why is mobile-first considered better than desktop-first for responsive design?',
  keyTakeaway: 'Media queries conditionally apply styles — mobile-first with `min-width` is the modern standard.',
},
{
  id: 50,
  title: 'What is the `viewport` meta tag and why is it essential for responsive design?',
  difficulty: 'easy',
  topic: 'layout-systems',
  subtopic: 'responsive',
  answer: 'The `<meta name="viewport" content="width=device-width, initial-scale=1">` tag tells mobile browsers to set the viewport width to the device\'s actual screen width rather than a virtual 980px-wide viewport. Without it, mobile browsers render pages at desktop width and zoom out, making text tiny and media queries ineffective. The `initial-scale=1` prevents automatic zooming. This tag is required for responsive design to work correctly on mobile devices. You should almost never set `user-scalable=no` or `maximum-scale=1` as these harm accessibility by preventing users from zooming.',
  followUp: 'What accessibility problems arise from setting `maximum-scale=1` or `user-scalable=no`?',
  keyTakeaway: 'Without the viewport meta tag, mobile browsers assume 980px width and media queries break.',
},
{
  id: 51,
  title: 'How do CSS `clamp()`, `min()`, and `max()` enable responsive design without media queries?',
  difficulty: 'medium',
  topic: 'layout-systems',
  subtopic: 'responsive',
  answer: '`clamp(min, preferred, max)` sets a value that scales fluidly between a minimum and maximum. The preferred value is typically viewport-relative (like `5vw`), so it scales with the screen. `min()` picks the smallest value and `max()` picks the largest from a list of values. For fluid typography, `font-size: clamp(1rem, 2.5vw, 2rem)` scales text smoothly between 1rem and 2rem. For layout, `width: min(90%, 1200px)` creates a container that is 90% wide on small screens and maxes out at 1200px — replacing the classic `max-width` + `width` pattern with a single declaration.',
  codeExample: '.container {\n  width: min(90%, 1200px);\n  margin-inline: auto;\n}\n\n.heading {\n  font-size: clamp(1.5rem, 4vw, 3rem);\n}\n\n.sidebar {\n  width: max(250px, 25%);\n}',
  followUp: 'How do you ensure `clamp()` font sizes still meet WCAG zoom accessibility requirements?',
  keyTakeaway: '`clamp()` creates fluid responsive values between a min and max — no breakpoints needed.',
},
{
  id: 52,
  title: 'What is the difference between responsive images using `srcset` with width descriptors versus CSS-only approaches?',
  difficulty: 'medium',
  topic: 'layout-systems',
  subtopic: 'responsive',
  answer: 'HTML `srcset` with width descriptors and `sizes` attribute lets the browser choose the optimal image file before layout, based on viewport width and device pixel ratio. This is a performance optimization — the browser downloads only the right-sized image. CSS-only approaches like `background-image` with media queries or `object-fit` on `<img>` control how an image displays but don\'t reduce download size. The `<picture>` element with `<source>` goes further, allowing art direction (different crops per breakpoint). For responsive layouts, combining `srcset` for performance with CSS `object-fit: cover` and `aspect-ratio` for display control is the ideal pattern.',
  codeExample: '/* CSS for responsive image display */\n.hero-image {\n  width: 100%;\n  height: auto;\n  aspect-ratio: 16 / 9;\n  object-fit: cover;\n}',
  followUp: 'Why can\'t CSS alone solve the responsive image performance problem?',
  keyTakeaway: 'HTML `srcset` optimizes which image to download; CSS controls how it displays — you need both.',
},
{
  id: 53,
  title: 'How do you build a truly fluid layout system that handles every screen size without breakpoints?',
  difficulty: 'hard',
  topic: 'layout-systems',
  subtopic: 'responsive',
  answer: 'A breakpoint-free fluid system combines several techniques. Use `grid-template-columns: repeat(auto-fit, minmax(min(100%, 300px), 1fr))` for grids that go from single-column on mobile to multi-column on desktop automatically. Use `clamp()` for typography and spacing that scales with the viewport. Use `min()` for container widths: `width: min(90%, 1200px)`. The `min(100%, 300px)` pattern inside `minmax()` prevents the grid minimum from exceeding the container on narrow screens. Combine with CSS custom properties for a maintainable fluid scale. This approach eliminates most media queries, though some remain necessary for truly different layouts (like moving a sidebar below content).',
  codeExample: '.fluid-grid {\n  display: grid;\n  grid-template-columns: repeat(\n    auto-fit,\n    minmax(min(100%, 300px), 1fr)\n  );\n  gap: clamp(1rem, 3vw, 2rem);\n  padding: clamp(1rem, 5vw, 3rem);\n}',
  followUp: 'What are the limits of breakpoint-free design — when do you still need media queries?',
  keyTakeaway: 'Combine `auto-fit`, `minmax()`, `min()`, and `clamp()` for layouts that adapt without breakpoints.',
},
{
  id: 54,
  title: 'How do you handle responsive typography at scale, including line length control and vertical rhythm?',
  difficulty: 'hard',
  topic: 'layout-systems',
  subtopic: 'responsive',
  answer: 'Fluid typography uses `clamp()` to scale font sizes between minimum and maximum values, but true typographic control goes further. Line length (measure) should stay between 45-75 characters: use `max-width: 65ch` on text containers. Vertical rhythm means all spacing is based on a consistent baseline unit — typically the body line-height. Use a modular type scale where each level is a ratio of the base (e.g., 1.25 or the "major third" scale). Implement this as CSS custom properties that `clamp()` between mobile and desktop values. The hardest part is maintaining rhythm when mixing content types: images, code blocks, and headings all need spacing that is a multiple of the base line-height.',
  codeExample: ':root {\n  --step-0: clamp(1rem, 0.5rem + 1vw, 1.125rem);\n  --step-1: clamp(1.25rem, 0.75rem + 1.2vw, 1.5rem);\n  --step-2: clamp(1.563rem, 1rem + 1.5vw, 2rem);\n}\n\n.prose {\n  font-size: var(--step-0);\n  line-height: 1.65;\n  max-width: 65ch;\n}',
  followUp: 'How does `ch` unit sizing for line length behave with variable-width fonts versus monospace?',
  keyTakeaway: 'Fluid typography needs `clamp()` for sizing, `ch` units for measure, and a modular scale for harmony.',
},
{
  id: 55,
  title: 'What are container queries and how do they differ from media queries?',
  difficulty: 'medium',
  topic: 'layout-systems',
  subtopic: 'container-queries',
  answer: 'Container queries allow you to style an element based on the size of its parent container rather than the viewport. This is declared with `container-type: inline-size` on the parent, which establishes it as a containment context. You then use `@container` rules instead of `@media` rules. The key difference is that media queries are global (viewport-based) while container queries are local (component-based). This means a card component can rearrange itself whether it\'s in a narrow sidebar or a wide main area, without the component knowing anything about the page layout. You can also name containers with `container-name` to target specific ancestors.',
  codeExample: '.card-wrapper {\n  container-type: inline-size;\n  container-name: card;\n}\n\n@container card (min-width: 400px) {\n  .card {\n    display: grid;\n    grid-template-columns: 200px 1fr;\n  }\n}\n\n@container card (max-width: 399px) {\n  .card {\n    display: flex;\n    flex-direction: column;\n  }\n}',
  followUp: 'Why does `container-type: inline-size` require size containment and what layout implications does that have?',
  keyTakeaway: 'Container queries style elements based on their parent\'s size — making truly reusable components possible.',
},
{
  id: 56,
  title: 'How does container query size containment work under the hood and what are its limitations?',
  difficulty: 'hard',
  topic: 'layout-systems',
  subtopic: 'container-queries',
  answer: 'Setting `container-type: inline-size` applies CSS containment to the element, meaning its inline size cannot depend on its children — this breaks the circular dependency where a child\'s styles depend on the parent\'s size, which depends on the child\'s size. This containment has real consequences: the container must get its size from its own context (parent, grid track, explicit width), not from its content. An element with `container-type: inline-size` and no external sizing constraint collapses to zero width. You cannot query the block (height) axis with `inline-size` containment — for that you need `container-type: size`, which applies both inline and block containment. Block containment is rarely practical because it requires explicit height, defeating the purpose of content-driven layouts.',
  followUp: 'Can you nest container queries, and if so, which container does an inner `@container` rule resolve against?',
  keyTakeaway: 'Container queries require size containment — the container\'s size must not depend on its children.',
},
{
  id: 57,
  title: 'What are CSS logical properties and why should you use them?',
  difficulty: 'medium',
  topic: 'layout-systems',
  subtopic: 'logical-properties',
  answer: 'Logical properties replace physical direction properties (like `margin-left`, `padding-top`) with flow-relative ones (`margin-inline-start`, `padding-block-start`) that adapt to writing mode and text direction. In a left-to-right language, `margin-inline-start` equals `margin-left`, but in a right-to-left language like Arabic, it automatically becomes `margin-right`. The `block` axis maps to the vertical direction in horizontal writing modes, and `inline` maps to horizontal. Shorthand properties like `margin-inline` and `padding-block` set both start and end values at once. Using logical properties makes your CSS internationalization-ready without any additional code.',
  codeExample: '/* Physical (breaks in RTL) */\n.old-way {\n  margin-left: 1rem;\n  padding-right: 2rem;\n  border-bottom: 1px solid;\n}\n\n/* Logical (works in any direction) */\n.new-way {\n  margin-inline-start: 1rem;\n  padding-inline-end: 2rem;\n  border-block-end: 1px solid;\n}',
  followUp: 'How do logical properties interact with `flexbox` and `grid` which are already flow-relative?',
  keyTakeaway: 'Logical properties adapt to writing direction automatically — use `inline`/`block` instead of `left`/`right`/`top`/`bottom`.',
},
{
  id: 58,
  title: 'How do logical properties interact with the full CSS layout system including transforms, positioning, and scroll behavior?',
  difficulty: 'hard',
  topic: 'layout-systems',
  subtopic: 'logical-properties',
  answer: 'Logical properties have uneven adoption across CSS features. Box model properties (`margin`, `padding`, `border`) fully support logical equivalents. The `inset-inline-start` and `inset-block-start` properties replace `left`/`top` for positioned elements. `overflow-inline` and `overflow-block` replace `overflow-x`/`overflow-y`. However, `transform: translateX()` has no logical equivalent — you\'d need to use custom properties or `dir`-based selectors for RTL transforms. Similarly, `scroll-margin-left` has a logical `scroll-margin-inline-start` equivalent, but scroll snap alignment is physical. The `resize` property now accepts `block` and `inline` values. When mixing logical and physical properties, physical properties always map to their physical axis regardless of writing mode, which can cause subtle bugs if both are used on the same element.',
  codeExample: '.positioned {\n  position: absolute;\n  inset-block-start: 0;     /* replaces top */\n  inset-inline-end: 1rem;   /* replaces right in LTR */\n}\n\n/* transforms have no logical equivalent */\n:dir(rtl) .slider {\n  transform: translateX(100%); /* must flip manually */\n}',
  followUp: 'How would you build a fully logical-property-based layout system that handles the gaps where logical properties don\'t exist?',
  keyTakeaway: 'Logical properties cover box model and positioning but not transforms — plan for the gaps in RTL layouts.',
},
{
    id: 59,
    title: 'What does the `:nth-child()` pseudo-class do, and how does the `An+B` syntax work?',
    difficulty: 'easy',
    topic: 'modern-css',
    subtopic: 'selectors',
    answer: 'The `:nth-child()` pseudo-class selects elements based on their position among siblings using the `An+B` formula. `A` is the cycle size, `n` is a counter starting from 0, and `B` is the offset. For example, `:nth-child(2n+1)` selects odd children (1st, 3rd, 5th, etc.), while `:nth-child(3n)` selects every third child. You can also use keywords like `odd` and `even` for readability.',
    codeExample: '/* Select every odd row */\ntr:nth-child(odd) {\n  background-color: #f9f9f9;\n}\n\n/* Select every 3rd element starting from the 2nd */\nli:nth-child(3n+2) {\n  color: blue;\n}',
    followUp: 'What is the difference between `:nth-child()` and `:nth-of-type()`, and when would you choose one over the other?',
    keyTakeaway: '`:nth-child(An+B)` selects elements by position using a cycle-size (A) and offset (B) formula.',
  },
  {
    id: 60,
    title: 'What is the difference between the `>` (child combinator) and the ` ` (descendant combinator) in CSS selectors?',
    difficulty: 'easy',
    topic: 'modern-css',
    subtopic: 'selectors',
    answer: 'The descendant combinator (a space) selects all matching elements nested at any depth within the ancestor, while the child combinator (`>`) selects only direct children. For example, `div p` matches any `<p>` inside a `<div>` regardless of nesting depth, but `div > p` matches only `<p>` elements that are immediate children of a `<div>`. The child combinator is stricter and more performant because the browser does not need to traverse the entire subtree. Using `>` is a good practice when you want to avoid unintended matches in deeply nested structures.',
    codeExample: '/* Matches any <p> nested inside .card */\n.card p {\n  color: gray;\n}\n\n/* Matches only direct <p> children of .card */\n.card > p {\n  color: black;\n}',
    followUp: 'Can you name the four CSS combinators and give an example of when you would use the sibling combinator (`~`)?',
    keyTakeaway: '`>` selects only direct children; a space selects all descendants at any depth.',
  },
  {
    id: 61,
    title: 'Explain the `:is()` and `:where()` pseudo-class functions. How do they differ?',
    difficulty: 'medium',
    topic: 'modern-css',
    subtopic: 'selectors',
    answer: 'Both `:is()` and `:where()` accept a selector list and match any element that matches at least one of the selectors in the list. They simplify repetitive selector patterns by grouping alternatives. The key difference is specificity: `:is()` takes the specificity of its most specific argument, whereas `:where()` always has zero specificity. This makes `:where()` ideal for default styles that should be easy to override, while `:is()` is better when you want the specificity to reflect the selectors used. Neither function accepts pseudo-elements in its selector list.',
    codeExample: '/* :is() — specificity equals the highest argument */\n:is(h1, h2, h3) {\n  line-height: 1.2;\n}\n\n/* :where() — zero specificity, easily overridden */\n:where(.card, .panel) p {\n  margin-bottom: 1em;\n}',
    followUp: 'If `:is(.foo, #bar)` is used, what specificity does the entire selector carry and why might that be surprising?',
    keyTakeaway: '`:is()` inherits the highest specificity from its arguments; `:where()` always contributes zero specificity.',
  },
  {
    id: 62,
    title: 'How does the `:has()` pseudo-class work, and why is it called the "parent selector"?',
    difficulty: 'medium',
    topic: 'modern-css',
    subtopic: 'selectors',
    answer: 'The `:has()` pseudo-class selects an element if it contains at least one descendant (or matches a relative selector) specified inside the parentheses. It is called the "parent selector" because it lets you style a parent based on its children, which was impossible in CSS before. For example, `div:has(> img)` selects any `<div>` with a direct `<img>` child. You can combine it with other selectors like `form:has(:invalid)` to style a form when it contains invalid inputs. It can also be used for sibling-aware selection, such as `h2:has(+ p)` to select an `h2` directly followed by a `p`.',
    codeExample: '/* Style a card differently if it contains an image */\n.card:has(img) {\n  grid-template-rows: auto 1fr;\n}\n\n/* Highlight a label when its input is focused */\nlabel:has(+ input:focus) {\n  color: blue;\n}',
    followUp: 'Can `:has()` be used inside `:not()` or other functional pseudo-classes, and what are browser support considerations?',
    keyTakeaway: '`:has()` is the first real parent selector in CSS — it styles elements based on what they contain.',
  },
  {
    id: 63,
    title: 'What is the `:not()` pseudo-class and how does its specificity behave in CSS Selectors Level 4?',
    difficulty: 'medium',
    topic: 'modern-css',
    subtopic: 'selectors',
    answer: 'The `:not()` pseudo-class matches elements that do not match the given selector argument. In CSS Selectors Level 3, `:not()` accepted only a single simple selector. In Level 4, it accepts a full selector list like `:not(.a, .b)`. The specificity of `:not()` is equal to the most specific selector in its argument list, just like `:is()`. The `:not()` pseudo-class itself does not add any specificity beyond its arguments. This means `:not(#id)` has the same specificity as `#id` alone.',
    codeExample: '/* Level 3 — single simple selector */\na:not(.external) {\n  text-decoration: none;\n}\n\n/* Level 4 — selector list */\nbutton:not(:disabled, .hidden) {\n  cursor: pointer;\n}',
    followUp: 'What happens if you write `:not(:not(.foo))` — does it simplify to `.foo`, and are there performance concerns with deeply nested negation?',
    keyTakeaway: '`:not()` excludes matching elements, and its specificity equals that of its most specific argument.',
  },
  {
    id: 64,
    title: 'How do attribute selectors work, and what are the substring-matching variants?',
    difficulty: 'hard',
    topic: 'modern-css',
    subtopic: 'selectors',
    answer: 'Attribute selectors match elements based on the presence or value of an attribute. The exact match `[attr="value"]` requires a full value match. Substring variants include `[attr^="val"]` (starts with), `[attr$="val"]` (ends with), and `[attr*="val"]` (contains). The `[attr~="val"]` form matches a space-separated word in the attribute, while `[attr|="val"]` matches the value or the value followed by a hyphen (useful for language codes). Adding the `i` flag like `[attr="val" i]` makes the comparison case-insensitive. These selectors have the same specificity as a class selector (0,1,0).',
    codeExample: '/* Links that open in a new tab */\na[target="_blank"] {\n  padding-right: 1em;\n}\n\n/* External links (start with https) */\na[href^="https://"] {\n  color: green;\n}\n\n/* Case-insensitive match */\ninput[type="email" i] {\n  border-color: blue;\n}',
    followUp: 'How do attribute selectors compare in performance to class selectors, and when should you prefer one over the other?',
    keyTakeaway: 'Attribute selectors match by presence or value patterns (`^=`, `$=`, `*=`) and carry class-level specificity.',
  },
  {
    id: 65,
    title: 'How does `:has()` enable complex conditional styling, and what are its performance implications?',
    difficulty: 'hard',
    topic: 'modern-css',
    subtopic: 'selectors',
    answer: 'The `:has()` pseudo-class enables patterns that previously required JavaScript, such as styling an ancestor based on the state of a deeply nested descendant. Combined with other pseudo-classes, you can write selectors like `.form:has(:focus-visible)` to apply styles when any descendant has keyboard focus, or `body:has(.modal.open)` to apply an overlay. Performance-wise, `:has()` forces the browser to evaluate selectors in a bottom-up and top-down direction, which can be expensive on large DOMs. Browsers mitigate this with caching and style invalidation optimizations, but overusing complex `:has()` selectors in frequently changing parts of the DOM can cause style recalculation bottlenecks. Limiting the depth and frequency of `:has()` usage in animation-heavy contexts is a recommended best practice.',
    codeExample: '/* Responsive quantity query — style a list based on item count */\nul:has(li:nth-child(6)) {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n}\n\n/* Theme switching without JS */\nbody:has(#dark-toggle:checked) {\n  --bg: #111;\n  --text: #eee;\n}',
    followUp: 'Can you explain how the browser invalidation model works for `:has()` selectors and why it differs from other pseudo-classes?',
    keyTakeaway: '`:has()` unlocks ancestor and quantity-based styling but demands awareness of its performance cost on large DOMs.',
  },
  {
    id: 66,
    title: 'What are CSS custom properties (variables) and how do you declare and use them?',
    difficulty: 'easy',
    topic: 'modern-css',
    subtopic: 'css-variables',
    answer: 'CSS custom properties, also known as CSS variables, are entities defined by authors that hold specific values to be reused throughout a document. They are declared with a double-hyphen prefix like `--primary-color: blue` and accessed using the `var()` function. Custom properties follow the cascade and are inherited by default, meaning child elements receive their parent\'s values. The `var()` function accepts an optional fallback value as a second argument, such as `var(--color, black)`. They are resolved at computed-value time, which means they are live and can be changed at runtime via JavaScript or media queries.',
    codeExample: ':root {\n  --primary: #3b82f6;\n  --spacing: 16px;\n}\n\n.button {\n  background: var(--primary);\n  padding: var(--spacing);\n  margin-bottom: var(--spacing-lg, 24px);\n}',
    followUp: 'How do CSS custom properties differ from Sass variables in terms of cascade behavior and runtime capabilities?',
    keyTakeaway: 'CSS custom properties are live, inherited, cascade-aware variables declared with `--` and consumed with `var()`.',
  },
  {
    id: 67,
    title: 'How does the fallback mechanism work in the `var()` function?',
    difficulty: 'easy',
    topic: 'modern-css',
    subtopic: 'css-variables',
    answer: 'The `var()` function accepts two arguments: the custom property name and an optional fallback value. If the referenced custom property is not defined or is invalid, the fallback value is used instead. Fallbacks can themselves contain `var()` references, allowing chained defaults like `var(--theme-color, var(--default-color, blue))`. However, a comma within the fallback is treated as part of the fallback value, so `var(--font, Helvetica, Arial, sans-serif)` correctly yields `Helvetica, Arial, sans-serif`. The fallback is only triggered when the property is not registered on any ancestor, not when the property\'s value is an empty string.',
    codeExample: '.card {\n  /* Single fallback */\n  color: var(--card-text, #333);\n\n  /* Chained fallback */\n  background: var(--card-bg, var(--surface-bg, white));\n\n  /* Comma in fallback is legal */\n  font-family: var(--font-stack, "Inter", system-ui, sans-serif);\n}',
    followUp: 'What happens when a custom property is set to `initial` — does it trigger the fallback or produce an invalid value?',
    keyTakeaway: 'The `var()` fallback fires when the property is undefined; commas inside it are part of the fallback value.',
  },
  {
    id: 68,
    title: 'How does custom property scoping and inheritance work, and how can you prevent inheritance?',
    difficulty: 'medium',
    topic: 'modern-css',
    subtopic: 'css-variables',
    answer: 'CSS custom properties inherit by default, meaning a value set on a parent is available to all descendants. You can scope a variable by defining it on a specific selector rather than `:root`, limiting its availability to that element and its children. To prevent inheritance, you can re-declare the property with a new value on a child, or use the `@property` at-rule to register the custom property with `inherits: false`. The `@property` rule also allows you to define a type syntax and initial value, giving the browser enough information to animate the property and catch invalid values early. This registration makes custom properties behave more like built-in CSS properties.',
    codeExample: '/* Inherited by default */\n.theme-dark {\n  --bg: #1a1a2e;\n}\n\n/* Registered — not inherited, typed */\n@property --progress {\n  syntax: "<percentage>";\n  inherits: false;\n  initial-value: 0%;\n}',
    followUp: 'What are the practical benefits of registering a custom property with `@property` beyond preventing inheritance?',
    keyTakeaway: 'Custom properties inherit by default; use `@property` with `inherits: false` to scope them tightly.',
  },
  {
    id: 69,
    title: 'How do CSS custom properties interact with the CSSOM and JavaScript at runtime?',
    difficulty: 'medium',
    topic: 'modern-css',
    subtopic: 'css-variables',
    answer: 'CSS custom properties can be read and written from JavaScript using the CSSOM. You can get a computed value with `getComputedStyle(element).getPropertyValue("--my-var")` and set one with `element.style.setProperty("--my-var", "newValue")`. Because custom properties participate in the cascade, setting a variable on an element via JS affects all descendants that reference it, enabling efficient theme switching or dynamic styling without touching individual properties. Changes trigger style recalculation for affected subtrees. The `CSS.registerProperty()` method is the JS equivalent of the `@property` at-rule, allowing runtime registration with type checking.',
    codeExample: '// Read a custom property\nconst root = document.documentElement;\nconst color = getComputedStyle(root)\n  .getPropertyValue("--primary");\n\n// Set a custom property\nroot.style.setProperty("--primary", "#e11d48");\n\n// Register via JS\nCSS.registerProperty({\n  name: "--angle",\n  syntax: "<angle>",\n  inherits: false,\n  initialValue: "0deg",\n});',
    followUp: 'What performance considerations should you keep in mind when frequently updating CSS custom properties from JavaScript?',
    keyTakeaway: 'Custom properties are live CSSOM values — reading with `getComputedStyle` and writing with `setProperty` updates styles reactively.',
  },
  {
    id: 70,
    title: 'How can you animate CSS custom properties, and why does `@property` registration matter?',
    difficulty: 'hard',
    topic: 'modern-css',
    subtopic: 'css-variables',
    answer: 'By default, CSS custom properties cannot be animated because the browser treats them as opaque strings with no interpolation logic. When you register a custom property using `@property` with a defined `syntax` (e.g., `<number>`, `<color>`, `<length>`), the browser knows the value type and can interpolate between keyframes. This enables smooth transitions and animations on custom properties, unlocking effects like animated gradients, dynamic hue rotations, and progress indicators that are impossible with static properties. Without registration, the transition will snap between values at 50% of the duration. This feature is fundamental to many modern creative CSS techniques.',
    codeExample: '@property --hue {\n  syntax: "<number>";\n  inherits: false;\n  initial-value: 0;\n}\n\n.gradient-box {\n  --hue: 0;\n  background: hsl(var(--hue), 80%, 60%);\n  transition: --hue 1s ease;\n}\n\n.gradient-box:hover {\n  --hue: 240;\n}',
    followUp: 'What `syntax` descriptors does `@property` support, and what happens if you assign a value that does not match the declared syntax?',
    keyTakeaway: 'Register custom properties with `@property` to give the browser a type, enabling smooth interpolation and animation.',
  },
  {
    id: 71,
    title: 'How does the `@property` at-rule enable type-safe theming systems, and what are the edge cases?',
    difficulty: 'hard',
    topic: 'modern-css',
    subtopic: 'css-variables',
    answer: 'The `@property` at-rule allows you to declare the expected type (`syntax`), inheritance behavior, and initial value for a custom property. This creates a contract: if an assigned value does not match the syntax, it is treated as invalid at computed-value time, and the initial value is used instead. This enables type-safe theming where assigning the wrong type of value fails gracefully rather than silently breaking styles. Edge cases include the fact that the `syntax` descriptor supports union types like `<length> | <percentage>` but does not support all CSS types. Duplicate `@property` rules follow cascade order, so the last declaration wins. Importantly, `@property` registrations are document-global, not scoped to shadow DOM boundaries, which can cause conflicts in web component architectures.',
    codeExample: '@property --radius {\n  syntax: "<length>";\n  inherits: true;\n  initial-value: 4px;\n}\n\n/* This works */\n.card { --radius: 8px; }\n\n/* This is invalid — falls back to 4px */\n.card { --radius: red; }\n\n/* Union syntax */\n@property --size {\n  syntax: "<length> | <percentage>";\n  inherits: false;\n  initial-value: 100%;\n}',
    followUp: 'How do `@property` registrations interact with Shadow DOM encapsulation, and can they be scoped to a component?',
    keyTakeaway: '`@property` creates a typed contract for custom properties — invalid values fall back to the initial value automatically.',
  },
  {
    id: 72,
    title: 'What is the difference between CSS `transition` and `animation`, and when should you use each?',
    difficulty: 'easy',
    topic: 'modern-css',
    subtopic: 'animations',
    answer: 'CSS `transition` animates a property change between two states, triggered by a state change like `:hover` or a class toggle. CSS `animation` uses `@keyframes` to define multi-step sequences that can run automatically, loop, and alternate direction without needing a trigger. Transitions are simpler and best for interactive UI feedback such as button hovers and focus states. Animations are better for complex, multi-step sequences like loading spinners, attention-grabbing effects, or orchestrated entrance animations. Transitions require an explicit property change to trigger, whereas animations begin as specified by `animation-play-state` or upon element render.',
    codeExample: '/* Transition: smooth hover effect */\n.button {\n  background: blue;\n  transition: background 0.3s ease;\n}\n.button:hover {\n  background: darkblue;\n}\n\n/* Animation: continuous spin */\n@keyframes spin {\n  to { transform: rotate(360deg); }\n}\n.loader {\n  animation: spin 1s linear infinite;\n}',
    followUp: 'Can you combine transitions and animations on the same element, and what happens if they target the same property?',
    keyTakeaway: 'Transitions react to state changes between two values; animations define multi-step sequences with `@keyframes`.',
  },
  {
    id: 73,
    title: 'What are the different `animation-fill-mode` values and why do they matter?',
    difficulty: 'easy',
    topic: 'modern-css',
    subtopic: 'animations',
    answer: 'The `animation-fill-mode` property controls what styles apply to an element before and after an animation runs. `none` (the default) means the element reverts to its original styles outside the animation period. `forwards` retains the styles from the last keyframe after the animation ends. `backwards` applies the first keyframe\'s styles during the `animation-delay` period before the animation starts. `both` combines `forwards` and `backwards`, applying first-keyframe styles before and last-keyframe styles after. This property is critical for preventing the visual "snap-back" that occurs when an animated element reverts to its pre-animation state.',
    codeExample: '.fade-in {\n  opacity: 0;\n  animation: appear 0.5s ease forwards;\n}\n\n@keyframes appear {\n  to { opacity: 1; }\n}\n\n/* Without forwards, opacity snaps back to 0 after animation */\n/* With both, delay period also shows first keyframe */\n.slide-in {\n  animation: slideUp 0.3s ease 0.5s both;\n}',
    followUp: 'How does `animation-fill-mode` interact with the cascade — do filled styles override inline styles?',
    keyTakeaway: '`animation-fill-mode: forwards` keeps end-state styles; `both` covers the delay period and end state.',
  },
  {
    id: 74,
    title: 'What triggers layout, paint, and composite in the browser rendering pipeline, and how does this affect animation performance?',
    difficulty: 'medium',
    topic: 'modern-css',
    subtopic: 'animations',
    answer: 'The browser rendering pipeline has three main stages: layout (calculating element geometry), paint (filling pixels), and composite (layering painted tiles). Changing properties like `width`, `height`, or `margin` triggers a full layout recalculation, which is the most expensive. Properties like `color`, `background`, or `box-shadow` skip layout but trigger repaint. Only `transform` and `opacity` can be handled entirely on the compositor thread, making them the cheapest to animate. For smooth 60fps animations, you should animate `transform` and `opacity` whenever possible, using `translate()` instead of `top`/`left` and `opacity` instead of `visibility`. The `will-change` property can hint the browser to promote an element to its own compositing layer.',
    codeExample: '/* Expensive: triggers layout on every frame */\n.bad {\n  transition: left 0.3s, width 0.3s;\n}\n\n/* Cheap: compositor-only properties */\n.good {\n  transition: transform 0.3s, opacity 0.3s;\n}\n\n/* Promote to own layer for complex animations */\n.animated {\n  will-change: transform;\n}',
    followUp: 'What are the downsides of overusing `will-change`, and how does layer promotion affect memory usage?',
    keyTakeaway: 'Animate `transform` and `opacity` for 60fps — they skip layout and paint, running on the compositor thread.',
  },
  {
    id: 75,
    title: 'How do CSS `@keyframes` work with multiple stops, and how does `animation-timing-function` apply to each segment?',
    difficulty: 'medium',
    topic: 'modern-css',
    subtopic: 'animations',
    answer: 'The `@keyframes` rule defines named animation stages using percentage stops from `0%` (or `from`) to `100%` (or `to`). You can define multiple intermediate stops like `25%`, `50%`, `75%`, and even assign the same styles to multiple stops with comma-separated percentages like `0%, 100% { opacity: 1 }`. The `animation-timing-function` applies independently to each segment between keyframes, not to the animation as a whole. For example, with stops at 0%, 50%, and 100%, the timing function resets at each stop and eases within each segment. You can also set different timing functions per keyframe by declaring `animation-timing-function` inside a keyframe block.',
    codeExample: '@keyframes bounce {\n  0% {\n    transform: translateY(0);\n    animation-timing-function: ease-out;\n  }\n  50% {\n    transform: translateY(-40px);\n    animation-timing-function: ease-in;\n  }\n  100% {\n    transform: translateY(0);\n  }\n}\n\n.ball {\n  animation: bounce 0.6s infinite;\n}',
    followUp: 'How does `animation-direction: alternate` affect the timing function — does it reverse the easing curve?',
    keyTakeaway: 'Timing functions apply per keyframe segment, not the entire animation — set different easings per stop for realistic motion.',
  },
  {
    id: 76,
    title: 'How do you use the Web Animations API alongside CSS animations, and what advantages does it offer?',
    difficulty: 'medium',
    topic: 'modern-css',
    subtopic: 'animations',
    answer: 'The Web Animations API (WAAPI) provides a JavaScript interface for creating and controlling animations using the same rendering engine that powers CSS animations and transitions. You call `element.animate(keyframes, options)` where keyframes is an array of style objects and options control duration, easing, iterations, and fill mode. WAAPI returns an `Animation` object with methods like `play()`, `pause()`, `reverse()`, `cancel()`, and a `finished` promise for sequencing. Unlike CSS animations, WAAPI allows dynamic keyframe generation, precise playback control, and programmatic sequencing without managing CSS class toggling. It uses the compositor path for `transform` and `opacity`, achieving the same performance as CSS animations.',
    codeExample: 'const el = document.querySelector(".box");\n\nconst anim = el.animate([\n  { transform: "translateX(0)", opacity: 1 },\n  { transform: "translateX(300px)", opacity: 0 }\n], {\n  duration: 500,\n  easing: "ease-in-out",\n  fill: "forwards"\n});\n\nanim.finished.then(() => {\n  console.log("Animation complete");\n});',
    followUp: 'How does WAAPI handle composite modes like `add` and `accumulate`, and when would you use them?',
    keyTakeaway: 'The Web Animations API gives JS control over CSS-quality animations with promises, playback control, and dynamic keyframes.',
  },
  {
    id: 77,
    title: 'How do scroll-driven animations work with `animation-timeline`, and how do they differ from scroll-triggered animations?',
    difficulty: 'hard',
    topic: 'modern-css',
    subtopic: 'animations',
    answer: 'Scroll-driven animations bind animation progress directly to scroll position rather than time, using the `animation-timeline` property. You define a `scroll()` timeline that maps a scroller\'s scroll range to the 0%–100% of a `@keyframes` animation. Unlike scroll-triggered animations (which start a time-based animation when an element enters the viewport), scroll-driven animations are continuously linked to scroll progress, so scrubbing backward reverses the animation. There are two types: `scroll()` tracks the scroll position of a container, while `view()` tracks an element\'s position within the viewport. These run on the compositor thread and avoid main-thread JavaScript, delivering smooth performance. The `animation-range` property controls which portion of the scroll range maps to the animation.',
    codeExample: '@keyframes reveal {\n  from { opacity: 0; transform: translateY(50px); }\n  to { opacity: 1; transform: translateY(0); }\n}\n\n.section {\n  animation: reveal linear both;\n  animation-timeline: view();\n  animation-range: entry 0% entry 100%;\n}\n\n/* Progress bar tied to page scroll */\n.progress {\n  animation: grow linear;\n  animation-timeline: scroll(root);\n}\n\n@keyframes grow {\n  to { transform: scaleX(1); }\n}',
    followUp: 'How does `animation-range` work with named timeline ranges like `entry`, `exit`, `contain`, and `cover`?',
    keyTakeaway: 'Scroll-driven animations tie `@keyframes` progress to scroll position, running smoothly on the compositor thread.',
  },
  {
    id: 78,
    title: 'How do the `@starting-style` rule and `transition-behavior: allow-discrete` enable transitions on display changes?',
    difficulty: 'hard',
    topic: 'modern-css',
    subtopic: 'animations',
    answer: 'Historically, CSS transitions could not animate elements entering or leaving the DOM (e.g., `display: none` to `display: block`) because `display` is a discrete property with no interpolation. The `@starting-style` rule defines the styles an element should transition from when it first appears or has its display changed from `none`. Combined with `transition-behavior: allow-discrete`, the browser can now animate discrete properties by flipping them at the appropriate point during the transition. For entry, the browser applies `@starting-style` values, then transitions to the target state. For exit, you apply the exit styles and the browser keeps the element visible until the transition completes. This eliminates the need for JavaScript-based enter/exit animation libraries for many common use cases.',
    codeExample: '.dialog {\n  opacity: 1;\n  transform: scale(1);\n  transition: opacity 0.3s, transform 0.3s,\n             display 0.3s allow-discrete;\n}\n\n.dialog[hidden] {\n  opacity: 0;\n  transform: scale(0.95);\n  display: none;\n}\n\n@starting-style {\n  .dialog {\n    opacity: 0;\n    transform: scale(0.95);\n  }\n}',
    followUp: 'How does `@starting-style` interact with the `popover` attribute and the `::backdrop` pseudo-element for dialog animations?',
    keyTakeaway: '`@starting-style` defines entry transition origins, and `allow-discrete` enables transitions on `display` changes.',
  },
  {
    id: 79,
    title: 'What are `::before` and `::after` pseudo-elements, and what is the `content` property\'s role?',
    difficulty: 'easy',
    topic: 'modern-css',
    subtopic: 'pseudo-elements',
    answer: 'The `::before` and `::after` pseudo-elements create virtual child elements at the beginning and end of an element\'s content, respectively. They are commonly used for decorative purposes such as icons, shapes, borders, and overlays without adding extra HTML markup. The `content` property is required for them to render — even `content: ""` for purely decorative elements. The `content` property can hold strings, `attr()` functions to pull attribute values, `url()` for images, counters, or special values like `open-quote`. Pseudo-elements are inline by default and can be styled with nearly any CSS property. They do not appear in the DOM and are not accessible to screen readers unless `content` contains meaningful text.',
    codeExample: '.tooltip::after {\n  content: attr(data-tip);\n  position: absolute;\n  bottom: 100%;\n  background: black;\n  color: white;\n  padding: 4px 8px;\n  border-radius: 4px;\n}\n\n.required::before {\n  content: "* ";\n  color: red;\n}',
    followUp: 'Can you use `::before` or `::after` on replaced elements like `<img>` or `<input>`, and why or why not?',
    keyTakeaway: '`::before` and `::after` inject virtual elements via CSS — `content` is required, even as an empty string.',
  },
  {
    id: 80,
    title: 'How do `::marker`, `::placeholder`, and `::selection` pseudo-elements work, and what are their styling limitations?',
    difficulty: 'medium',
    topic: 'modern-css',
    subtopic: 'pseudo-elements',
    answer: '`::marker` targets the bullet or number of list items and accepts a limited set of properties including `color`, `font-size`, `content`, and `animation` properties. `::placeholder` styles the placeholder text in input and textarea elements, but only supports a subset of properties like `color`, `font`, `opacity`, and `text-transform` — it cannot change layout properties like `padding`. `::selection` styles user-selected (highlighted) text and is limited to `color`, `background-color`, `text-decoration`, `text-shadow`, and `stroke` properties. All three pseudo-elements have restricted property sets because they target browser-controlled content where full styling could break expected behavior or accessibility. Their specificity follows standard pseudo-element rules.',
    codeExample: '/* Custom list markers */\nli::marker {\n  color: coral;\n  font-size: 1.2em;\n  content: "→ ";\n}\n\n/* Placeholder styling */\ninput::placeholder {\n  color: #999;\n  font-style: italic;\n}\n\n/* Selection colors */\n::selection {\n  background-color: #3b82f6;\n  color: white;\n}',
    followUp: 'Why can\'t you set `padding` or `margin` on `::placeholder`, and how do pseudo-element styling restrictions get decided by browser vendors?',
    keyTakeaway: '`::marker`, `::placeholder`, and `::selection` style specific UI parts but accept only a restricted subset of CSS properties.',
  },
  {
    id: 81,
    title: 'How do the `::part()` and `::slotted()` pseudo-elements enable styling within Shadow DOM boundaries?',
    difficulty: 'hard',
    topic: 'modern-css',
    subtopic: 'pseudo-elements',
    answer: 'The Shadow DOM encapsulates styles, preventing outside CSS from reaching internal elements. The `::part()` pseudo-element pierces this boundary by targeting elements that have been explicitly exposed with the `part` attribute inside the shadow tree. For example, `my-component::part(header)` styles any element inside the shadow DOM with `part="header"`. The `::slotted()` pseudo-element, used inside shadow DOM stylesheets, targets elements that are slotted into `<slot>` elements from the light DOM. A key limitation is that `::slotted()` only matches top-level slotted elements, not their descendants. The `::part()` mechanism is deliberate — component authors choose exactly which internal elements can be styled from outside, maintaining controlled customization without breaking encapsulation.',
    codeExample: '<!-- Component internal shadow DOM -->\n<template>\n  <div part="header">Title</div>\n  <slot></slot>\n</template>\n\n/* External stylesheet — style exposed parts */\nmy-card::part(header) {\n  font-size: 1.5em;\n  color: navy;\n}\n\n/* Inside shadow DOM — style slotted content */\n::slotted(p) {\n  margin-bottom: 1em;\n}\n\n/* ❌ Won\'t work — ::slotted only targets top-level */\n::slotted(p span) {\n  color: red;\n}',
    followUp: 'Can `::part()` names be forwarded through nested shadow DOM layers, and how does the `exportparts` attribute work?',
    keyTakeaway: '`::part()` lets outsiders style explicitly exposed shadow DOM elements; `::slotted()` styles slotted light DOM content.',
  },
  {
    id: 82,
    title: 'What is CSS Container Queries and how does `@container` differ from `@media` queries?',
    difficulty: 'medium',
    topic: 'modern-css',
    subtopic: 'new-features',
    answer: 'CSS Container Queries allow components to adapt their styles based on the size of a parent container rather than the viewport. You first declare a containment context with `container-type: inline-size` on a parent element, then use `@container` rules to apply styles based on that container\'s dimensions. Unlike `@media` queries that respond to the viewport, `@container` queries make truly reusable components that adapt regardless of where they are placed in a layout. You can name containers with `container-name` to target specific ancestors. Container queries support size conditions like `min-width`, `max-width`, and style conditions using `style()` for querying custom property values. This enables component-level responsive design rather than page-level.',
    codeExample: '.card-wrapper {\n  container-type: inline-size;\n  container-name: card;\n}\n\n@container card (min-width: 400px) {\n  .card {\n    display: grid;\n    grid-template-columns: 200px 1fr;\n  }\n}\n\n@container card (max-width: 399px) {\n  .card {\n    display: flex;\n    flex-direction: column;\n  }\n}',
    followUp: 'How do container style queries with `style()` work, and can you query the computed value of a standard CSS property or only custom properties?',
    keyTakeaway: 'Container queries let components respond to their parent\'s size — making truly reusable responsive components.',
  },
  {
    id: 83,
    title: 'How does CSS Nesting work natively, and what are the differences from preprocessor nesting?',
    difficulty: 'hard',
    topic: 'modern-css',
    subtopic: 'new-features',
    answer: 'Native CSS nesting allows writing child rules inside parent rules, similar to Sass or Less, but directly in the browser without a build step. The `&` symbol represents the parent selector and is required when the nested selector starts with a type selector (e.g., `& div`) though it can be omitted when nesting starts with a symbol like `.`, `#`, `:`, or `[`. Unlike preprocessor nesting, native CSS nesting is resolved at parse time and follows CSS specificity rules, meaning `& .child` has the combined specificity of the parent and child selectors. You can nest media queries and other at-rules inside selectors, and they automatically scope to the parent. One key difference from Sass is that native nesting cannot concatenate class names — `&-suffix` does not work because `&` is a full selector, not a string token. The relaxed parsing rules (since late 2023) allow nesting without `&` in most cases.',
    codeExample: '.card {\n  padding: 1rem;\n\n  .title {\n    font-size: 1.25em;\n  }\n\n  &:hover {\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n  }\n\n  /* Nested media query scoped to .card */\n  @media (width >= 768px) {\n    grid-template-columns: 1fr 1fr;\n  }\n\n  /* ❌ Doesn\'t work — no string concatenation */\n  /* &-header { } */\n}',
    followUp: 'How does native CSS nesting interact with the cascade and specificity compared to flat selectors, and are there performance differences?',
    keyTakeaway: 'Native CSS nesting uses `&` for parent references but cannot concatenate strings — it is real selector composition, not text substitution.',
  },
{
  id: 84,
  title: 'What is the BEM naming convention and why is it used?',
  difficulty: 'easy',
  topic: 'architecture-performance',
  subtopic: 'methodologies',
  answer: 'BEM stands for Block, Element, Modifier — a naming convention that organizes CSS into reusable components. A Block is a standalone entity like `.card`, an Element is a part of a block like `.card__title`, and a Modifier is a variation like `.card--featured`. BEM keeps specificity flat because every selector is a single class, avoiding deep nesting and specificity wars. It makes stylesheets predictable and self-documenting since the class name reveals the relationship between components and their parts.',
  codeExample: '/* Block */\n.card { }\n\n/* Element */\n.card__title { }\n.card__body { }\n\n/* Modifier */\n.card--featured { }\n.card__title--large { }',
  followUp: 'What are common mistakes teams make when adopting BEM?',
  keyTakeaway: 'BEM keeps specificity flat and class names self-documenting by encoding component relationships into the naming convention.',
},
{
  id: 85,
  title: 'What is ITCSS and how does it organize stylesheets?',
  difficulty: 'easy',
  topic: 'architecture-performance',
  subtopic: 'methodologies',
  answer: 'ITCSS (Inverted Triangle CSS) is a methodology that organizes stylesheets by specificity, from the least specific at the top to the most specific at the bottom. The layers typically include Settings, Tools, Generic, Elements, Objects, Components, and Utilities. Each layer has a higher specificity reach than the one before it, which eliminates specificity conflicts by design. This approach works well with any naming convention like BEM and scales effectively in large codebases because developers know exactly where new styles belong.',
  followUp: 'How would you adapt ITCSS for a project using CSS custom properties and modern cascade layers?',
  keyTakeaway: 'ITCSS tames the cascade by ordering styles from generic to explicit, preventing specificity conflicts structurally.',
},
{
  id: 86,
  title: 'Compare CSS Modules, BEM, and CSS-in-JS as styling approaches for component-based architectures.',
  difficulty: 'medium',
  topic: 'architecture-performance',
  subtopic: 'methodologies',
  answer: 'BEM is a naming convention that relies on developer discipline to avoid collisions — it adds no runtime cost but has no tooling enforcement. CSS Modules generate unique class names at build time, providing true scope isolation with zero runtime overhead and standard CSS authoring. CSS-in-JS libraries like styled-components or Emotion co-locate styles with components and enable dynamic styling via props, but they add a runtime cost for style generation and increase bundle size. For performance-critical applications, CSS Modules offer the best balance of scoping and zero-runtime cost, while CSS-in-JS excels in highly dynamic theming scenarios.',
  followUp: 'How does the new CSS `@scope` rule compare to these approaches for native scope isolation?',
  keyTakeaway: 'CSS Modules give you scoping guarantees at build time without runtime cost, making them ideal for performance-sensitive apps.',
},
{
  id: 87,
  title: 'How do utility-first frameworks like Tailwind differ architecturally from component-based CSS methodologies?',
  difficulty: 'medium',
  topic: 'architecture-performance',
  subtopic: 'methodologies',
  answer: 'Utility-first frameworks compose styles directly in markup using small, single-purpose classes like `flex`, `p-4`, and `text-center`, eliminating the need to name and maintain separate CSS class hierarchies. Component-based methodologies like BEM or SMACSS create semantic abstractions in CSS files that are referenced in markup. Utility-first approaches produce smaller CSS bundles through purging unused classes and avoid specificity escalation since utilities are all single-class selectors. The tradeoff is that design consistency must be enforced through a token configuration file rather than semantic class names, and complex component patterns can lead to verbose markup.',
  followUp: 'How would you handle complex responsive hover states in a utility-first framework without duplicating class lists?',
  keyTakeaway: 'Utility-first frameworks shift the abstraction layer from CSS files into markup, trading semantic naming for composability and smaller bundles.',
},
{
  id: 88,
  title: 'Design a CSS architecture strategy for a large multi-team design system that must scale across dozens of applications.',
  difficulty: 'hard',
  topic: 'architecture-performance',
  subtopic: 'methodologies',
  answer: 'A scalable design system architecture starts with a token layer using CSS custom properties for colors, spacing, and typography, distributed as a standalone package. Above the tokens sits a base reset and element layer. Component styles should use CSS Modules or `@layer` for scope isolation, with each component packaged independently for tree-shaking. Use cascade layers (`@layer tokens, base, components, utilities, overrides`) to give consuming applications a predictable override mechanism. Version the token and component packages separately so teams can adopt updates incrementally. Include a linting step that flags hardcoded values and enforces token usage across all consuming repos.',
  codeExample: '@layer tokens, base, components, utilities, overrides;\n\n@layer tokens {\n  :root {\n    --color-primary: #0066ff;\n    --spacing-md: 1rem;\n  }\n}\n\n@layer components {\n  .button {\n    background: var(--color-primary);\n    padding: var(--spacing-md);\n  }\n}\n\n@layer overrides {\n  /* App-specific overrides */\n}',
  followUp: 'How would you handle breaking changes in the token layer without disrupting all consuming applications simultaneously?',
  keyTakeaway: 'Scalable design systems use layered tokens, isolated component packages, and cascade layers so teams can adopt and override predictably.',
},
{
  id: 89,
  title: 'What is critical CSS and why does it matter for performance?',
  difficulty: 'easy',
  topic: 'architecture-performance',
  subtopic: 'performance',
  answer: 'Critical CSS is the minimum set of styles required to render the above-the-fold content of a page. By inlining these styles directly into the `<head>` of the HTML document, the browser can paint meaningful content without waiting for external stylesheets to download and parse. The remaining non-critical CSS is then loaded asynchronously using techniques like `<link rel="preload">` or deferred loading. This technique directly improves First Contentful Paint (FCP) and Largest Contentful Paint (LCP) metrics, which are core web vitals.',
  codeExample: '<head>\n  <style>\n    /* Critical CSS inlined */\n    .header { display: flex; height: 64px; }\n    .hero { min-height: 100vh; }\n  </style>\n  <link rel="preload" href="/styles.css"\n    as="style"\n    onload="this.rel=\'stylesheet\'">\n</head>',
  followUp: 'How would you automate critical CSS extraction in a CI/CD pipeline?',
  keyTakeaway: 'Inlining critical CSS eliminates the render-blocking stylesheet fetch, directly improving FCP and LCP.',
},
{
  id: 90,
  title: 'Explain the browser rendering pipeline and how CSS properties affect each stage.',
  difficulty: 'medium',
  topic: 'architecture-performance',
  subtopic: 'performance',
  answer: 'The rendering pipeline consists of five stages: Style calculation, Layout, Paint, Composite, and Display. Changing geometric properties like `width`, `height`, or `margin` triggers layout (reflow), which forces all subsequent stages to re-run. Changing visual properties like `color` or `background` skips layout but triggers a repaint. Changing only compositor properties like `transform` and `opacity` skips both layout and paint, running only on the compositor thread. Animating with `transform` and `opacity` is dramatically cheaper because it avoids main-thread work entirely, which is why these are called "cheap" animation properties.',
  followUp: 'What is layout thrashing and how do you diagnose it in DevTools?',
  keyTakeaway: 'Animate `transform` and `opacity` to stay on the compositor thread and avoid expensive layout and paint cycles.',
},
{
  id: 91,
  title: 'How do CSS selectors impact rendering performance and what is the browser matching algorithm?',
  difficulty: 'medium',
  topic: 'architecture-performance',
  subtopic: 'performance',
  answer: 'Browsers match CSS selectors right-to-left, starting from the rightmost (key) selector and working back through ancestors. A selector like `.nav ul li a` first matches every `a` element on the page, then walks up each ancestor chain checking for `li`, `ul`, and `.nav`. Deeply nested or overly broad key selectors like `*` or bare element selectors cause the engine to evaluate more elements. In practice, modern browsers optimize selector matching so aggressively that the difference between selectors is negligible for most pages. The real performance concern is having an excessively large stylesheet, as every rule must be evaluated during style recalculation after DOM changes.',
  followUp: 'At what scale does selector performance actually become measurable, and how would you profile it?',
  keyTakeaway: 'Browsers match selectors right-to-left from the key selector; keep key selectors specific and stylesheets lean for fast style recalculation.',
},
{
  id: 92,
  title: 'How does the CSS `contain` property improve rendering performance and what are its containment modes?',
  difficulty: 'hard',
  topic: 'architecture-performance',
  subtopic: 'performance',
  answer: 'The `contain` property tells the browser that an element is independent from the rest of the document in specific ways, enabling rendering optimizations. `contain: layout` ensures the element\'s internal layout does not affect siblings or ancestors, allowing the browser to skip recalculating layout outside the contained subtree. `contain: paint` guarantees nothing will be painted outside the element\'s bounds, enabling the browser to skip painting this subtree when it is offscreen. `contain: size` tells the browser the element\'s size is independent of its children, enabling size calculations without traversing the subtree. `contain: content` is shorthand for `layout paint style`, and `contain: strict` is shorthand for `size layout paint style`. These are particularly impactful for virtualized lists and complex dashboards where DOM changes in one section should never force recalculation elsewhere.',
  codeExample: '/* Contain each card independently */\n.card {\n  contain: content;\n}\n\n/* Strict containment for offscreen items */\n.virtual-list-item {\n  contain: strict;\n  content-visibility: auto;\n}\n\n/* Layout-only containment */\n.sidebar {\n  contain: layout;\n}',
  followUp: 'How does `content-visibility: auto` relate to `contain` and what performance gains does it provide for long pages?',
  keyTakeaway: '`contain` isolates rendering work to subtrees, letting the browser skip layout, paint, and size calculations for unaffected elements.',
},
{
  id: 93,
  title: 'How do `will-change` and layer promotion work, and what are the risks of overusing them?',
  difficulty: 'hard',
  topic: 'architecture-performance',
  subtopic: 'performance',
  answer: 'The `will-change` property hints to the browser that an element will be animated, prompting it to promote the element to its own compositor layer ahead of time. This avoids the cost of layer promotion mid-animation, which can cause a visible jank frame. However, each promoted layer consumes GPU memory — a composited layer stores a bitmap texture, and on mobile devices with limited GPU memory, excessive promotion can trigger performance degradation or even cause the browser to fall back to software rendering. The correct pattern is to apply `will-change` just before an animation starts and remove it after the animation completes. Applying `will-change: transform` to dozens or hundreds of elements simultaneously is an anti-pattern that wastes GPU memory. Use DevTools Layers panel to audit how many composited layers exist and their memory consumption.',
  codeExample: '/* Anti-pattern: permanent promotion */\n.card {\n  will-change: transform; /* DON\'T */\n}\n\n/* Correct: promote on interaction */\n.card:hover {\n  will-change: transform;\n}\n.card.animating {\n  transform: scale(1.05);\n  transition: transform 200ms;\n}\n\n/* Remove after animation via JS:\n   el.addEventListener(\'transitionend\',\n     () => el.style.willChange = \'auto\') */',
  followUp: 'How would you diagnose excessive layer count and GPU memory usage in Chrome DevTools?',
  keyTakeaway: '`will-change` is a temporary optimization hint — apply it before animation and remove it after, never leave it on permanently.',
},
{
  id: 94,
  title: 'Explain how `content-visibility`, `contain-intrinsic-size`, and lazy rendering work together to optimize long pages.',
  difficulty: 'hard',
  topic: 'architecture-performance',
  subtopic: 'performance',
  answer: '`content-visibility: auto` tells the browser to skip rendering (layout, paint, and style) for elements that are offscreen, which can drastically reduce initial rendering time on long pages. When an offscreen element has its rendering skipped, the browser cannot know its height, which would cause layout shifts as the user scrolls. `contain-intrinsic-size` solves this by providing a placeholder size estimate so the scrollbar and page height remain stable. Together they function as native CSS-level virtualization — the browser renders only visible content while reserving space for offscreen content. This combination has been measured to reduce rendering time by 50-90% on content-heavy pages like news feeds or documentation sites. The browser automatically manages rendering as elements enter and leave the viewport during scrolling.',
  codeExample: '.article-section {\n  content-visibility: auto;\n  contain-intrinsic-size: auto 500px;\n}\n\n/* The browser will:\n   1. Skip rendering offscreen sections\n   2. Reserve ~500px height per section\n   3. Render sections as they scroll into view\n   4. Cache rendered size in "auto" mode */\n\n/* For lists with uniform items */\n.list-item {\n  content-visibility: auto;\n  contain-intrinsic-size: 0 80px;\n}',
  followUp: 'What are the edge cases where `content-visibility: auto` can break functionality, such as with anchor links or find-on-page?',
  keyTakeaway: '`content-visibility: auto` with `contain-intrinsic-size` gives you native browser-level virtualization for free.',
},
{
  id: 95,
  title: 'What is CSS specificity and how is it calculated?',
  difficulty: 'easy',
  topic: 'architecture-performance',
  subtopic: 'specificity-management',
  answer: 'Specificity is the algorithm browsers use to decide which CSS rule wins when multiple rules target the same element. It is calculated as a three-part weight: inline styles have the highest specificity, followed by ID selectors, then class/attribute/pseudo-class selectors, and finally element/pseudo-element selectors. The specificity is often represented as a triple (A, B, C) where A counts IDs, B counts classes and attributes, and C counts elements. When two selectors have equal specificity, the one that appears later in source order wins. Understanding specificity is essential for debugging unexpected styles and writing maintainable CSS.',
  codeExample: '/* Specificity: (0, 0, 1) */\np { color: black; }\n\n/* Specificity: (0, 1, 0) */\n.text { color: blue; }\n\n/* Specificity: (0, 1, 1) */\np.text { color: green; }\n\n/* Specificity: (1, 0, 0) */\n#main { color: red; }\n\n/* Specificity: (1, 1, 1) */\n#main p.text { color: purple; }',
  followUp: 'Where does `!important` fit in the specificity hierarchy, and how does it interact with cascade layers?',
  keyTakeaway: 'Specificity is a three-part weight (IDs, classes, elements) that determines which competing CSS rule applies to an element.',
},
{
  id: 96,
  title: 'How do CSS cascade layers (`@layer`) help manage specificity at scale?',
  difficulty: 'medium',
  topic: 'architecture-performance',
  subtopic: 'specificity-management',
  answer: 'Cascade layers, defined with `@layer`, introduce a new level in the cascade above specificity. Rules in a later-declared layer always override rules in an earlier layer, regardless of selector specificity. This means a simple `.button` selector in a higher layer beats an `#app .sidebar .button.primary` selector in a lower layer. You declare the layer order once at the top of your stylesheet, giving you full control over which category of styles wins. This is transformative for design systems because third-party styles, resets, and component styles can be placed in separate layers with a guaranteed override hierarchy. Unlayered styles always beat layered styles, providing an escape hatch for overrides.',
  codeExample: '/* Declare layer order */\n@layer reset, base, components, utilities;\n\n@layer reset {\n  * { margin: 0; box-sizing: border-box; }\n}\n\n@layer components {\n  /* High specificity, but in a lower layer */\n  #sidebar .nav a.active { color: blue; }\n}\n\n@layer utilities {\n  /* Low specificity, but wins because\n     utilities layer comes after components */\n  .text-red { color: red; }\n}',
  followUp: 'How does `!important` behave inside cascade layers, and why is it inverted compared to normal layer order?',
  keyTakeaway: 'Cascade layers override by declared order, making selector specificity irrelevant across layer boundaries.',
},
{
  id: 97,
  title: 'Explain the `:where()` and `:is()` pseudo-classes and their role in specificity management.',
  difficulty: 'medium',
  topic: 'architecture-performance',
  subtopic: 'specificity-management',
  answer: '`:is()` and `:where()` both accept a selector list and match any element that matches at least one of the selectors in the list. The key difference is specificity: `:is()` takes the specificity of its most specific argument, while `:where()` has zero specificity regardless of its arguments. This makes `:where()` invaluable for writing base styles or defaults that are intentionally easy to override. For example, a reset or library can use `:where(.card) { padding: 1rem }` and any single class in user code will override it without specificity battles. Conversely, `:is()` is useful for grouping selectors without losing specificity protection, like `:is(h1, h2, h3) { margin-top: 1em }`.',
  codeExample: '/* :where() — zero specificity, easy to override */\n:where(.card) {\n  padding: 1rem;\n  border: 1px solid gray;\n}\n\n/* Any class overrides :where() */\n.compact { padding: 0.5rem; } /* Wins */\n\n/* :is() — takes highest specificity arg */\n:is(#main, .sidebar) p {\n  /* Specificity includes the #main ID\n     even when matching .sidebar p */\n  line-height: 1.6;\n}\n\n/* Grouping without :is()/:where() */\nh1, h2, h3 { margin-top: 1em; }\n/* Same but with forgiving parsing: */\n:is(h1, h2, h3) { margin-top: 1em; }',
  followUp: 'How would you use `:where()` to build a CSS framework whose styles are trivially overridable by consumers?',
  keyTakeaway: '`:where()` has zero specificity for easily overridable defaults; `:is()` groups selectors while preserving specificity.',
},
{
  id: 98,
  title: 'Design a specificity strategy for a design system that supports theming, component variants, and consumer overrides without `!important`.',
  difficulty: 'hard',
  topic: 'architecture-performance',
  subtopic: 'specificity-management',
  answer: 'The strategy combines cascade layers with zero-specificity base selectors. Define layers in order: `@layer tokens, reset, base, components, variants, utilities, overrides`. Tokens use custom properties on `:root`. Base component styles use `:where(.button)` so they sit at zero specificity within their layer. Variant styles like `.button--primary` use regular class selectors in the variants layer. Utility classes go in the utilities layer for last-resort overrides. Consumer applications get the overrides layer, which wins over all library layers regardless of specificity. Theming is achieved by swapping custom property values in the tokens layer, not by writing higher-specificity selectors. This architecture makes `!important` completely unnecessary and gives consumers a clear, documented override path.',
  codeExample: '@layer tokens, reset, base, components, variants, utilities, overrides;\n\n@layer tokens {\n  :root {\n    --btn-bg: #0066ff;\n    --btn-text: #ffffff;\n  }\n  [data-theme="dark"] {\n    --btn-bg: #3388ff;\n  }\n}\n\n@layer components {\n  :where(.button) {\n    background: var(--btn-bg);\n    color: var(--btn-text);\n    padding: 0.5rem 1rem;\n  }\n}\n\n@layer variants {\n  .button--ghost {\n    background: transparent;\n    border: 1px solid var(--btn-bg);\n  }\n}\n\n@layer overrides {\n  /* Consumer overrides always win */\n}',
  followUp: 'How would you lint and enforce this layer architecture across multiple teams contributing to the design system?',
  keyTakeaway: 'Combine cascade layers with `:where()` selectors and custom property theming to eliminate all specificity conflicts without `!important`.',
},
{
  id: 99,
  title: 'How does the `@scope` rule work and how does it change CSS architecture for nested components?',
  difficulty: 'hard',
  topic: 'architecture-performance',
  subtopic: 'specificity-management',
  answer: '`@scope` defines a scoping root and an optional scoping limit, restricting where styles apply in the DOM tree. Unlike CSS Modules which rewrite class names, `@scope` is a native cascade feature — styles inside a scope rule only match descendants of the scoping root and stop matching at the scoping limit. This is ideal for components that should not leak styles into nested sub-components. The specificity of scoped selectors includes the scoping root, and a new proximity rule means closer scopes win over farther ones when specificity ties. This natively solves the "component styles leaking into slotted child components" problem that has plagued CSS architectures and required naming conventions or tooling to work around.',
  codeExample: '/* Styles apply inside .card but stop at .card nested inside */\n@scope (.card) to (.card) {\n  .title { font-size: 1.25rem; }\n  .body { padding: 1rem; }\n  /* Does NOT match .title inside a nested .card */\n}\n\n/* Tab component scoped to prevent leaking */\n@scope (.tabs) to (.tab-panel) {\n  button { border-bottom: 2px solid blue; }\n  /* Only matches tab buttons,\n     not buttons inside tab panels */\n}\n\n/* Proximity: closer scope wins */\n@scope (.dark) { p { color: white; } }\n@scope (.light) { p { color: black; } }\n/* <div class="dark"><div class="light"><p>\n   gets color: black (closer scope) */\n',
  followUp: 'How does `@scope` proximity compare to cascade layer order when both are in play?',
  keyTakeaway: '`@scope` provides native DOM-subtree style isolation with proximity-based resolution, eliminating the need for naming conventions to prevent style leaking.',
},
{
  id: 100,
  title: 'What is PostCSS and how does it fit into a CSS build pipeline?',
  difficulty: 'easy',
  topic: 'architecture-performance',
  subtopic: 'tooling',
  answer: 'PostCSS is a tool for transforming CSS using JavaScript plugins. Unlike preprocessors like Sass that have a fixed feature set, PostCSS is a platform where each plugin handles one transformation — Autoprefixer adds vendor prefixes, `postcss-preset-env` enables future CSS syntax, and `cssnano` minifies output. PostCSS parses CSS into an AST, plugins transform the AST, and the result is serialized back to CSS. It fits into the build pipeline after CSS authoring and before the final bundle, often integrated into bundlers like Webpack, Vite, or esbuild. Many teams use PostCSS alongside preprocessors, running Sass first for authoring convenience and PostCSS second for optimization and compatibility.',
  followUp: 'How would you write a custom PostCSS plugin to enforce design token usage in a codebase?',
  keyTakeaway: 'PostCSS is a plugin-based CSS transformer that handles prefixing, future syntax, and optimization in the build pipeline.',
},
{
  id: 101,
  title: 'Compare CSS preprocessors (Sass, Less) with modern native CSS features — which preprocessor features are now redundant?',
  difficulty: 'medium',
  topic: 'architecture-performance',
  subtopic: 'tooling',
  answer: 'Native CSS now covers many features that previously required preprocessors. CSS custom properties replace Sass variables with the added benefit of runtime dynamism and cascade inheritance. Native CSS nesting (now supported in all major browsers) replaces Sass nesting. The `:is()` and `:where()` pseudo-classes replace many `@extend` use cases. `color-mix()` replaces Sass color functions for lightening and darkening. `@layer` replaces manual specificity ordering that preprocessors attempted through file concatenation order. Preprocessors remain useful for build-time loops (`@each`, `@for`), mixins with complex logic, and conditional compilation. The trend is toward using native CSS features with PostCSS for polyfilling, reducing the need for full preprocessors.',
  codeExample: '/* Sass variable — static, build-time only */\n$primary: #0066ff;\n.btn { color: $primary; }\n\n/* CSS custom property — dynamic, inheritable */\n:root { --primary: #0066ff; }\n.btn { color: var(--primary); }\n[data-theme="dark"] { --primary: #3388ff; }\n\n/* Native nesting */\n.card {\n  padding: 1rem;\n  & .title { font-size: 1.25rem; }\n  &:hover { box-shadow: 0 2px 8px #0002; }\n}\n\n/* color-mix replaces darken()/lighten() */\n.btn:hover {\n  background: color-mix(in srgb, var(--primary), black 20%);\n}',
  followUp: 'What is the migration strategy for moving a large Sass codebase to native CSS features incrementally?',
  keyTakeaway: 'Native CSS custom properties, nesting, `color-mix()`, and `@layer` have replaced most preprocessor features — preprocessors remain useful mainly for build-time logic.',
},
{
  id: 102,
  title: 'How do you configure Stylelint or a CSS linter to enforce architectural rules like token usage and selector conventions?',
  difficulty: 'medium',
  topic: 'architecture-performance',
  subtopic: 'tooling',
  answer: 'Stylelint is a configurable CSS linter that can enforce architectural rules through built-in and custom rules. The `declaration-property-value-allowed-list` rule restricts which values properties can use, enforcing design token usage by only allowing `var(--color-*)` for color properties. `selector-class-pattern` enforces naming conventions like BEM by requiring class names to match a regex. `max-nesting-depth` prevents excessive nesting that leads to specificity bloat. Custom plugins can enforce team-specific rules like requiring `@layer` declarations or forbidding certain at-rules. Integrating Stylelint into CI and editor plugins creates a tight feedback loop where violations are caught before code review.',
  codeExample: '/* .stylelintrc.json */\n{\n  "rules": {\n    "selector-class-pattern": [\n      "^[a-z][a-zA-Z0-9]+(__[a-z][a-zA-Z0-9]+)?(--[a-z][a-zA-Z0-9]+)?$",\n      { "message": "Class must follow BEM convention" }\n    ],\n    "declaration-property-value-allowed-list": {\n      "color": ["/^var\\\\(--color-/"],\n      "background-color": ["/^var\\\\(--color-/", "transparent"]\n    },\n    "max-nesting-depth": 3,\n    "no-descending-specificity": true\n  }\n}',
  followUp: 'How would you write a custom Stylelint rule that flags any hardcoded pixel value not in the design token scale?',
  keyTakeaway: 'Stylelint enforces CSS architecture rules like token usage, naming conventions, and nesting depth through configurable and custom rules.',
},
{
  id: 103,
  title: 'How would you set up CSS bundle analysis, tree-shaking, and dead code elimination for a production application?',
  difficulty: 'hard',
  topic: 'architecture-performance',
  subtopic: 'tooling',
  answer: 'Start by analyzing the CSS bundle with tools like `css-stats` or the Coverage tab in Chrome DevTools to identify unused rules. For utility frameworks like Tailwind, configure the content paths so PurgeCSS (or Tailwind\'s built-in purge) removes unused utility classes at build time. For CSS Modules, unused exports are automatically excluded when the importing component is tree-shaken. For global stylesheets, tools like `PurgeCSS` or `UnCSS` compare selectors against rendered HTML to remove dead rules. Configure `cssnano` for minification, `postcss-combine-duplicated-selectors` to merge repeated selectors, and enable CSS code splitting in your bundler so each route loads only its required styles. Monitor the CSS bundle size in CI using `bundlesize` or `size-limit` to prevent regressions.',
  followUp: 'How do you handle dynamic class names that PurgeCSS might incorrectly strip as unused?',
  keyTakeaway: 'Combine DevTools Coverage analysis, PurgeCSS for unused removal, CSS Modules for automatic scoping, and CI size budgets for production-grade CSS optimization.',
},
{
  id: 104,
  title: 'How do `prefers-reduced-motion` and `prefers-color-scheme` affect CSS architecture, and how should a design system handle these preferences?',
  difficulty: 'hard',
  topic: 'architecture-performance',
  subtopic: 'accessibility',
  answer: '`prefers-reduced-motion` and `prefers-color-scheme` are user preference media queries that a robust CSS architecture must treat as first-class concerns, not afterthoughts. For motion, the best practice is to author all animations and transitions behind a `prefers-reduced-motion: no-preference` query, so reduced-motion users get no animation by default. For color scheme, the architecture should define all colors as custom properties and swap their values inside a `prefers-color-scheme: dark` media query or a `[data-theme]` attribute selector. A design system should provide both media query support for automatic detection and a manual toggle mechanism so users can override the OS preference. Motion tokens should include a reduced variant: `--transition-fast` becomes `0ms` or a crossfade fallback when motion is reduced.',
  codeExample: '/* Motion: default to no animation */\n.card {\n  transition: none;\n}\n\n@media (prefers-reduced-motion: no-preference) {\n  .card {\n    transition: transform 200ms ease;\n  }\n}\n\n/* Color scheme with token swap */\n:root {\n  --bg-primary: #ffffff;\n  --text-primary: #111111;\n}\n\n@media (prefers-color-scheme: dark) {\n  :root {\n    --bg-primary: #0a0a0a;\n    --text-primary: #eeeeee;\n  }\n}\n\n/* Manual override via attribute */\n[data-theme="dark"] {\n  --bg-primary: #0a0a0a;\n  --text-primary: #eeeeee;\n}',
  followUp: 'How do you test reduced-motion and dark-mode styles in automated tests and CI pipelines?',
  keyTakeaway: 'Author animations opt-in behind `prefers-reduced-motion: no-preference` and use custom property swaps for color schemes to respect user preferences architecturally.',
},
{
  id: 105,
  title: 'How do you architect CSS to meet WCAG contrast, focus visibility, and spacing requirements without sacrificing design flexibility?',
  difficulty: 'hard',
  topic: 'architecture-performance',
  subtopic: 'accessibility',
  answer: 'Start by encoding WCAG-compliant values directly into the design token system — every color pairing in the token set should pass a 4.5:1 contrast ratio check for normal text and 3:1 for large text. Focus styles should use a dedicated token like `--focus-ring` applied globally via `:focus-visible`, which only shows focus rings for keyboard users, not mouse users. Never use `outline: none` without providing an equivalent or better custom focus indicator. Spacing tokens should enforce minimum touch target sizes of 44x44 CSS pixels per WCAG 2.5.8. Build automated accessibility checks into the token pipeline — run contrast ratio validation when tokens are generated, and use `axe-core` in CI to catch violations. This way, accessibility is a property of the system, not a responsibility of individual developers.',
  codeExample: '/* Focus ring token — globally applied */\n:focus-visible {\n  outline: 2px solid var(--color-focus-ring);\n  outline-offset: 2px;\n}\n\n/* Remove default focus for mouse users */\n:focus:not(:focus-visible) {\n  outline: none;\n}\n\n/* Minimum touch target */\n.interactive {\n  min-width: 44px;\n  min-height: 44px;\n  /* If visual size must be smaller,\n     use padding to expand hit area */\n  position: relative;\n}\n.interactive::before {\n  content: "";\n  position: absolute;\n  inset: -8px; /* Expand clickable area */\n}\n\n/* Forced high-contrast mode support */\n@media (forced-colors: active) {\n  .button {\n    border: 1px solid ButtonText;\n  }\n}',
  followUp: 'How would you handle `forced-colors` mode (Windows High Contrast) in your design system, and what CSS properties does it override?',
  keyTakeaway: 'Encode WCAG compliance into tokens and global styles so accessibility is a system property, not a per-component burden.',
},
]

export function filterCSSQuestions(
  questions: CSSInterviewQuestion[],
  difficulty: 'all' | 'easy' | 'medium' | 'hard',
  topic: 'all' | CSSInterviewTopic,
): CSSInterviewQuestion[] {
  return questions.filter((q) => {
    if (difficulty !== 'all' && q.difficulty !== difficulty) return false
    if (topic !== 'all' && q.topic !== topic) return false
    return true
  })
}
