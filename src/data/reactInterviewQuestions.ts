export type ReactInterviewTopic =
  | 'core-rendering'
  | 'hooks-state'
  | 'patterns-architecture'
  | 'performance-advanced'

export interface ReactInterviewQuestion {
  id: number
  title: string
  difficulty: 'easy' | 'medium' | 'hard'
  topic: ReactInterviewTopic
  subtopic: string
  answer: string
  codeExample?: string
  followUp: string
  keyTakeaway: string
}

export interface ReactTopicConfig {
  id: ReactInterviewTopic
  label: string
  description: string
}

export const reactTopics: ReactTopicConfig[] = [
  {
    id: 'core-rendering',
    label: 'Core & Rendering',
    description: 'JSX, virtual DOM, reconciliation, keys, refs, portals, error boundaries',
  },
  {
    id: 'hooks-state',
    label: 'Hooks & State',
    description: 'useState, useEffect, useReducer, useContext, custom hooks, rules of hooks',
  },
  {
    id: 'patterns-architecture',
    label: 'Patterns & Architecture',
    description: 'Composition, HOCs, render props, compound components, Server Components',
  },
  {
    id: 'performance-advanced',
    label: 'Performance & Advanced',
    description: 'Memoization, concurrent features, React 19 APIs, profiling, testing',
  },
]

export const reactTopicMap: Record<ReactInterviewTopic, ReactTopicConfig> =
  Object.fromEntries(reactTopics.map((t) => [t.id, t])) as Record<ReactInterviewTopic, ReactTopicConfig>

export const reactInterviewQuestions: ReactInterviewQuestion[] = [
{
  id: 1,
  title: 'What is JSX and how does it get transformed into JavaScript?',
  difficulty: 'easy',
  topic: 'core-rendering',
  subtopic: 'jsx',
  answer: 'JSX is a syntax extension that lets you write HTML-like markup inside JavaScript. It is not valid JavaScript on its own — a compiler like Babel or SWC transforms each JSX element into a `React.createElement()` call (or the newer `jsx()` runtime function in React 17+). For example, `<h1>Hello</h1>` becomes `React.createElement(\'h1\', null, \'Hello\')`. This means JSX is purely syntactic sugar that produces plain JavaScript objects describing the UI tree.',
  codeExample: '// JSX syntax\nconst element = <h1 className="title">Hello</h1>;\n\n// Compiles to (classic runtime)\nconst element = React.createElement(\n  \'h1\',\n  { className: \'title\' },\n  \'Hello\'\n);\n\n// With automatic runtime (React 17+)\nimport { jsx as _jsx } from \'react/jsx-runtime\';\nconst element = _jsx(\'h1\', { className: \'title\', children: \'Hello\' });',
  followUp: 'What is the difference between the classic and automatic JSX transform introduced in React 17?',
  keyTakeaway: 'JSX is syntactic sugar that compilers transform into `React.createElement()` or `jsx()` function calls producing plain objects.',
},
{
  id: 2,
  title: 'What is the virtual DOM and why does React use it?',
  difficulty: 'easy',
  topic: 'core-rendering',
  subtopic: 'virtual-dom',
  answer: 'The virtual DOM is a lightweight, in-memory representation of the actual DOM tree. When state changes, React creates a new virtual DOM tree, diffs it against the previous one, and computes the minimal set of real DOM mutations needed. This approach is faster than naively re-rendering the entire DOM because JavaScript object comparison is cheap, while DOM manipulation is expensive. The virtual DOM also provides a declarative programming model — you describe what the UI should look like, and React figures out how to get there.',
  codeExample: '// You describe the desired state declaratively\nfunction Counter({ count }: { count: number }) {\n  // React builds a virtual DOM node from this JSX\n  // and diffs it against the previous render\n  return (\n    <div>\n      <p>Count: {count}</p>\n      {/* Only the text node updates when count changes */}\n    </div>\n  );\n}',
  followUp: 'If the virtual DOM still ultimately updates the real DOM, how is it actually faster than direct manipulation?',
  keyTakeaway: 'The virtual DOM lets React batch and minimize expensive real DOM operations by diffing lightweight JavaScript objects first.',
},
{
  id: 3,
  title: 'How do you embed JavaScript expressions inside JSX?',
  difficulty: 'easy',
  topic: 'core-rendering',
  subtopic: 'jsx',
  answer: 'You embed JavaScript expressions inside JSX using curly braces `{}`. Anything that is a valid JavaScript expression — variables, function calls, ternary operators, arithmetic — can go inside the braces. Statements like `if`, `for`, or variable declarations are not allowed directly inside JSX because JSX curly braces expect an expression that evaluates to a value. For conditional rendering, you use ternary expressions or logical `&&` operators instead.',
  codeExample: 'interface UserProps {\n  name: string;\n  age: number;\n  isAdmin: boolean;\n}\n\nfunction UserCard({ name, age, isAdmin }: UserProps) {\n  return (\n    <div>\n      {/* Variable expression */}\n      <h2>{name}</h2>\n      {/* Arithmetic expression */}\n      <p>Born around {new Date().getFullYear() - age}</p>\n      {/* Ternary for conditional rendering */}\n      {isAdmin ? <span>Admin</span> : <span>User</span>}\n      {/* Logical AND for conditional rendering */}\n      {age >= 18 && <p>Eligible to vote</p>}\n    </div>\n  );\n}',
  followUp: 'Why can\'t you use an `if` statement directly inside JSX curly braces?',
  keyTakeaway: 'JSX curly braces accept any JavaScript expression, but not statements — use ternaries or `&&` for conditional rendering.',
},
{
  id: 4,
  title: 'What are React keys and why are they important in lists?',
  difficulty: 'easy',
  topic: 'core-rendering',
  subtopic: 'keys',
  answer: 'Keys are special string attributes you provide when rendering lists of elements. They help React identify which items have changed, been added, or been removed during reconciliation. Without stable keys, React falls back to comparing elements by index, which can cause incorrect state preservation, unnecessary re-renders, and visual bugs when the list order changes. Keys must be unique among siblings and should be stable identifiers like database IDs, not array indices.',
  codeExample: 'interface Todo {\n  id: string;\n  text: string;\n}\n\nfunction TodoList({ todos }: { todos: Todo[] }) {\n  return (\n    <ul>\n      {todos.map((todo) => (\n        // Use a stable, unique identifier as key\n        <li key={todo.id}>{todo.text}</li>\n      ))}\n    </ul>\n  );\n}\n\n// BAD: Using index as key causes bugs when items reorder\n// todos.map((todo, index) => <li key={index}>{todo.text}</li>)',
  followUp: 'What specific bugs can occur when you use array indices as keys in a list that gets reordered?',
  keyTakeaway: 'Keys let React track list items across renders — always use stable unique IDs, never array indices for dynamic lists.',
},
{
  id: 5,
  title: 'What is `React.StrictMode` and what does it do?',
  difficulty: 'easy',
  topic: 'core-rendering',
  subtopic: 'strict-mode',
  answer: '`React.StrictMode` is a development-only wrapper component that activates additional checks and warnings for its descendants. It intentionally double-invokes functions like component bodies, `useState` initializers, and `useEffect` setup/cleanup to help you detect impure renders and side effects. It also warns about deprecated APIs such as legacy string refs and `findDOMNode`. Strict Mode has zero impact on the production build — all its checks are stripped out.',
  codeExample: 'import { StrictMode } from \'react\';\nimport { createRoot } from \'react-dom/client\';\nimport { App } from \'./App\';\n\n// Wrap your app in StrictMode for development checks\ncreateRoot(document.getElementById(\'root\')!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n\n// In development, component bodies run twice\n// to expose impure logic that depends on single execution',
  followUp: 'Why does React 18 StrictMode unmount and remount components in development?',
  keyTakeaway: '`StrictMode` double-invokes renders and effects in development to surface impure code and deprecated API usage.',
},
{
  id: 6,
  title: 'What are refs in React and when should you use them?',
  difficulty: 'easy',
  topic: 'core-rendering',
  subtopic: 'refs',
  answer: 'Refs provide a way to access DOM nodes or persist mutable values across renders without triggering a re-render. You create a ref with `useRef()`, which returns an object with a `.current` property that persists for the lifetime of the component. Common use cases include focusing an input, measuring element dimensions, storing interval IDs, or integrating with third-party DOM libraries. Unlike state, mutating a ref does not cause the component to re-render.',
  codeExample: 'import { useRef, useEffect } from \'react\';\n\nfunction SearchInput() {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    // Focus the input on mount\n    inputRef.current?.focus();\n  }, []);\n\n  return <input ref={inputRef} type="text" placeholder="Search..." />;\n}\n\n// Storing a mutable value without re-rendering\nfunction Timer() {\n  const intervalRef = useRef<number | null>(null);\n\n  const start = () => {\n    intervalRef.current = window.setInterval(() => {\n      console.log(\'tick\');\n    }, 1000);\n  };\n\n  const stop = () => {\n    if (intervalRef.current) window.clearInterval(intervalRef.current);\n  };\n\n  return <div><button onClick={start}>Start</button><button onClick={stop}>Stop</button></div>;\n}',
  followUp: 'What is the difference between `useRef` and `useState` for tracking values across renders?',
  keyTakeaway: 'Refs access DOM nodes or store mutable values across renders without causing re-renders, created via `useRef()`.',
},
{
  id: 7,
  title: 'What are React Fragments and why would you use them?',
  difficulty: 'easy',
  topic: 'core-rendering',
  subtopic: 'fragments',
  answer: 'React Fragments let you group multiple child elements without adding an extra DOM node. Every React component must return a single root element, so before Fragments you had to wrap siblings in a `<div>`, which could break CSS layouts or add semantically meaningless markup. You can use the explicit `<Fragment>` import (required when you need to pass a `key`) or the shorthand `<>...</>` syntax. Fragments produce no output in the DOM.',
  codeExample: 'import { Fragment } from \'react\';\n\n// Shorthand syntax — most common\nfunction Greeting() {\n  return (\n    <>\n      <h1>Hello</h1>\n      <p>Welcome back</p>\n    </>\n  );\n}\n\n// Explicit Fragment with key — required in lists\ninterface Item { id: string; term: string; definition: string; }\n\nfunction Glossary({ items }: { items: Item[] }) {\n  return (\n    <dl>\n      {items.map((item) => (\n        <Fragment key={item.id}>\n          <dt>{item.term}</dt>\n          <dd>{item.definition}</dd>\n        </Fragment>\n      ))}\n    </dl>\n  );\n}',
  followUp: 'When would you choose the explicit `<Fragment>` syntax over the `<>` shorthand?',
  keyTakeaway: 'Fragments group multiple elements without adding extra DOM nodes, keeping markup clean and CSS layouts intact.',
},
{
  id: 8,
  title: 'How does React\'s synthetic event system work?',
  difficulty: 'easy',
  topic: 'core-rendering',
  subtopic: 'events',
  answer: 'React wraps native browser events in `SyntheticEvent` objects that provide a consistent, cross-browser interface. As of React 17, React attaches a single event listener at the root DOM container (not `document`) using event delegation, meaning individual elements do not have their own listeners. Synthetic events have the same interface as native events (`stopPropagation`, `preventDefault`) and are pooled for performance in React 16, though event pooling was removed in React 17+. You can access the underlying native event via `event.nativeEvent`.',
  codeExample: 'import { MouseEvent, ChangeEvent } from \'react\';\n\nfunction Form() {\n  const handleClick = (e: MouseEvent<HTMLButtonElement>) => {\n    e.preventDefault();\n    console.log(\'Button clicked\');\n    // Access native event if needed\n    console.log(e.nativeEvent);\n  };\n\n  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {\n    console.log(e.target.value);\n  };\n\n  return (\n    <form>\n      <input onChange={handleChange} />\n      <button onClick={handleClick}>Submit</button>\n    </form>\n  );\n}',
  followUp: 'Why did React 17 change event delegation from `document` to the root container?',
  keyTakeaway: 'React uses synthetic events for cross-browser consistency and event delegation at the root container for performance.',
},
{
  id: 9,
  title: 'How does React\'s reconciliation algorithm decide what to update in the DOM?',
  difficulty: 'medium',
  topic: 'core-rendering',
  subtopic: 'reconciliation',
  answer: 'React\'s reconciliation algorithm compares the new virtual DOM tree with the previous one using two key heuristics to achieve O(n) complexity instead of the O(n^3) generic tree diff. First, elements of different types produce entirely different subtrees — React tears down the old tree and builds a new one. Second, the `key` prop lets React match children across renders, identifying moves, insertions, and deletions. When elements have the same type, React keeps the DOM node and only updates changed attributes, then recurses into children.',
  codeExample: '// Same type — React updates props, keeps the DOM node\n// Before: <button className="blue">OK</button>\n// After:  <button className="red">OK</button>\n// React only updates className on the existing button\n\n// Different type — React destroys and rebuilds\n// Before: <div><Counter /></div>\n// After:  <section><Counter /></section>\n// Counter state is lost because the parent type changed\n\n// Keys help React track items\nfunction List({ items }: { items: { id: string; name: string }[] }) {\n  return (\n    <ul>\n      {items.map((item) => (\n        // React uses key to match old and new items\n        <li key={item.id}>{item.name}</li>\n      ))}\n    </ul>\n  );\n}',
  followUp: 'What happens to component state when its parent element type changes during reconciliation?',
  keyTakeaway: 'Reconciliation uses O(n) heuristics: different element types rebuild subtrees, and keys track list items across renders.',
},
{
  id: 10,
  title: 'What are React Portals and when should you use them?',
  difficulty: 'medium',
  topic: 'core-rendering',
  subtopic: 'portals',
  answer: 'Portals let you render children into a DOM node that exists outside the parent component\'s DOM hierarchy using `createPortal(children, domNode)`. This is essential for UI elements like modals, tooltips, and dropdown menus that need to visually break out of containers with `overflow: hidden`, `z-index` stacking contexts, or fixed positioning. Despite rendering into a different DOM location, portal children still behave as part of the React tree — they can access context, and events bubble up through the React component hierarchy, not the DOM hierarchy.',
  codeExample: 'import { createPortal } from \'react-dom\';\nimport { ReactNode } from \'react\';\n\ninterface ModalProps {\n  children: ReactNode;\n  isOpen: boolean;\n}\n\nfunction Modal({ children, isOpen }: ModalProps) {\n  if (!isOpen) return null;\n\n  // Renders into document.body, not the parent div\n  return createPortal(\n    <div className="modal-overlay">\n      <div className="modal-content">\n        {children}\n      </div>\n    </div>,\n    document.body\n  );\n}\n\n// Usage — Modal escapes any overflow:hidden ancestors\nfunction App() {\n  return (\n    <div style={{ overflow: \'hidden\' }}>\n      <Modal isOpen={true}>\n        <p>This renders outside the overflow container</p>\n      </Modal>\n    </div>\n  );\n}',
  followUp: 'If a portal renders outside the parent DOM node, how do React events still bubble through the component tree?',
  keyTakeaway: 'Portals render children into a different DOM node while preserving React tree behavior including event bubbling and context.',
},
{
  id: 11,
  title: 'What are error boundaries and how do you implement one in React?',
  difficulty: 'medium',
  topic: 'core-rendering',
  subtopic: 'error-boundaries',
  answer: 'Error boundaries are React components that catch JavaScript errors in their child component tree during rendering, lifecycle methods, and constructors, then display a fallback UI instead of crashing the whole app. They are implemented as class components using `static getDerivedStateFromError()` to update state and `componentDidCatch()` for logging. Error boundaries do not catch errors in event handlers, asynchronous code, server-side rendering, or errors thrown in the boundary itself.',
  codeExample: 'import { Component, ReactNode, ErrorInfo } from \'react\';\n\ninterface Props { children: ReactNode; fallback: ReactNode; }\ninterface State { hasError: boolean; }\n\nclass ErrorBoundary extends Component<Props, State> {\n  state: State = { hasError: false };\n\n  static getDerivedStateFromError(_error: Error): State {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, info: ErrorInfo): void {\n    // Log to an error reporting service\n    console.error(\'Caught error:\', error, info.componentStack);\n  }\n\n  render() {\n    if (this.state.hasError) return this.props.fallback;\n    return this.props.children;\n  }\n}\n\n// Usage\n// <ErrorBoundary fallback={<p>Something went wrong</p>}>\n//   <MyComponent />\n// </ErrorBoundary>',
  followUp: 'Why can\'t error boundaries be implemented as functional components?',
  keyTakeaway: 'Error boundaries are class components that catch render errors in children and display fallback UI using `getDerivedStateFromError`.',
},
{
  id: 12,
  title: 'How does `React.lazy` work with `Suspense` for code splitting?',
  difficulty: 'medium',
  topic: 'core-rendering',
  subtopic: 'suspense',
  answer: '`React.lazy` takes a function that returns a dynamic `import()` and creates a component that loads its code on demand. When the lazy component is first rendered, it triggers the import and "suspends" — React walks up the tree to find the nearest `<Suspense>` boundary and renders its `fallback` prop while waiting. Once the module loads, React re-renders with the actual component. This enables route-level and component-level code splitting, reducing the initial bundle size.',
  codeExample: 'import { lazy, Suspense } from \'react\';\n\n// Lazy-load a heavy component\nconst HeavyChart = lazy(() => import(\'./HeavyChart\'));\n\nfunction Dashboard() {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      {/* Suspense shows fallback while HeavyChart loads */}\n      <Suspense fallback={<div>Loading chart...</div>}>\n        <HeavyChart />\n      </Suspense>\n    </div>\n  );\n}\n\n// Route-level code splitting\nconst Settings = lazy(() => import(\'./pages/Settings\'));\nconst Profile = lazy(() => import(\'./pages/Profile\'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading page...</div>}>\n      {/* Router switches between lazy routes */}\n    </Suspense>\n  );\n}',
  followUp: 'What happens if the lazy-loaded module fails to load — how do you handle that error?',
  keyTakeaway: '`React.lazy` enables code splitting by loading components on demand, with `Suspense` showing a fallback during the load.',
},
{
  id: 13,
  title: 'What is the difference between controlled and uncontrolled components?',
  difficulty: 'medium',
  topic: 'core-rendering',
  subtopic: 'controlled-components',
  answer: 'In a controlled component, React state is the single source of truth for the input value — you set `value` and provide an `onChange` handler to update state on every keystroke. In an uncontrolled component, the DOM itself holds the value and you read it via a ref when needed. Controlled components give you full control for validation, formatting, and conditional disabling, but require more code. Uncontrolled components are simpler for basic forms where you only need the value on submit.',
  codeExample: 'import { useState, useRef, FormEvent } from \'react\';\n\n// Controlled — React owns the value\nfunction ControlledInput() {\n  const [value, setValue] = useState(\'\');\n  return (\n    <input\n      value={value}\n      onChange={(e) => setValue(e.target.value.toUpperCase())}\n    />\n  );\n}\n\n// Uncontrolled — DOM owns the value\nfunction UncontrolledInput() {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const handleSubmit = (e: FormEvent) => {\n    e.preventDefault();\n    // Read value only when needed\n    console.log(inputRef.current?.value);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input ref={inputRef} defaultValue="" />\n      <button type="submit">Submit</button>\n    </form>\n  );\n}',
  followUp: 'What happens if you provide a `value` prop without an `onChange` handler on an input?',
  keyTakeaway: 'Controlled components use React state as the source of truth; uncontrolled components let the DOM manage the value via refs.',
},
{
  id: 14,
  title: 'What is `forwardRef` and when do you need it?',
  difficulty: 'medium',
  topic: 'core-rendering',
  subtopic: 'refs',
  answer: '`forwardRef` is a higher-order function that lets a parent component pass a ref through a child component to access a specific DOM element inside it. By default, refs cannot be passed as a regular prop because React handles `ref` specially. `forwardRef` wraps the component and provides the ref as a second argument alongside props. This is essential for reusable UI primitives (buttons, inputs) where consumers need direct DOM access for focus management, measurements, or animations. In React 19, `ref` is available as a regular prop, making `forwardRef` unnecessary.',
  codeExample: 'import { forwardRef, useRef } from \'react\';\n\ninterface FancyInputProps {\n  label: string;\n  placeholder?: string;\n}\n\n// forwardRef passes the ref to the inner input\nconst FancyInput = forwardRef<HTMLInputElement, FancyInputProps>(\n  ({ label, placeholder }, ref) => (\n    <label>\n      {label}\n      <input ref={ref} placeholder={placeholder} />\n    </label>\n  )\n);\nFancyInput.displayName = \'FancyInput\';\n\n// Parent can now focus the input directly\nfunction Form() {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  return (\n    <div>\n      <FancyInput ref={inputRef} label="Name" />\n      <button onClick={() => inputRef.current?.focus()}>\n        Focus Input\n      </button>\n    </div>\n  );\n}',
  followUp: 'How does `useImperativeHandle` let you customize what a forwarded ref exposes?',
  keyTakeaway: '`forwardRef` lets parent components pass refs through children to access inner DOM nodes, essential for reusable UI primitives.',
},
{
  id: 15,
  title: 'How does React\'s event delegation differ from native DOM event delegation?',
  difficulty: 'medium',
  topic: 'core-rendering',
  subtopic: 'events',
  answer: 'In native DOM event delegation, you manually attach a listener to a parent element and use `event.target` to identify the child that triggered it. React automates this — as of React 17, it attaches a single set of listeners to the root container (the element you pass to `createRoot`), not to `document`. React then uses its fiber tree to dispatch synthetic events through the React component hierarchy. This matters for micro-frontends and multiple React roots on the same page, because events no longer leak between roots as they did when listeners were on `document`.',
  codeExample: '// React automatically delegates — you just write handlers\nfunction ItemList({ items }: { items: string[] }) {\n  // One handler, delegated at the root by React\n  const handleClick = (item: string) => {\n    console.log(\'Clicked:\', item);\n  };\n\n  return (\n    <ul>\n      {items.map((item) => (\n        <li key={item} onClick={() => handleClick(item)}>\n          {item}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Native equivalent (manual delegation)\n// document.querySelector(\'ul\')?.addEventListener(\'click\', (e) => {\n//   const target = e.target as HTMLElement;\n//   if (target.tagName === \'LI\') console.log(target.textContent);\n// });',
  followUp: 'What problems can arise when mixing React synthetic events with native `addEventListener` on the same elements?',
  keyTakeaway: 'React delegates all events to the root container automatically, unlike manual native delegation, enabling safe coexistence of multiple React roots.',
},
{
  id: 16,
  title: 'How does React batch state updates and what changed in React 18?',
  difficulty: 'medium',
  topic: 'core-rendering',
  subtopic: 'reconciliation',
  answer: 'Batching means React groups multiple state updates into a single re-render for performance. In React 17, batching only happened inside React event handlers — updates inside `setTimeout`, `fetch` callbacks, or native event listeners triggered separate re-renders for each `setState` call. React 18 introduced automatic batching, which batches all state updates regardless of where they originate — event handlers, promises, timeouts, and native event listeners all get batched. If you need to force an immediate re-render, you can use `flushSync`.',
  codeExample: 'import { useState } from \'react\';\nimport { flushSync } from \'react-dom\';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n\n  const handleClick = () => {\n    // React 18: both updates batched into ONE re-render\n    setCount((c) => c + 1);\n    setFlag((f) => !f);\n  };\n\n  const handleAsync = () => {\n    setTimeout(() => {\n      // React 18: ALSO batched (was NOT batched in React 17)\n      setCount((c) => c + 1);\n      setFlag((f) => !f);\n    }, 100);\n  };\n\n  const handleFlush = () => {\n    // Force immediate re-render — opt out of batching\n    flushSync(() => setCount((c) => c + 1));\n    // DOM is updated here\n    flushSync(() => setFlag((f) => !f));\n  };\n\n  return <div>{count} {String(flag)}</div>;\n}',
  followUp: 'When would you actually need to use `flushSync` to opt out of automatic batching?',
  keyTakeaway: 'React 18 automatically batches all state updates into single re-renders, regardless of where they originate.',
},
{
  id: 17,
  title: 'How does event bubbling work with React Portals?',
  difficulty: 'medium',
  topic: 'core-rendering',
  subtopic: 'portals',
  answer: 'Even though a portal renders its children into a different DOM node, events bubble through the React component tree, not the DOM tree. This means a click inside a portal will bubble up to the React parent that rendered the portal, even if the portal DOM node is completely outside that parent in the actual DOM. This behavior is intentional — it lets parent components handle events from portalled children without knowing they are portals, preserving React\'s compositional model.',
  codeExample: 'import { createPortal } from \'react-dom\';\nimport { MouseEvent } from \'react\';\n\nfunction Parent() {\n  // This handler catches clicks from the portal child\n  const handleClick = (e: MouseEvent) => {\n    console.log(\'Parent caught click from portal!\');\n  };\n\n  return (\n    <div onClick={handleClick}>\n      <h1>Parent Component</h1>\n      {/* Child renders into document.body, but click bubbles here */}\n      {createPortal(\n        <button>Click Me (in portal)</button>,\n        document.body\n      )}\n    </div>\n  );\n}\n\n// Clicking the button logs "Parent caught click from portal!"\n// because React event bubbling follows the component tree',
  followUp: 'How would you stop a portal event from bubbling to the React parent without affecting the DOM event?',
  keyTakeaway: 'Portal events bubble through the React component tree, not the DOM tree, so React parents can catch events from portalled children.',
},
{
  id: 18,
  title: 'Why does StrictMode in React 18 simulate unmounting and remounting components?',
  difficulty: 'medium',
  topic: 'core-rendering',
  subtopic: 'strict-mode',
  answer: 'React 18 StrictMode simulates unmounting and remounting every component on initial mount to help prepare for a future feature where React can preserve and reuse component state (like when navigating back to a previous screen). By running effects, cleaning them up, and running them again, it exposes bugs where cleanup functions are missing or incomplete. If your component works correctly after this double mount cycle, it will work correctly with future features like offscreen rendering and state preservation.',
  codeExample: 'import { useEffect, useState } from \'react\';\n\nfunction ChatRoom({ roomId }: { roomId: string }) {\n  const [messages, setMessages] = useState<string[]>([]);\n\n  useEffect(() => {\n    const connection = createConnection(roomId);\n    connection.connect();\n\n    // StrictMode calls this cleanup, then re-runs the effect\n    // If cleanup is missing, you get duplicate connections\n    return () => {\n      connection.disconnect();\n    };\n  }, [roomId]);\n\n  // In development with StrictMode:\n  // 1. Mount: connect to room\n  // 2. Unmount (simulated): disconnect\n  // 3. Remount (simulated): connect again\n  // This verifies cleanup works correctly\n\n  return <div>{messages.length} messages</div>;\n}\n\nfunction createConnection(id: string) {\n  return { connect() {}, disconnect() {} };\n}',
  followUp: 'What is the offscreen API that motivated this StrictMode behavior?',
  keyTakeaway: 'StrictMode double-mounts components to verify effect cleanup works, preparing code for future state preservation features.',
},
{
  id: 19,
  title: 'What is React Fiber and how does it improve rendering?',
  difficulty: 'hard',
  topic: 'core-rendering',
  subtopic: 'virtual-dom',
  answer: 'React Fiber is the reimplemented reconciliation engine introduced in React 16 that enables incremental rendering. The old stack reconciler processed the entire tree synchronously, blocking the main thread. Fiber breaks rendering work into small units called "fibers" (lightweight objects representing each component) that can be paused, resumed, and prioritized. Each fiber node tracks its component type, pending props, state, effect list, and pointers to its parent, child, and sibling fibers, forming a linked-list tree. This architecture enables concurrent features like `useTransition`, time-slicing, and Suspense.',
  codeExample: '// Fiber enables concurrent rendering — you can mark updates\n// as non-urgent so React can interrupt them for higher-priority work\nimport { useState, useTransition } from \'react\';\n\nfunction SearchResults({ query }: { query: string }) {\n  return <div>Results for: {query}</div>;\n}\n\nfunction Search() {\n  const [input, setInput] = useState(\'\');\n  const [query, setQuery] = useState(\'\');\n  const [isPending, startTransition] = useTransition();\n\n  const handleChange = (value: string) => {\n    // High priority — update input immediately\n    setInput(value);\n\n    // Low priority — Fiber can interrupt this render\n    startTransition(() => {\n      setQuery(value);\n    });\n  };\n\n  return (\n    <div>\n      <input value={input} onChange={(e) => handleChange(e.target.value)} />\n      <div style={{ opacity: isPending ? 0.6 : 1 }}>\n        <SearchResults query={query} />\n      </div>\n    </div>\n  );\n}',
  followUp: 'How does Fiber decide which work to prioritize and when to yield to the browser?',
  keyTakeaway: 'Fiber is a linked-list reconciliation engine that enables incremental, interruptible rendering and concurrent features.',
},
{
  id: 20,
  title: 'What are the limitations of error boundaries and how do you work around them?',
  difficulty: 'hard',
  topic: 'core-rendering',
  subtopic: 'error-boundaries',
  answer: 'Error boundaries only catch errors during rendering, lifecycle methods, and constructors of the component tree below them. They do NOT catch errors in event handlers, asynchronous code (`setTimeout`, `fetch`, promises), server-side rendering, or errors thrown in the error boundary itself. For event handler errors, you need standard `try/catch` blocks. For async errors, you can catch them and re-throw into the React render cycle using a state setter pattern, which forces the error boundary to catch it on the next render.',
  codeExample: 'import { useState } from \'react\';\n\nfunction AsyncErrorThrower() {\n  const [, setState] = useState();\n\n  const handleClick = async () => {\n    try {\n      const res = await fetch(\'/api/data\');\n      if (!res.ok) throw new Error(\'Fetch failed\');\n    } catch (error) {\n      // Re-throw into React render cycle\n      // This triggers the nearest error boundary\n      setState(() => { throw error; });\n    }\n  };\n\n  return <button onClick={handleClick}>Load Data</button>;\n}\n\n// Event handler errors need try/catch\nfunction SafeButton() {\n  const handleClick = () => {\n    try {\n      riskyOperation();\n    } catch (error) {\n      // Handle locally — error boundary won\'t catch this\n      console.error(\'Event handler error:\', error);\n    }\n  };\n\n  return <button onClick={handleClick}>Do Something</button>;\n}\n\nfunction riskyOperation() { throw new Error(\'oops\'); }',
  followUp: 'How do libraries like `react-error-boundary` improve the developer experience over raw class-based error boundaries?',
  keyTakeaway: 'Error boundaries miss event handlers and async errors — use `try/catch` and the state-setter re-throw pattern to bridge those gaps.',
},
{
  id: 21,
  title: 'How does `Suspense` work for data fetching and what changed with React 18\'s streaming SSR?',
  difficulty: 'hard',
  topic: 'core-rendering',
  subtopic: 'suspense',
  answer: 'Suspense for data fetching works by letting a component "suspend" — throw a promise during rendering — which React catches to show the fallback. When the promise resolves, React retries the render. In React 18, Suspense integrates with streaming SSR via `renderToPipeableStream`: the server sends the shell HTML immediately and streams in suspended chunks as they resolve, with inline `<script>` tags that swap placeholders for real content. This eliminates waterfall loading — the browser can start hydrating completed sections while others are still streaming.',
  codeExample: '// Server-side streaming with Suspense\nimport { renderToPipeableStream } from \'react-dom/server\';\nimport { Suspense } from \'react\';\n\nfunction App() {\n  return (\n    <html>\n      <body>\n        <header>Loads instantly</header>\n        <Suspense fallback={<div>Loading feed...</div>}>\n          {/* This component suspends while fetching data */}\n          <NewsFeed />\n        </Suspense>\n        <Suspense fallback={<div>Loading sidebar...</div>}>\n          <Sidebar />\n        </Suspense>\n      </body>\n    </html>\n  );\n}\n\n// Server streams HTML progressively:\n// 1. Shell with header + fallbacks sent immediately\n// 2. NewsFeed HTML streamed when data resolves\n// 3. Sidebar HTML streamed independently\n// Browser hydrates each section as it arrives',
  followUp: 'What is selective hydration and how does Suspense enable it in React 18?',
  keyTakeaway: 'Suspense for data fetching catches thrown promises; React 18 streaming SSR sends the shell first and streams suspended sections as they resolve.',
},
{
  id: 22,
  title: 'What happens when you use an unstable key (like `Math.random()`) on a list element?',
  difficulty: 'hard',
  topic: 'core-rendering',
  subtopic: 'keys',
  answer: 'Using an unstable key like `Math.random()` generates a new key on every render, which tells React that every item is a brand-new element. This causes React to unmount and remount every list item on each re-render, destroying all component state, DOM state (focus, scroll position, input values), and triggering all effects. Performance degrades severely because React cannot reuse any existing DOM nodes. This is worse than using no key at all, since index-based fallback at least preserves position-based matches.',
  codeExample: 'import { useState } from \'react\';\n\ninterface ItemProps { name: string; }\n\nfunction EditableItem({ name }: ItemProps) {\n  const [value, setValue] = useState(name);\n  // Input state is LOST every render with unstable keys\n  return <input value={value} onChange={(e) => setValue(e.target.value)} />;\n}\n\n// BAD: Math.random() key — every item remounts every render\nfunction BadList({ items }: { items: string[] }) {\n  return (\n    <ul>\n      {items.map((item) => (\n        <li key={Math.random()}>\n          <EditableItem name={item} />\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// GOOD: stable key from data\nfunction GoodList({ items }: { items: { id: string; name: string }[] }) {\n  return (\n    <ul>\n      {items.map((item) => (\n        <li key={item.id}>\n          <EditableItem name={item.name} />\n        </li>\n      ))}\n    </ul>\n  );\n}',
  followUp: 'Can you use a key prop on a non-list component, and what effect does it have?',
  keyTakeaway: 'Unstable keys force React to unmount and remount every item on each render, destroying state and killing performance.',
},
{
  id: 23,
  title: 'How does JSX handle boolean, null, and undefined values, and what pitfalls exist with falsy expressions?',
  difficulty: 'hard',
  topic: 'core-rendering',
  subtopic: 'jsx',
  answer: 'JSX ignores `true`, `false`, `null`, and `undefined` — they render nothing. This enables the `{condition && <Component />}` pattern. However, `0` and `""` (empty string) are falsy but DO render as text, which is a common pitfall. Writing `{count && <Items />}` renders the text `0` when count is zero instead of rendering nothing. The fix is to ensure the left side of `&&` is a boolean: `{count > 0 && <Items />}` or `{Boolean(count) && <Items />}`. The `NaN` value also renders as text.',
  codeExample: 'function Dashboard({ count, name }: { count: number; name: string }) {\n  return (\n    <div>\n      {/* These render nothing */}\n      {true}\n      {false}\n      {null}\n      {undefined}\n\n      {/* BUG: renders "0" when count is 0 */}\n      {count && <p>{count} items</p>}\n\n      {/* FIX: explicitly convert to boolean */}\n      {count > 0 && <p>{count} items</p>}\n\n      {/* BUG: renders "" (empty string) when name is "" */}\n      {name && <p>Hello, {name}</p>}\n\n      {/* FIX: check length or use ternary */}\n      {name.length > 0 ? <p>Hello, {name}</p> : null}\n\n      {/* NaN also renders as text — another gotcha */}\n      {Number(\'abc\')}\n      {/* Renders "NaN" in the DOM */}\n    </div>\n  );\n}',
  followUp: 'Why does React render `0` and `""` but not `false` or `null`?',
  keyTakeaway: 'JSX renders `0`, `""`, and `NaN` as text despite being falsy — always use explicit boolean checks with `&&` patterns.',
},
{
  id: 24,
  title: 'How does React\'s concurrent rendering model differ from synchronous rendering, and what are its implications?',
  difficulty: 'hard',
  topic: 'core-rendering',
  subtopic: 'reconciliation',
  answer: 'In synchronous rendering (React 17 and below), once React starts rendering a tree, it finishes the entire pass without interruption. In concurrent mode (React 18+), React can start rendering, pause to handle higher-priority updates (like user input), and resume or discard incomplete renders. This means render functions may be called multiple times before committing to the DOM, so they must be pure — no side effects, no external mutations. Concurrent features like `useTransition` and `useDeferredValue` rely on this interruptible rendering to keep the UI responsive.',
  codeExample: 'import { useDeferredValue, useState, useMemo } from \'react\';\n\nfunction FilteredList({ items }: { items: string[] }) {\n  const [filter, setFilter] = useState(\'\');\n\n  // Deferred value lets React interrupt the expensive render\n  const deferredFilter = useDeferredValue(filter);\n  const isStale = filter !== deferredFilter;\n\n  // Expensive filtering runs at lower priority\n  const filtered = useMemo(\n    () => items.filter((item) =>\n      item.toLowerCase().includes(deferredFilter.toLowerCase())\n    ),\n    [items, deferredFilter]\n  );\n\n  return (\n    <div>\n      <input\n        value={filter}\n        onChange={(e) => setFilter(e.target.value)}\n        placeholder="Filter items..."\n      />\n      <div style={{ opacity: isStale ? 0.7 : 1 }}>\n        {filtered.map((item) => (\n          <div key={item}>{item}</div>\n        ))}\n      </div>\n    </div>\n  );\n}',
  followUp: 'What does it mean for render functions to be "pure" in the context of concurrent rendering?',
  keyTakeaway: 'Concurrent rendering lets React pause, resume, and discard renders for responsiveness, requiring render functions to be pure and side-effect free.',
},
{
  id: 25,
  title: 'How do you use `useImperativeHandle` with `forwardRef` to expose a custom API from a child component?',
  difficulty: 'hard',
  topic: 'core-rendering',
  subtopic: 'refs',
  answer: '`useImperativeHandle` customizes the value exposed to parent components when using `forwardRef`. Instead of exposing the entire DOM node, you can expose a limited, well-defined API with specific methods. This is useful for complex components like video players, canvas wrappers, or form fields where you want parents to call methods like `play()`, `reset()`, or `scrollIntoView()` without accessing the raw DOM. It takes the forwarded ref, a factory function returning the exposed object, and an optional dependency array.',
  codeExample: 'import { forwardRef, useRef, useImperativeHandle } from \'react\';\n\n// Define the imperative API\ninterface VideoPlayerHandle {\n  play: () => void;\n  pause: () => void;\n  seekTo: (time: number) => void;\n}\n\ninterface VideoPlayerProps {\n  src: string;\n}\n\nconst VideoPlayer = forwardRef<VideoPlayerHandle, VideoPlayerProps>(\n  ({ src }, ref) => {\n    const videoRef = useRef<HTMLVideoElement>(null);\n\n    // Expose only specific methods, not the full DOM node\n    useImperativeHandle(ref, () => ({\n      play: () => videoRef.current?.play(),\n      pause: () => videoRef.current?.pause(),\n      seekTo: (time: number) => {\n        if (videoRef.current) videoRef.current.currentTime = time;\n      },\n    }), []);\n\n    return <video ref={videoRef} src={src} />;\n  }\n);\nVideoPlayer.displayName = \'VideoPlayer\';\n\n// Parent uses the clean API\nfunction App() {\n  const playerRef = useRef<VideoPlayerHandle>(null);\n\n  return (\n    <div>\n      <VideoPlayer ref={playerRef} src="/video.mp4" />\n      <button onClick={() => playerRef.current?.play()}>Play</button>\n      <button onClick={() => playerRef.current?.seekTo(0)}>Restart</button>\n    </div>\n  );\n}',
  followUp: 'In React 19 where `ref` is a regular prop, how does `useImperativeHandle` work without `forwardRef`?',
  keyTakeaway: '`useImperativeHandle` exposes a custom, limited API to parent refs instead of the raw DOM node, promoting encapsulation.',
},
{
  id: 26,
  title: 'What is the `useState` hook and how do you use it?',
  difficulty: 'easy',
  topic: 'hooks-state',
  subtopic: 'useState',
  answer: '`useState` is a React hook that lets you add state to functional components. It accepts an initial value and returns a tuple of the current state value and a setter function. When you call the setter, React schedules a re-render with the new value. The state is preserved between renders, and each component instance maintains its own independent state.',
  codeExample: 'import { useState } from \'react\';\n\nfunction Counter(): JSX.Element {\n  // Declare state with initial value of 0\n  const [count, setCount] = useState<number>(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <button onClick={() => setCount(0)}>Reset</button>\n    </div>\n  );\n}',
  followUp: 'What happens if you call `setCount` twice in the same event handler with the same direct value — does it increment twice?',
  keyTakeaway: '`useState` returns a [value, setter] tuple and triggers a re-render when the setter is called with a new value.',
},
{
  id: 27,
  title: 'How does the `useEffect` dependency array control when the effect runs?',
  difficulty: 'easy',
  topic: 'hooks-state',
  subtopic: 'useEffect',
  answer: 'The dependency array is the second argument to `useEffect` and determines when the effect callback re-executes. If omitted, the effect runs after every render. If an empty array `[]` is provided, the effect runs only once after the initial mount. If the array contains values, the effect re-runs whenever any of those values change between renders, compared using `Object.is` shallow equality.',
  codeExample: 'import { useEffect, useState } from \'react\';\n\nfunction UserProfile({ userId }: { userId: string }): JSX.Element {\n  const [user, setUser] = useState<User | null>(null);\n\n  // Runs only when userId changes\n  useEffect(() => {\n    let cancelled = false;\n    fetchUser(userId).then((data) => {\n      if (!cancelled) setUser(data);\n    });\n    return () => { cancelled = true; };\n  }, [userId]);\n\n  return <div>{user?.name ?? \'Loading...\'}</div>;\n}',
  followUp: 'What happens if you put an object or array in the dependency array — will the effect fire on every render?',
  keyTakeaway: 'The dependency array controls effect timing: omitted means every render, empty means mount-only, and specific values mean run when those values change.',
},
{
  id: 28,
  title: 'What is `useRef` and how is it different from `useState`?',
  difficulty: 'easy',
  topic: 'hooks-state',
  subtopic: 'useRef',
  answer: '`useRef` returns a mutable ref object with a `.current` property that persists across renders without triggering re-renders when mutated. Unlike `useState`, updating a ref does not cause the component to re-render. This makes refs ideal for storing values that need to survive re-renders but should not drive the UI, such as timer IDs, previous values, or imperative handles.',
  codeExample: 'import { useRef, useEffect, useState } from \'react\';\n\nfunction Stopwatch(): JSX.Element {\n  const [seconds, setSeconds] = useState(0);\n  // Ref holds the interval ID without causing re-renders\n  const intervalRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  const start = () => {\n    intervalRef.current = setInterval(() => {\n      setSeconds((s) => s + 1);\n    }, 1000);\n  };\n\n  const stop = () => {\n    if (intervalRef.current) clearInterval(intervalRef.current);\n  };\n\n  useEffect(() => stop, []); // Cleanup on unmount\n\n  return <div>{seconds}s</div>;\n}',
  followUp: 'Can you use `useRef` to access a DOM element directly, and when would you need to?',
  keyTakeaway: '`useRef` stores a mutable value that persists across renders without triggering re-renders, unlike `useState`.',
},
{
  id: 29,
  title: 'What are the rules of hooks and why do they exist?',
  difficulty: 'easy',
  topic: 'hooks-state',
  subtopic: 'rules-of-hooks',
  answer: 'There are two main rules: (1) Only call hooks at the top level of a component or custom hook — never inside loops, conditions, or nested functions. (2) Only call hooks from React function components or custom hooks — never from regular JavaScript functions. These rules exist because React relies on the order of hook calls to associate each hook with its internal state slot. If the call order changes between renders due to conditional logic, React would mismatch state values with the wrong hooks.',
  codeExample: 'import { useState, useEffect } from \'react\';\n\nfunction BadComponent({ isLoggedIn }: { isLoggedIn: boolean }): JSX.Element {\n  // WRONG: conditional hook call breaks the rules\n  // if (isLoggedIn) {\n  //   const [name, setName] = useState(\'\');\n  // }\n\n  // CORRECT: always call the hook, conditionally use the value\n  const [name, setName] = useState(\'\');\n\n  useEffect(() => {\n    if (isLoggedIn) {\n      fetchUserName().then(setName);\n    }\n  }, [isLoggedIn]);\n\n  return <div>{isLoggedIn ? name : \'Guest\'}</div>;\n}',
  followUp: 'How does the `eslint-plugin-react-hooks` linter help enforce these rules in practice?',
  keyTakeaway: 'Hooks must be called at the top level in consistent order so React can correctly map each hook call to its persisted state slot.',
},
{
  id: 30,
  title: 'How do you create and consume a context with `useContext`?',
  difficulty: 'easy',
  topic: 'hooks-state',
  subtopic: 'useContext',
  answer: 'You create a context with `React.createContext(defaultValue)`, provide a value using the `<Context.Provider value={...}>` wrapper, and consume it in any descendant with `useContext(Context)`. The hook returns the current context value from the nearest matching provider above the component in the tree. If no provider is found, the default value passed to `createContext` is used. This pattern replaces prop drilling for shared values like themes, auth state, or locale.',
  codeExample: 'import { createContext, useContext, useState, type ReactNode } from \'react\';\n\ninterface ThemeContextType {\n  theme: \'light\' | \'dark\';\n  toggle: () => void;\n}\n\nconst ThemeContext = createContext<ThemeContextType | null>(null);\n\nfunction ThemeProvider({ children }: { children: ReactNode }): JSX.Element {\n  const [theme, setTheme] = useState<\'light\' | \'dark\'>(\'light\');\n  const toggle = () => setTheme((t) => (t === \'light\' ? \'dark\' : \'light\'));\n  return <ThemeContext.Provider value={{ theme, toggle }}>{children}</ThemeContext.Provider>;\n}\n\nfunction ThemedButton(): JSX.Element {\n  const ctx = useContext(ThemeContext);\n  if (!ctx) throw new Error(\'Must be used within ThemeProvider\');\n  return <button onClick={ctx.toggle}>{ctx.theme}</button>;\n}',
  followUp: 'What happens to all consumers when the context value changes — do they all re-render?',
  keyTakeaway: '`useContext` reads the nearest provider value above the component, enabling shared state without prop drilling.',
},
{
  id: 31,
  title: 'What is `useMemo` and when should you use it?',
  difficulty: 'easy',
  topic: 'hooks-state',
  subtopic: 'useMemo',
  answer: '`useMemo` memoizes the result of an expensive computation, recomputing only when one of its dependencies changes. It accepts a factory function and a dependency array, returning the cached value on subsequent renders if the dependencies are unchanged. Use it for computationally expensive calculations like filtering or sorting large lists, or when you need referential stability for an object or array passed to a child component. Do not use it for trivial computations, as the overhead of memoization itself may outweigh the benefit.',
  codeExample: 'import { useMemo, useState } from \'react\';\n\ninterface Product { id: number; name: string; price: number; }\n\nfunction ProductList({ products }: { products: Product[] }): JSX.Element {\n  const [query, setQuery] = useState(\'\');\n  const [sortBy, setSortBy] = useState<\'name\' | \'price\'>(\'name\');\n\n  // Only recomputes when products, query, or sortBy changes\n  const filtered = useMemo(() => {\n    const result = products.filter((p) => p.name.toLowerCase().includes(query.toLowerCase()));\n    return result.sort((a, b) => (sortBy === \'price\' ? a.price - b.price : a.name.localeCompare(b.name)));\n  }, [products, query, sortBy]);\n\n  return <ul>{filtered.map((p) => <li key={p.id}>{p.name} — ${p.price}</li>)}</ul>;\n}',
  followUp: 'What is the difference between `useMemo` and `useCallback`?',
  keyTakeaway: '`useMemo` caches a computed value and recalculates only when its dependencies change, avoiding redundant expensive work.',
},
{
  id: 32,
  title: 'What is `useCallback` and when does it improve performance?',
  difficulty: 'easy',
  topic: 'hooks-state',
  subtopic: 'useCallback',
  answer: '`useCallback` returns a memoized version of a callback function that only changes when its dependencies change. It is essentially `useMemo(() => fn, deps)`. The primary use case is passing stable callback references to child components wrapped in `React.memo`, preventing unnecessary re-renders caused by new function references on every parent render. Without `useCallback`, a new function instance is created each render, which breaks referential equality checks in memoized children.',
  codeExample: 'import { useCallback, useState, memo } from \'react\';\n\ninterface ButtonProps { onClick: () => void; label: string; }\n\n// Memoized child — only re-renders if props change by reference\nconst ExpensiveButton = memo(function ExpensiveButton({ onClick, label }: ButtonProps): JSX.Element {\n  console.log(\'ExpensiveButton rendered\');\n  return <button onClick={onClick}>{label}</button>;\n});\n\nfunction Parent(): JSX.Element {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState(\'\');\n\n  // Stable reference — ExpensiveButton won\'t re-render when text changes\n  const increment = useCallback(() => setCount((c) => c + 1), []);\n\n  return (\n    <div>\n      <input value={text} onChange={(e) => setText(e.target.value)} />\n      <ExpensiveButton onClick={increment} label={`Count: ${count}`} />\n    </div>\n  );\n}',
  followUp: 'Is there ever a case where `useCallback` could hurt performance rather than help?',
  keyTakeaway: '`useCallback` memoizes a function reference so memoized children receiving it as a prop can skip unnecessary re-renders.',
},
{
  id: 33,
  title: 'How do functional updates work with `useState` and why are they necessary?',
  difficulty: 'medium',
  topic: 'hooks-state',
  subtopic: 'useState',
  answer: 'A functional update passes a function to the setter instead of a direct value: `setState(prev => prev + 1)`. The function receives the most recent state as its argument and returns the new state. This is necessary when the next state depends on the previous state, especially in asynchronous contexts or when multiple updates are batched. Using the direct form like `setState(count + 1)` inside a stale closure captures an outdated `count` value, while the functional form always reads the latest state from React\'s internal queue.',
  codeExample: 'import { useState } from \'react\';\n\nfunction Counter(): JSX.Element {\n  const [count, setCount] = useState(0);\n\n  const incrementThrice = () => {\n    // BUG: all three read the same stale `count` value\n    // setCount(count + 1); setCount(count + 1); setCount(count + 1);\n    // Result: count only increases by 1\n\n    // CORRECT: functional updates chain properly\n    setCount((prev) => prev + 1);\n    setCount((prev) => prev + 1);\n    setCount((prev) => prev + 1);\n    // Result: count increases by 3\n  };\n\n  return <button onClick={incrementThrice}>Count: {count}</button>;\n}',
  followUp: 'How does React batch these functional updates internally, and does batching behavior differ between React 17 and 18?',
  keyTakeaway: 'Functional updates receive the latest state as an argument, preventing stale closure bugs when updates depend on previous state.',
},
{
  id: 34,
  title: 'How does `useEffect` cleanup work and when does the cleanup function run?',
  difficulty: 'medium',
  topic: 'hooks-state',
  subtopic: 'useEffect',
  answer: 'A `useEffect` callback can return a cleanup function that React calls to tear down the previous effect before running the next one, and also when the component unmounts. Specifically, when dependencies change, React first runs the old cleanup, then runs the new effect. This pattern is essential for cancelling subscriptions, aborting fetch requests, clearing timers, and removing event listeners. Without cleanup, you risk memory leaks and stale event handlers accumulating across re-renders.',
  codeExample: 'import { useEffect, useState } from \'react\';\n\nfunction ChatRoom({ roomId }: { roomId: string }): JSX.Element {\n  const [messages, setMessages] = useState<string[]>([]);\n\n  useEffect(() => {\n    const connection = createConnection(roomId);\n    connection.on(\'message\', (msg: string) => {\n      setMessages((prev) => [...prev, msg]);\n    });\n    connection.connect();\n\n    // Cleanup: disconnect from OLD room before connecting to new one\n    return () => {\n      connection.disconnect();\n    };\n  }, [roomId]); // Re-runs when roomId changes\n\n  return <ul>{messages.map((m, i) => <li key={i}>{m}</li>)}</ul>;\n}',
  followUp: 'In React 18 Strict Mode, effects mount, unmount, and remount in development — how does that affect your cleanup logic?',
  keyTakeaway: 'The cleanup function returned from `useEffect` runs before the next effect execution and on unmount, preventing resource leaks.',
},
{
  id: 35,
  title: 'When should you use `useReducer` instead of `useState`?',
  difficulty: 'medium',
  topic: 'hooks-state',
  subtopic: 'useReducer',
  answer: '`useReducer` is preferred over `useState` when state logic is complex, involves multiple sub-values, or when the next state depends on the previous state in non-trivial ways. It centralizes state transitions into a pure reducer function, making state changes predictable and easier to test independently. It is also useful when multiple event handlers need to perform related state changes, because they can dispatch named actions rather than duplicating update logic. Think of it as an in-component version of the Redux pattern.',
  codeExample: 'import { useReducer } from \'react\';\n\ninterface FormState { name: string; email: string; submitting: boolean; error: string | null; }\ntype FormAction =\n  | { type: \'SET_FIELD\'; field: keyof FormState; value: string }\n  | { type: \'SUBMIT\' }\n  | { type: \'SUCCESS\' }\n  | { type: \'ERROR\'; message: string };\n\nfunction formReducer(state: FormState, action: FormAction): FormState {\n  switch (action.type) {\n    case \'SET_FIELD\': return { ...state, [action.field]: action.value };\n    case \'SUBMIT\': return { ...state, submitting: true, error: null };\n    case \'SUCCESS\': return { ...state, submitting: false };\n    case \'ERROR\': return { ...state, submitting: false, error: action.message };\n  }\n}\n\nconst initialState: FormState = { name: \'\', email: \'\', submitting: false, error: null };\n\nfunction SignupForm(): JSX.Element {\n  const [state, dispatch] = useReducer(formReducer, initialState);\n  return <input value={state.name} onChange={(e) => dispatch({ type: \'SET_FIELD\', field: \'name\', value: e.target.value })} />;\n}',
  followUp: 'Can you use `useReducer` with `useContext` to build a global state management solution, and what are the trade-offs compared to Zustand or Redux?',
  keyTakeaway: '`useReducer` is ideal for complex state with multiple related transitions, centralizing logic in a testable pure reducer function.',
},
{
  id: 36,
  title: 'What is lazy initialization in `useState` and why would you use it?',
  difficulty: 'medium',
  topic: 'hooks-state',
  subtopic: 'useState',
  answer: 'Lazy initialization passes a function to `useState` instead of a direct value: `useState(() => expensiveComputation())`. The function is called only once during the initial render and its return value becomes the initial state. On subsequent renders, the initializer is ignored entirely. This avoids running expensive computations or reading from localStorage on every re-render, since passing a direct value like `useState(expensiveComputation())` would invoke that function on every render even though the result is discarded after the first.',
  codeExample: 'import { useState } from \'react\';\n\ninterface Preferences { theme: string; fontSize: number; }\n\n// BAD: JSON.parse runs on EVERY render\n// const [prefs, setPrefs] = useState(JSON.parse(localStorage.getItem(\'prefs\') ?? \'{}\'));\n\nfunction Settings(): JSX.Element {\n  // GOOD: initializer function runs only on first render\n  const [prefs, setPrefs] = useState<Preferences>(() => {\n    const stored = localStorage.getItem(\'prefs\');\n    return stored ? JSON.parse(stored) : { theme: \'dark\', fontSize: 14 };\n  });\n\n  const updateTheme = (theme: string) => {\n    setPrefs((prev) => ({ ...prev, theme }));\n  };\n\n  return <div>Theme: {prefs.theme}</div>;\n}',
  followUp: 'Does `useReducer` also support lazy initialization, and if so, how?',
  keyTakeaway: 'Passing a function to `useState` runs the initializer only once on mount, avoiding expensive re-computation on every render.',
},
{
  id: 37,
  title: 'What is a stale closure in `useEffect` and how do you fix it?',
  difficulty: 'medium',
  topic: 'hooks-state',
  subtopic: 'useEffect',
  answer: 'A stale closure occurs when a `useEffect` callback captures variables from a previous render\'s scope and never receives the updated values. This typically happens when you reference state or props inside an effect but omit them from the dependency array. The effect keeps running with the original captured values, leading to bugs where the UI shows updated data but the effect uses outdated values. Fix it by including all referenced variables in the dependency array, using functional state updates, or using a ref to always read the latest value.',
  codeExample: 'import { useState, useEffect, useRef } from \'react\';\n\nfunction StaleClosureDemo(): JSX.Element {\n  const [count, setCount] = useState(0);\n\n  // BUG: stale closure — count is always 0 inside the interval\n  // useEffect(() => {\n  //   const id = setInterval(() => console.log(count), 1000);\n  //   return () => clearInterval(id);\n  // }, []);\n\n  // FIX 1: functional update avoids reading stale count\n  useEffect(() => {\n    const id = setInterval(() => setCount((c) => c + 1), 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  // FIX 2: ref always holds the latest value\n  const countRef = useRef(count);\n  countRef.current = count;\n  useEffect(() => {\n    const id = setInterval(() => console.log(countRef.current), 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  return <div>{count}</div>;\n}',
  followUp: 'Does the `useEvent` proposal (or React 19 equivalent) solve the stale closure problem?',
  keyTakeaway: 'Stale closures capture outdated state inside effects — fix by adding correct dependencies, using functional updates, or using refs.',
},
{
  id: 38,
  title: 'How do you use `useRef` to access and manipulate DOM elements?',
  difficulty: 'medium',
  topic: 'hooks-state',
  subtopic: 'useRef',
  answer: 'Create a ref with `useRef<HTMLElement>(null)` and attach it to a JSX element via the `ref` attribute. After the component mounts, `ref.current` points to the actual DOM node, allowing imperative operations like focusing an input, measuring dimensions, or scrolling into view. The ref is populated during the commit phase, so it is available inside `useEffect` callbacks and event handlers but not during the initial render return. For TypeScript, type the ref with the specific element type like `useRef<HTMLInputElement>(null)` for proper autocompletion.',
  codeExample: 'import { useRef, useEffect } from \'react\';\n\nfunction AutoFocusInput(): JSX.Element {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    // DOM node is available after mount\n    inputRef.current?.focus();\n  }, []);\n\n  const handleReset = () => {\n    if (inputRef.current) {\n      inputRef.current.value = \'\';\n      inputRef.current.focus();\n    }\n  };\n\n  return (\n    <div>\n      <input ref={inputRef} type=\"text\" placeholder=\"Auto-focused\" />\n      <button onClick={handleReset}>Reset</button>\n    </div>\n  );\n}',
  followUp: 'How do you forward a ref from a parent component to a child component\'s internal DOM element using `forwardRef`?',
  keyTakeaway: '`useRef` with a `ref` attribute gives direct access to a DOM node after mount for imperative operations like focus and measurement.',
},
{
  id: 39,
  title: 'How do you extract reusable logic into a custom hook?',
  difficulty: 'medium',
  topic: 'hooks-state',
  subtopic: 'custom-hooks',
  answer: 'A custom hook is a JavaScript function whose name starts with `use` and that calls other hooks internally. You extract repeated stateful logic from components into a custom hook, which encapsulates the state, effects, and any derived values while exposing only the interface consumers need. Each component calling the custom hook gets its own independent copy of the state — hooks do not share state between callers. Custom hooks follow all the same rules as built-in hooks and can compose other custom hooks.',
  codeExample: 'import { useState, useEffect } from \'react\';\n\n// Custom hook for fetching data\nfunction useFetch<T>(url: string): { data: T | null; loading: boolean; error: string | null } {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    let cancelled = false;\n    setLoading(true);\n    fetch(url)\n      .then((res) => res.json())\n      .then((json: T) => { if (!cancelled) { setData(json); setLoading(false); } })\n      .catch((err: Error) => { if (!cancelled) { setError(err.message); setLoading(false); } });\n    return () => { cancelled = true; };\n  }, [url]);\n\n  return { data, loading, error };\n}\n\n// Usage in a component\nfunction UserList(): JSX.Element {\n  const { data, loading, error } = useFetch<User[]>(\'/api/users\');\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  return <ul>{data?.map((u) => <li key={u.id}>{u.name}</li>)}</ul>;\n}',
  followUp: 'How would you add caching or deduplication to this custom `useFetch` hook to avoid redundant network requests?',
  keyTakeaway: 'Custom hooks extract reusable stateful logic into functions prefixed with `use`, giving each consumer an independent state copy.',
},
{
  id: 40,
  title: 'What is `useMemo` referential equality and why does it matter for child components?',
  difficulty: 'medium',
  topic: 'hooks-state',
  subtopic: 'useMemo',
  answer: 'In React, objects and arrays created during render get a new reference every time, even if their contents are identical. When passed as props to a child wrapped in `React.memo`, the new reference causes a failed shallow comparison and an unnecessary re-render. `useMemo` preserves the same object reference across renders as long as dependencies remain unchanged, so memoized children can skip re-rendering. This referential stability is also important for dependency arrays in `useEffect` and `useCallback`, where an unstable object reference would trigger the effect or callback to regenerate every render.',
  codeExample: 'import { useMemo, memo, useState } from \'react\';\n\ninterface ChartProps { data: { x: number; y: number }[]; }\n\n// Expensive child component — only re-renders when data reference changes\nconst Chart = memo(function Chart({ data }: ChartProps): JSX.Element {\n  console.log(\'Chart rendered with\', data.length, \'points\');\n  return <canvas />;\n});\n\nfunction Dashboard(): JSX.Element {\n  const [filter, setFilter] = useState(\'\');\n  const [rawData] = useState([{ x: 1, y: 10 }, { x: 2, y: 20 }, { x: 3, y: 30 }]);\n\n  // Without useMemo, a new array is created every render\n  const chartData = useMemo(\n    () => rawData.map((d) => ({ x: d.x, y: d.y * 2 })),\n    [rawData]\n  );\n\n  return (\n    <div>\n      <input value={filter} onChange={(e) => setFilter(e.target.value)} />\n      <Chart data={chartData} />\n    </div>\n  );\n}',
  followUp: 'Does React\'s compiler (React Forget) automatically handle memoization, making `useMemo` unnecessary in the future?',
  keyTakeaway: '`useMemo` preserves referential identity of objects across renders, preventing unnecessary re-renders in memoized child components.',
},
{
  id: 41,
  title: 'Why should you avoid using `useCallback` everywhere, and when does it not help?',
  difficulty: 'medium',
  topic: 'hooks-state',
  subtopic: 'useCallback',
  answer: '`useCallback` is only beneficial when the callback is passed to a memoized child component (`React.memo`) or used in a dependency array of another hook. If the child is not memoized, wrapping the callback in `useCallback` adds overhead (dependency comparison, closure allocation) without preventing any re-renders — the child re-renders anyway because its parent re-rendered. Additionally, if the dependency array changes frequently, the callback is recreated on most renders, making the memoization pointless. Premature use of `useCallback` clutters code and can actually be slower than creating a plain inline function.',
  codeExample: 'import { useCallback, useState } from \'react\';\n\n// NOT memoized — useCallback on the parent is wasted\nfunction PlainChild({ onClick }: { onClick: () => void }): JSX.Element {\n  return <button onClick={onClick}>Click</button>;\n}\n\nfunction Parent(): JSX.Element {\n  const [count, setCount] = useState(0);\n\n  // WASTEFUL: PlainChild is not wrapped in React.memo\n  // so it re-renders regardless of callback stability\n  const handleClick = useCallback(() => {\n    setCount((c) => c + 1);\n  }, []);\n\n  // SIMPLER: just use an inline function when the child is not memoized\n  return <PlainChild onClick={() => setCount((c) => c + 1)} />;\n}',
  followUp: 'How do you profile whether `useCallback` is actually providing a performance benefit in your application?',
  keyTakeaway: '`useCallback` only helps when paired with `React.memo` children or hook dependency arrays — otherwise it adds overhead without benefit.',
},
{
  id: 42,
  title: 'How do you share stateful logic between components using custom hooks vs. context?',
  difficulty: 'medium',
  topic: 'hooks-state',
  subtopic: 'custom-hooks',
  answer: 'Custom hooks share logic but not state — each component calling the hook gets its own independent state instance. Context shares actual state — all consumers read from the same provider value. Use a custom hook when components need the same behavior pattern (like fetching, form validation, or debouncing) but with independent data. Use context when components need to read and react to the same shared value (like the current user, theme, or locale). You can combine both patterns by creating a custom hook that internally calls `useContext` to provide a clean API over shared state.',
  codeExample: 'import { createContext, useContext, useState, type ReactNode } from \'react\';\n\n// Custom hook: shared LOGIC, independent STATE\nfunction useToggle(initial: boolean = false): [boolean, () => void] {\n  const [value, setValue] = useState(initial);\n  const toggle = () => setValue((v) => !v);\n  return [value, toggle];\n}\n\n// Context + custom hook: shared STATE via provider\ninterface AuthContextType { user: string | null; login: (name: string) => void; logout: () => void; }\nconst AuthContext = createContext<AuthContextType | null>(null);\n\nfunction useAuth(): AuthContextType {\n  const ctx = useContext(AuthContext);\n  if (!ctx) throw new Error(\'useAuth must be used within AuthProvider\');\n  return ctx;\n}\n\nfunction AuthProvider({ children }: { children: ReactNode }): JSX.Element {\n  const [user, setUser] = useState<string | null>(null);\n  return <AuthContext.Provider value={{ user, login: setUser, logout: () => setUser(null) }}>{children}</AuthContext.Provider>;\n}',
  followUp: 'What are the performance implications of putting frequently-changing values in context?',
  keyTakeaway: 'Custom hooks share reusable logic with independent state; context shares actual state across all consumers in the tree.',
},
{
  id: 43,
  title: 'What is `useId` and why was it introduced in React 18?',
  difficulty: 'medium',
  topic: 'hooks-state',
  subtopic: 'useId',
  answer: '`useId` generates a unique, stable ID string that is consistent between server and client renders. It was introduced to solve the hydration mismatch problem that occurs when using counters or `Math.random()` to generate IDs — the server generates one ID and the client generates a different one, causing a mismatch warning. `useId` produces the same ID on both server and client by deriving it from the component\'s position in the tree. It is primarily used for accessibility attributes like `htmlFor`/`id` pairs and `aria-describedby` references.',
  codeExample: 'import { useId } from \'react\';\n\ninterface FormFieldProps { label: string; type?: string; helpText?: string; }\n\nfunction FormField({ label, type = \'text\', helpText }: FormFieldProps): JSX.Element {\n  // Generates a unique ID consistent across server and client\n  const id = useId();\n  const helpId = helpText ? `${id}-help` : undefined;\n\n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input id={id} type={type} aria-describedby={helpId} />\n      {helpText && <p id={helpId}>{helpText}</p>}\n    </div>\n  );\n}\n\n// Each instance gets a unique ID — no collisions\n// <FormField label=\"Email\" /> → id=\":r1:\"\n// <FormField label=\"Password\" /> → id=\":r2:\"',
  followUp: 'Can you use `useId` as a key for list items, and why or why not?',
  keyTakeaway: '`useId` generates hydration-safe unique IDs consistent between server and client, solving SSR ID mismatch problems.',
},
{
  id: 44,
  title: 'What is the difference between `useLayoutEffect` and `useEffect`?',
  difficulty: 'hard',
  topic: 'hooks-state',
  subtopic: 'useLayoutEffect',
  answer: '`useLayoutEffect` fires synchronously after DOM mutations but before the browser paints, while `useEffect` fires asynchronously after the browser has painted. This means `useLayoutEffect` can read layout (like element dimensions) and synchronously re-render before the user sees the initial frame, preventing visual flicker. Use it for DOM measurements, tooltip positioning, or animations that must be calculated before paint. However, because it blocks painting, overusing it degrades performance. The vast majority of effects should use `useEffect`; reach for `useLayoutEffect` only when you observe a visual flicker that needs to be eliminated.',
  codeExample: 'import { useLayoutEffect, useEffect, useRef, useState } from \'react\';\n\nfunction Tooltip({ targetRef }: { targetRef: React.RefObject<HTMLElement | null> }): JSX.Element {\n  const tooltipRef = useRef<HTMLDivElement>(null);\n  const [position, setPosition] = useState({ top: 0, left: 0 });\n\n  // useLayoutEffect: measure and position BEFORE paint to prevent flicker\n  useLayoutEffect(() => {\n    if (!targetRef.current || !tooltipRef.current) return;\n    const rect = targetRef.current.getBoundingClientRect();\n    setPosition({ top: rect.bottom + 8, left: rect.left });\n  }, [targetRef]);\n\n  // useEffect would cause a brief flicker — tooltip appears at (0,0) then jumps\n  return <div ref={tooltipRef} style={{ position: \'fixed\', top: position.top, left: position.left }}>Tooltip</div>;\n}',
  followUp: 'What happens if you use `useLayoutEffect` in a server-rendered component, and how do you handle it?',
  keyTakeaway: '`useLayoutEffect` runs synchronously before paint for flicker-free DOM reads; `useEffect` runs asynchronously after paint.',
},
{
  id: 45,
  title: 'How does `useSyncExternalStore` work and when do you need it?',
  difficulty: 'hard',
  topic: 'hooks-state',
  subtopic: 'useSyncExternalStore',
  answer: '`useSyncExternalStore` subscribes a React component to an external store (any state source outside React) in a way that is compatible with concurrent rendering. It takes three arguments: a `subscribe` function that registers a callback, a `getSnapshot` function that returns the current value, and an optional `getServerSnapshot` for SSR. React calls `getSnapshot` during render and re-renders when the subscribed callback fires and the snapshot has changed. It was introduced in React 18 to prevent tearing — a bug where different parts of the UI show inconsistent state during concurrent renders because they read from a mutable external source at different times.',
  codeExample: 'import { useSyncExternalStore } from \'react\';\n\n// External store (not managed by React)\nlet listeners: Array<() => void> = [];\nlet windowWidth = typeof window !== \'undefined\' ? window.innerWidth : 0;\n\nfunction subscribe(callback: () => void): () => void {\n  listeners.push(callback);\n  window.addEventListener(\'resize\', callback);\n  return () => {\n    listeners = listeners.filter((l) => l !== callback);\n    window.removeEventListener(\'resize\', callback);\n  };\n}\n\nfunction getSnapshot(): number {\n  return window.innerWidth;\n}\n\nfunction getServerSnapshot(): number {\n  return 1024; // Default width for SSR\n}\n\nfunction useWindowWidth(): number {\n  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\nfunction ResponsiveLayout(): JSX.Element {\n  const width = useWindowWidth();\n  return <div>{width > 768 ? \'Desktop\' : \'Mobile\'} — {width}px</div>;\n}',
  followUp: 'What is tearing in concurrent React, and how does `useSyncExternalStore` prevent it?',
  keyTakeaway: '`useSyncExternalStore` safely subscribes React to external mutable stores, preventing tearing in concurrent rendering.',
},
{
  id: 46,
  title: 'How do you handle complex state transitions with `useReducer` and TypeScript discriminated unions?',
  difficulty: 'hard',
  topic: 'hooks-state',
  subtopic: 'useReducer',
  answer: 'Discriminated unions in TypeScript model `useReducer` actions as a union of interfaces that each have a `type` literal property. The `switch` statement on `action.type` narrows the type automatically, giving you type-safe access to each action\'s specific payload without casting. This pattern ensures exhaustive handling — the compiler warns if you forget an action type. Combined with `useReducer`, it creates a predictable state machine where every valid transition is explicitly defined, invalid state combinations are impossible to construct, and the reducer is easy to unit test in isolation.',
  codeExample: 'import { useReducer } from \'react\';\n\ntype AsyncState<T> =\n  | { status: \'idle\' }\n  | { status: \'loading\' }\n  | { status: \'success\'; data: T }\n  | { status: \'error\'; error: string };\n\ntype AsyncAction<T> =\n  | { type: \'FETCH\' }\n  | { type: \'RESOLVE\'; data: T }\n  | { type: \'REJECT\'; error: string }\n  | { type: \'RESET\' };\n\nfunction asyncReducer<T>(state: AsyncState<T>, action: AsyncAction<T>): AsyncState<T> {\n  switch (action.type) {\n    case \'FETCH\': return { status: \'loading\' };\n    case \'RESOLVE\': return { status: \'success\', data: action.data };\n    case \'REJECT\': return { status: \'error\', error: action.error };\n    case \'RESET\': return { status: \'idle\' };\n  }\n}\n\nfunction UserProfile(): JSX.Element {\n  const [state, dispatch] = useReducer(asyncReducer<User>, { status: \'idle\' });\n  // TypeScript narrows: state.status === \'success\' guarantees state.data exists\n  if (state.status === \'success\') return <div>{state.data.name}</div>;\n  if (state.status === \'error\') return <div>Error: {state.error}</div>;\n  return <div>Loading...</div>;\n}',
  followUp: 'How would you add middleware or logging around dispatched actions in a `useReducer` setup?',
  keyTakeaway: 'TypeScript discriminated unions with `useReducer` create exhaustively-typed state machines where invalid states are unrepresentable.',
},
{
  id: 47,
  title: 'What are the performance pitfalls of `useContext` and how do you mitigate them?',
  difficulty: 'hard',
  topic: 'hooks-state',
  subtopic: 'useContext',
  answer: 'Every component that calls `useContext` for a given context re-renders whenever the context value changes, regardless of whether the specific property the component uses has changed. If you put a large object in context that updates frequently, every consumer re-renders even if they only read a stable sub-field. Mitigations include: splitting context into smaller, focused contexts so consumers only subscribe to what they need; memoizing the context value with `useMemo` to prevent re-creation on every provider render; wrapping consumers in `React.memo` with selective props; or replacing context with a state management library that supports selector-based subscriptions.',
  codeExample: 'import { createContext, useContext, useMemo, useState, memo, type ReactNode } from \'react\';\n\n// BAD: one big context — all consumers re-render on any change\n// const AppContext = createContext({ user: null, theme: \'dark\', notifications: [] });\n\n// GOOD: split into focused contexts\ninterface UserContextType { user: string | null; setUser: (u: string | null) => void; }\nconst UserContext = createContext<UserContextType | null>(null);\n\ninterface ThemeContextType { theme: string; setTheme: (t: string) => void; }\nconst ThemeContext = createContext<ThemeContextType | null>(null);\n\nfunction UserProvider({ children }: { children: ReactNode }): JSX.Element {\n  const [user, setUser] = useState<string | null>(null);\n  // Memoize to prevent re-renders when parent re-renders\n  const value = useMemo(() => ({ user, setUser }), [user]);\n  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;\n}\n\n// This component only re-renders when user changes, not when theme changes\nconst UserBadge = memo(function UserBadge(): JSX.Element {\n  const ctx = useContext(UserContext);\n  return <span>{ctx?.user ?? \'Guest\'}</span>;\n});',
  followUp: 'How does the `use(Context)` API in React 19 differ from `useContext`, and does it solve the re-render problem?',
  keyTakeaway: 'Context causes all consumers to re-render on any value change — split contexts, memoize values, and keep context values small to mitigate.',
},
{
  id: 48,
  title: 'How do you build a custom hook that shares state across multiple components using `useSyncExternalStore`?',
  difficulty: 'hard',
  topic: 'hooks-state',
  subtopic: 'useSyncExternalStore',
  answer: 'You create a store module outside of React that holds mutable state, a set of listeners, and a `subscribe` function. The store exposes mutation methods that update the state and notify all listeners. Then you build a custom hook that calls `useSyncExternalStore` with the store\'s `subscribe` and `getSnapshot` functions. Unlike `useContext`, this approach does not require a provider wrapper and works with selector functions to prevent unnecessary re-renders when unrelated parts of the store change. This is the exact pattern that libraries like Zustand use internally.',
  codeExample: 'import { useSyncExternalStore, useCallback } from \'react\';\n\n// Store module — lives outside React\ninterface Store { count: number; text: string; }\nlet store: Store = { count: 0, text: \'\' };\nlet listeners = new Set<() => void>();\n\nfunction emitChange(): void {\n  listeners.forEach((l) => l());\n}\n\nconst todoStore = {\n  subscribe(listener: () => void): () => void {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  },\n  getSnapshot(): Store { return store; },\n  increment() { store = { ...store, count: store.count + 1 }; emitChange(); },\n  setText(text: string) { store = { ...store, text }; emitChange(); },\n};\n\n// Custom hook with selector to avoid unnecessary re-renders\nfunction useStore<T>(selector: (s: Store) => T): T {\n  return useSyncExternalStore(\n    todoStore.subscribe,\n    () => selector(todoStore.getSnapshot())\n  );\n}\n\n// Only re-renders when count changes, not when text changes\nfunction CountDisplay(): JSX.Element {\n  const count = useStore((s) => s.count);\n  return <div>{count}</div>;\n}',
  followUp: 'What are the gotchas with selector functions returning new object references from `useSyncExternalStore`?',
  keyTakeaway: '`useSyncExternalStore` with a store module enables shared state across components without providers, using selectors to minimize re-renders.',
},
{
  id: 49,
  title: 'How do you write a custom hook that properly handles race conditions and AbortController?',
  difficulty: 'hard',
  topic: 'hooks-state',
  subtopic: 'custom-hooks',
  answer: 'Race conditions in custom hooks occur when a slow request resolves after a newer request has already started, overwriting the UI with stale data. The robust fix uses `AbortController`: create an instance inside the effect, pass its `signal` to `fetch`, and abort it in the cleanup function. When the effect re-runs with new dependencies, the cleanup aborts the previous request, and the browser rejects the pending promise with an `AbortError` that you catch and ignore. This is more reliable than a boolean `cancelled` flag because it actually cancels the network request rather than just ignoring the response, saving bandwidth and preventing unhandled promise warnings.',
  codeExample: 'import { useState, useEffect } from \'react\';\n\ninterface UseFetchResult<T> { data: T | null; error: string | null; loading: boolean; }\n\nfunction useFetch<T>(url: string): UseFetchResult<T> {\n  const [data, setData] = useState<T | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const controller = new AbortController();\n    setLoading(true);\n    setError(null);\n\n    fetch(url, { signal: controller.signal })\n      .then((res) => {\n        if (!res.ok) throw new Error(`HTTP ${res.status}`);\n        return res.json() as Promise<T>;\n      })\n      .then((json) => { setData(json); setLoading(false); })\n      .catch((err: Error) => {\n        // Ignore abort errors — they mean a newer request replaced this one\n        if (err.name !== \'AbortError\') {\n          setError(err.message);\n          setLoading(false);\n        }\n      });\n\n    // Cleanup: abort previous request when url changes or component unmounts\n    return () => controller.abort();\n  }, [url]);\n\n  return { data, error, loading };\n}',
  followUp: 'How would you extend this hook to support caching, automatic retries, and deduplication of in-flight requests?',
  keyTakeaway: 'Use `AbortController` in custom hook `useEffect` cleanup to cancel stale fetch requests and prevent race conditions.',
},
{
  id: 50,
  title: 'Why can\'t you call hooks conditionally, and what happens internally if you do?',
  difficulty: 'hard',
  topic: 'hooks-state',
  subtopic: 'rules-of-hooks',
  answer: 'React stores hook state in a linked list (fiber node) indexed by the order hooks are called during render. On the first render, React builds this list sequentially. On subsequent renders, it walks through the same list in order, matching each hook call to its stored state by position. If a hook call is skipped due to a conditional, every hook after it shifts position by one, causing React to return the wrong state for the wrong hook — a `useState` might receive the value from a `useEffect`, leading to crashes or silent data corruption. The `eslint-plugin-react-hooks` lint rule detects and prevents this at development time.',
  codeExample: 'import { useState, useEffect } from \'react\';\n\n// BROKEN: conditional hook shifts the internal linked list\nfunction BrokenComponent({ showExtra }: { showExtra: boolean }): JSX.Element {\n  const [name, setName] = useState(\'Alice\');\n\n  // If showExtra flips from true to false, useEffect below\n  // gets the state slot that belonged to extraState\n  // if (showExtra) {\n  //   const [extraState] = useState(\'extra\'); // NEVER do this\n  // }\n\n  useEffect(() => {\n    document.title = name;\n  }, [name]);\n\n  // CORRECT: always call the hook, conditionally use the value\n  const [extraState] = useState(\'extra\');\n  const displayExtra = showExtra ? extraState : null;\n\n  return <div>{name} {displayExtra}</div>;\n}',
  followUp: 'How does the React Compiler (React Forget) handle conditional logic with hooks differently from manual hook calls?',
  keyTakeaway: 'React matches hooks to state by call order in a linked list — conditional calls shift indices and corrupt the state mapping.',
},
{
  id: 51,
  title: 'What is composition in React and why is it preferred over inheritance?',
  difficulty: 'easy',
  topic: 'patterns-architecture',
  subtopic: 'composition',
  answer: 'Composition is the pattern of building complex UIs by combining smaller, focused components together, typically by passing components as `children` or props. React favors composition over inheritance because it provides more explicit data flow and greater flexibility — you can change behavior by swapping out composed pieces rather than overriding methods in a class hierarchy. The `children` prop is the most basic form of composition, allowing any parent component to wrap arbitrary content without knowing what that content will be ahead of time.',
  codeExample: 'interface CardProps {\n  children: React.ReactNode\n  title: string\n}\n\nfunction Card({ children, title }: CardProps) {\n  return (\n    <div className="card">\n      <h2>{title}</h2>\n      {/* children can be anything — text, elements, other components */}\n      <div className="card-body">{children}</div>\n    </div>\n  )\n}\n\n// Usage: compose Card with any content\nfunction App() {\n  return (\n    <Card title="Profile">\n      <img src="/avatar.png" alt="avatar" />\n      <p>Hello, world!</p>\n    </Card>\n  )\n}',
  followUp: 'When would you use a render prop or a slot pattern instead of plain children composition?',
  keyTakeaway: 'Composition builds complex UIs from simple components via children and props, offering more flexibility than class inheritance.',
},
{
  id: 52,
  title: 'How do Higher-Order Components (HOCs) work in React?',
  difficulty: 'medium',
  topic: 'patterns-architecture',
  subtopic: 'higher-order-components',
  answer: 'A Higher-Order Component is a function that takes a component and returns a new component with enhanced behavior or additional props. HOCs do not modify the original component — they wrap it in a container component that passes through props and injects new ones. Common use cases include injecting authentication state, adding logging, or providing data from a store. The convention is to prefix the HOC name with `with` (e.g., `withAuth`) and to forward refs and hoist statics so the wrapped component behaves transparently.',
  codeExample: 'interface WithLoadingProps {\n  isLoading: boolean\n}\n\n// HOC that adds a loading spinner\nfunction withLoading<P extends object>(\n  WrappedComponent: React.ComponentType<P>\n) {\n  return function WithLoadingComponent(\n    props: P & WithLoadingProps\n  ) {\n    const { isLoading, ...rest } = props\n    if (isLoading) return <div>Loading...</div>\n    return <WrappedComponent {...(rest as P)} />\n  }\n}\n\n// Usage\ninterface UserListProps {\n  users: string[]\n}\n\nfunction UserList({ users }: UserListProps) {\n  return <ul>{users.map(u => <li key={u}>{u}</li>)}</ul>\n}\n\nconst UserListWithLoading = withLoading(UserList)',
  followUp: 'What problems can arise when you nest multiple HOCs together, and how do you debug the resulting component tree?',
  keyTakeaway: 'HOCs are functions that wrap a component to inject behavior or data without modifying the original component.',
},
{
  id: 53,
  title: 'What is the render props pattern and when is it useful?',
  difficulty: 'medium',
  topic: 'patterns-architecture',
  subtopic: 'render-props',
  answer: 'The render props pattern involves a component that takes a function as a prop (often called `render` or `children`) and calls it with internal state or logic, letting the consumer decide what to render. This inverts control: the component with the logic does not own the UI, and the parent provides the rendering function. It is useful for sharing stateful logic — like mouse tracking, intersection observation, or form validation — across components that need different visual representations. The pattern has largely been replaced by custom hooks but remains valuable when you need to share logic that involves JSX output.',
  codeExample: 'interface MousePosition {\n  x: number\n  y: number\n}\n\ninterface MouseTrackerProps {\n  children: (pos: MousePosition) => React.ReactNode\n}\n\nfunction MouseTracker({ children }: MouseTrackerProps) {\n  const [pos, setPos] = useState<MousePosition>({ x: 0, y: 0 })\n\n  const handleMouseMove = (e: React.MouseEvent) => {\n    setPos({ x: e.clientX, y: e.clientY })\n  }\n\n  return (\n    <div onMouseMove={handleMouseMove}>\n      {children(pos)}\n    </div>\n  )\n}\n\n// Usage — consumer decides the UI\nfunction App() {\n  return (\n    <MouseTracker>\n      {({ x, y }) => <p>Cursor at ({x}, {y})</p>}\n    </MouseTracker>\n  )\n}',
  followUp: 'How does the render props pattern compare to custom hooks for sharing stateful logic?',
  keyTakeaway: 'Render props pass a function as children to share logic while letting the consumer control the rendered output.',
},
{
  id: 54,
  title: 'What are compound components and how do they share implicit state?',
  difficulty: 'hard',
  topic: 'patterns-architecture',
  subtopic: 'compound-components',
  answer: 'Compound components are a set of related components that work together to form a cohesive API, sharing implicit state through React Context rather than explicit props. The parent component manages the state and exposes it via a context provider, while the child components consume that context to coordinate behavior. This pattern gives consumers full control over rendering order and composition while keeping the internal wiring hidden. Libraries like Radix UI and Headless UI use this pattern extensively for accessible, flexible component APIs.',
  codeExample: 'interface TabsContextValue {\n  activeTab: string\n  setActiveTab: (id: string) => void\n}\n\nconst TabsContext = createContext<TabsContextValue | null>(null)\n\nfunction useTabsContext() {\n  const ctx = useContext(TabsContext)\n  if (!ctx) throw new Error(\'Tab components must be used within Tabs\')\n  return ctx\n}\n\nfunction Tabs({ children, defaultTab }: { children: React.ReactNode; defaultTab: string }) {\n  const [activeTab, setActiveTab] = useState(defaultTab)\n  return (\n    <TabsContext.Provider value={{ activeTab, setActiveTab }}>\n      {children}\n    </TabsContext.Provider>\n  )\n}\n\nfunction TabButton({ id, children }: { id: string; children: React.ReactNode }) {\n  const { activeTab, setActiveTab } = useTabsContext()\n  return <button onClick={() => setActiveTab(id)} data-active={activeTab === id}>{children}</button>\n}\n\nfunction TabPanel({ id, children }: { id: string; children: React.ReactNode }) {\n  const { activeTab } = useTabsContext()\n  return activeTab === id ? <div>{children}</div> : null\n}',
  followUp: 'How would you validate that only allowed child components are used inside a compound component?',
  keyTakeaway: 'Compound components share implicit state through context, giving consumers flexible composition with coordinated behavior.',
},
{
  id: 55,
  title: 'What is the provider pattern and how does it solve prop drilling?',
  difficulty: 'easy',
  topic: 'patterns-architecture',
  subtopic: 'provider-pattern',
  answer: 'The provider pattern uses React Context to make state or functions available to any descendant component without manually passing props through every intermediate level. A provider component wraps a subtree and exposes a value, while consumers anywhere in that subtree access the value via `useContext`. This eliminates prop drilling — the problem where data must be threaded through components that do not use it themselves. The pattern is commonly used for themes, authentication state, locale settings, and feature flags.',
  codeExample: 'interface ThemeContextValue {\n  theme: \'light\' | \'dark\'\n  toggleTheme: () => void\n}\n\nconst ThemeContext = createContext<ThemeContextValue | null>(null)\n\nexport function ThemeProvider({ children }: { children: React.ReactNode }) {\n  const [theme, setTheme] = useState<\'light\' | \'dark\'>(\'light\')\n  const toggleTheme = () => setTheme(t => t === \'light\' ? \'dark\' : \'light\')\n\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  )\n}\n\n// Any deeply nested component can consume it\nfunction ThemeToggle() {\n  const ctx = useContext(ThemeContext)\n  if (!ctx) throw new Error(\'Must be inside ThemeProvider\')\n  return <button onClick={ctx.toggleTheme}>Current: {ctx.theme}</button>\n}',
  followUp: 'What happens when a context value changes — which components re-render?',
  keyTakeaway: 'The provider pattern wraps a subtree with context, making data available to any descendant without prop drilling.',
},
{
  id: 56,
  title: 'What is the difference between controlled and uncontrolled components?',
  difficulty: 'easy',
  topic: 'patterns-architecture',
  subtopic: 'controlled-uncontrolled',
  answer: 'A controlled component has its form value managed by React state — the component receives its current value via props and notifies the parent of changes through callbacks like `onChange`. An uncontrolled component stores its own state internally in the DOM, and you read the value imperatively using a `ref` when needed. Controlled components give you full programmatic control over the input (validation, formatting, conditional disabling) at the cost of more boilerplate, while uncontrolled components are simpler for basic forms where you only need the value on submission.',
  codeExample: '// Controlled: React state is the source of truth\nfunction ControlledInput() {\n  const [value, setValue] = useState(\'\')\n  return (\n    <input\n      value={value}\n      onChange={(e) => setValue(e.target.value)}\n    />\n  )\n}\n\n// Uncontrolled: DOM is the source of truth\nfunction UncontrolledInput() {\n  const inputRef = useRef<HTMLInputElement>(null)\n  const handleSubmit = () => {\n    console.log(inputRef.current?.value)\n  }\n  return (\n    <>\n      <input ref={inputRef} defaultValue="" />\n      <button onClick={handleSubmit}>Submit</button>\n    </>\n  )\n}',
  followUp: 'When would you choose uncontrolled components over controlled ones in a real application?',
  keyTakeaway: 'Controlled components derive their value from React state; uncontrolled components store their value in the DOM and are read via refs.',
},
{
  id: 57,
  title: 'How does React.lazy enable code splitting and what are its requirements?',
  difficulty: 'medium',
  topic: 'patterns-architecture',
  subtopic: 'code-splitting',
  answer: '`React.lazy` accepts a function that returns a dynamic `import()` promise and produces a component that loads the module on demand. When the lazy component is first rendered, React triggers the dynamic import, and the module is downloaded as a separate JavaScript bundle. The lazy component must be wrapped in a `Suspense` boundary that displays a fallback UI while the module is loading. `React.lazy` only supports default exports — if the module uses named exports, you must re-export it as default or use an intermediate module.',
  codeExample: 'import { Suspense, lazy } from \'react\'\n\n// Dynamic import — webpack/bundler creates a separate chunk\nconst Dashboard = lazy(() => import(\'./Dashboard\'))\nconst Settings = lazy(() => import(\'./Settings\'))\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Routes>\n        <Route path="/dashboard" element={<Dashboard />} />\n        <Route path="/settings" element={<Settings />} />\n      </Routes>\n    </Suspense>\n  )\n}\n\n// For named exports, re-export as default:\n// const Chart = lazy(() => import(\'./Charts\').then(m => ({ default: m.Chart })))',
  followUp: 'What happens if the lazy-loaded chunk fails to download — how do you handle that error?',
  keyTakeaway: '`React.lazy` combined with dynamic `import()` splits code into separate chunks that load on demand, wrapped in `Suspense` for fallback UI.',
},
{
  id: 58,
  title: 'What are React Server Components and how do they differ from Client Components?',
  difficulty: 'medium',
  topic: 'patterns-architecture',
  subtopic: 'server-components',
  answer: 'React Server Components (RSC) execute exclusively on the server and send their rendered output — a serialized component tree — to the client without including any JavaScript for that component in the client bundle. They can directly access databases, file systems, and server-only APIs. Client Components run on both server (for SSR) and client, and they include their JavaScript in the bundle for interactivity. The key distinction is that Server Components have zero client-side JavaScript cost but cannot use state, effects, or browser APIs, while Client Components can use all React hooks and handle user interaction.',
  codeExample: '// Server Component (default in Next.js App Router)\n// No "use client" directive — runs only on the server\nasync function UserProfile({ userId }: { userId: string }) {\n  // Direct database access — no API route needed\n  const user = await db.users.findById(userId)\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.bio}</p>\n      {/* Client Component for interactivity */}\n      <FollowButton userId={userId} />\n    </div>\n  )\n}\n\n// Client Component — includes JS in the bundle\n\'use client\'\nfunction FollowButton({ userId }: { userId: string }) {\n  const [following, setFollowing] = useState(false)\n  return (\n    <button onClick={() => setFollowing(!following)}>\n      {following ? \'Unfollow\' : \'Follow\'}\n    </button>\n  )\n}',
  followUp: 'Can a Server Component import and render a Client Component, and vice versa?',
  keyTakeaway: 'Server Components run only on the server with zero client JS cost, while Client Components include JavaScript for interactivity.',
},
{
  id: 59,
  title: 'How do you decide when to lift state up versus using a state management library?',
  difficulty: 'medium',
  topic: 'patterns-architecture',
  subtopic: 'lifting-state',
  answer: 'Lift state up when two or more sibling components need to share or synchronize the same piece of state — move it to their closest common ancestor and pass it down as props. This works well for localized state shared between a few components. Switch to a state management library (like Zustand, Jotai, or Redux) when the shared state spans many distant parts of the tree, when prop drilling becomes unwieldy (more than two levels), or when you need derived state, middleware, or devtools. The rule of thumb: start with local state, lift when siblings need it, and reach for a library when lifting creates excessive prop threading.',
  codeExample: '// Lift state to the common parent\nfunction SearchPage() {\n  const [query, setQuery] = useState(\'\')\n  return (\n    <div>\n      {/* Both siblings share query state */}\n      <SearchBar query={query} onQueryChange={setQuery} />\n      <SearchResults query={query} />\n    </div>\n  )\n}\n\nfunction SearchBar({ query, onQueryChange }: {\n  query: string\n  onQueryChange: (q: string) => void\n}) {\n  return <input value={query} onChange={e => onQueryChange(e.target.value)} />\n}\n\nfunction SearchResults({ query }: { query: string }) {\n  // Use query to filter/fetch results\n  return <div>Results for: {query}</div>\n}',
  followUp: 'What are the performance implications of lifting state up to a high-level ancestor that causes many children to re-render?',
  keyTakeaway: 'Lift state to the nearest common ancestor for sibling sharing; use a state management library when prop drilling exceeds two levels.',
},
{
  id: 60,
  title: 'How can you implement a state machine pattern using `useReducer`?',
  difficulty: 'medium',
  topic: 'patterns-architecture',
  subtopic: 'state-machines',
  answer: 'A state machine pattern with `useReducer` models your component as a finite set of states with defined transitions between them. The reducer function checks both the current state and the dispatched action to determine valid transitions, rejecting actions that are not valid for the current state. This prevents impossible state combinations — for example, a form cannot be both "submitting" and "idle" simultaneously. The pattern makes complex UI flows (multi-step wizards, async workflows, media players) predictable and easier to debug because every state transition is explicit.',
  codeExample: 'type FormState =\n  | { status: \'idle\' }\n  | { status: \'validating\'; data: FormData }\n  | { status: \'submitting\'; data: FormData }\n  | { status: \'success\'; result: string }\n  | { status: \'error\'; error: string }\n\ntype FormAction =\n  | { type: \'SUBMIT\'; data: FormData }\n  | { type: \'VALIDATION_PASS\' }\n  | { type: \'SUCCESS\'; result: string }\n  | { type: \'ERROR\'; error: string }\n  | { type: \'RESET\' }\n\nfunction formReducer(state: FormState, action: FormAction): FormState {\n  switch (state.status) {\n    case \'idle\':\n      if (action.type === \'SUBMIT\') return { status: \'validating\', data: action.data }\n      return state\n    case \'validating\':\n      if (action.type === \'VALIDATION_PASS\') return { status: \'submitting\', data: state.data }\n      if (action.type === \'ERROR\') return { status: \'error\', error: action.error }\n      return state\n    case \'submitting\':\n      if (action.type === \'SUCCESS\') return { status: \'success\', result: action.result }\n      if (action.type === \'ERROR\') return { status: \'error\', error: action.error }\n      return state\n    default:\n      if (action.type === \'RESET\') return { status: \'idle\' }\n      return state\n  }\n}',
  followUp: 'How does a library like XState compare to a hand-rolled reducer state machine for complex workflows?',
  keyTakeaway: 'State machines with `useReducer` model explicit transitions between finite states, preventing impossible state combinations.',
},
{
  id: 61,
  title: 'What is the slots pattern in React and how does it differ from children?',
  difficulty: 'medium',
  topic: 'patterns-architecture',
  subtopic: 'composition',
  answer: 'The slots pattern uses named props to accept multiple pieces of renderable content, giving the parent component precise control over where each piece is placed. Unlike the single `children` prop which can only fill one slot, named slots like `header`, `sidebar`, and `footer` let the layout component position content in specific locations. This pattern is common in layout components, modals, and cards where the structure is fixed but the content in each region is flexible. You can type each slot as `React.ReactNode` for maximum flexibility.',
  codeExample: 'interface PageLayoutProps {\n  header: React.ReactNode\n  sidebar: React.ReactNode\n  children: React.ReactNode\n  footer?: React.ReactNode\n}\n\nfunction PageLayout({ header, sidebar, children, footer }: PageLayoutProps) {\n  return (\n    <div className="layout">\n      <header>{header}</header>\n      <div className="main">\n        <aside>{sidebar}</aside>\n        <main>{children}</main>\n      </div>\n      {footer && <footer>{footer}</footer>}\n    </div>\n  )\n}\n\n// Usage: each slot is independently controlled\nfunction DashboardPage() {\n  return (\n    <PageLayout\n      header={<NavBar />}\n      sidebar={<FilterPanel />}\n      footer={<StatusBar />}\n    >\n      <DataGrid />\n    </PageLayout>\n  )\n}',
  followUp: 'How would you make a slot optional with a sensible default while still allowing the consumer to override it?',
  keyTakeaway: 'The slots pattern uses named props for multiple content regions, providing more precise layout control than a single children prop.',
},
{
  id: 62,
  title: 'When should you use the `\'use client\'` directive and what does it actually do?',
  difficulty: 'medium',
  topic: 'patterns-architecture',
  subtopic: 'server-components',
  answer: 'The `\'use client\'` directive marks a module as a Client Component boundary. When the bundler encounters it, every component exported from that file (and all its imports) is included in the client JavaScript bundle. You add `\'use client\'` when a component needs interactivity — `useState`, `useEffect`, event handlers, browser APIs, or third-party libraries that use these. Everything without the directive is a Server Component by default in frameworks like Next.js App Router. The directive should be placed as low in the tree as possible to keep the maximum amount of code server-only.',
  codeExample: '// LikeButton.tsx — needs interactivity, so it is a Client Component\n\'use client\'\n\nimport { useState } from \'react\'\n\ninterface LikeButtonProps {\n  initialCount: number\n}\n\nexport function LikeButton({ initialCount }: LikeButtonProps) {\n  const [count, setCount] = useState(initialCount)\n  return (\n    <button onClick={() => setCount(c => c + 1)}>\n      {count} likes\n    </button>\n  )\n}\n\n// BlogPost.tsx — Server Component (no directive)\n// Only LikeButton ships JS to the client\nasync function BlogPost({ id }: { id: string }) {\n  const post = await fetchPost(id)\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.body}</p>\n      <LikeButton initialCount={post.likes} />\n    </article>\n  )\n}',
  followUp: 'What happens if you accidentally use `useState` in a Server Component without the `\'use client\'` directive?',
  keyTakeaway: 'The `\'use client\'` directive marks a client boundary — place it as low as possible to minimize the client JavaScript bundle.',
},
{
  id: 63,
  title: 'How do you implement route-based code splitting in a React application?',
  difficulty: 'medium',
  topic: 'patterns-architecture',
  subtopic: 'code-splitting',
  answer: 'Route-based code splitting uses `React.lazy` and dynamic `import()` at the route level so each page is loaded as a separate chunk only when the user navigates to it. This is the most natural split point because users expect a brief loading time during navigation. You wrap the route tree in a `Suspense` boundary and assign each route a lazily loaded component. The bundler (webpack, Vite, Turbopack) automatically creates separate chunks for each dynamic import. For named routes, you can add webpack magic comments like `webpackChunkName` to produce readable chunk filenames.',
  codeExample: 'import { Suspense, lazy } from \'react\'\nimport { BrowserRouter, Routes, Route } from \'react-router-dom\'\n\n// Each route becomes a separate chunk\nconst Home = lazy(() => import(/* webpackChunkName: "home" */ \'./pages/Home\'))\nconst Products = lazy(() => import(/* webpackChunkName: "products" */ \'./pages/Products\'))\nconst Checkout = lazy(() => import(/* webpackChunkName: "checkout" */ \'./pages/Checkout\'))\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Suspense fallback={<div className="page-loader">Loading page...</div>}>\n        <Routes>\n          <Route path="/" element={<Home />} />\n          <Route path="/products" element={<Products />} />\n          <Route path="/checkout" element={<Checkout />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  )\n}',
  followUp: 'How can you prefetch a route\\\'s chunk before the user navigates, to eliminate the loading delay?',
  keyTakeaway: 'Route-based code splitting lazy-loads each page as a separate chunk, reducing the initial bundle size to only what the first route needs.',
},
{
  id: 64,
  title: 'How do you design a compound component API that is both flexible and type-safe?',
  difficulty: 'hard',
  topic: 'patterns-architecture',
  subtopic: 'compound-components',
  answer: 'A type-safe compound component API uses a context type that describes the shared state contract, a custom hook that throws if used outside the provider, and explicit prop interfaces for each sub-component. You attach the sub-components as static properties on the parent (e.g., `Select.Option`) to signal they belong together. Generic compound components can use TypeScript generics to propagate value types from the parent to children. The key design decision is what state to expose via context (the minimum needed for coordination) versus what to keep as local props on each sub-component.',
  codeExample: 'interface SelectContextValue<T> {\n  value: T\n  onChange: (value: T) => void\n}\n\nfunction createSelectContext<T>() {\n  return createContext<SelectContextValue<T> | null>(null)\n}\n\n// Example with string values\nconst SelectCtx = createSelectContext<string>()\n\nfunction useSelectContext() {\n  const ctx = useContext(SelectCtx)\n  if (!ctx) throw new Error(\'Select.Option must be used within Select\')\n  return ctx\n}\n\ninterface SelectProps {\n  value: string\n  onChange: (value: string) => void\n  children: React.ReactNode\n}\n\nfunction Select({ value, onChange, children }: SelectProps) {\n  return (\n    <SelectCtx.Provider value={{ value, onChange }}>\n      <div role="listbox">{children}</div>\n    </SelectCtx.Provider>\n  )\n}\n\nfunction Option({ value, children }: { value: string; children: React.ReactNode }) {\n  const { value: selected, onChange } = useSelectContext()\n  return (\n    <div role="option" aria-selected={value === selected} onClick={() => onChange(value)}>\n      {children}\n    </div>\n  )\n}\n\nSelect.Option = Option',
  followUp: 'How would you handle keyboard navigation and ARIA attributes in a compound select component?',
  keyTakeaway: 'Type-safe compound components use a typed context, a guarded custom hook, and static sub-component properties for a cohesive API.',
},
{
  id: 65,
  title: 'How does data flow from Server Components to Client Components in the RSC model?',
  difficulty: 'hard',
  topic: 'patterns-architecture',
  subtopic: 'rsc-data-flow',
  answer: 'In the RSC model, Server Components fetch data on the server and pass it to Client Components as serializable props. The data is serialized into a special RSC payload format that includes the rendered Server Component tree and the props for each Client Component boundary. Only JSON-serializable values can cross the server-client boundary — you cannot pass functions, class instances, Dates, or Symbols as props from a Server Component to a Client Component. This constraint enforces a clean unidirectional data flow: server fetches, serializes, and streams; client receives, hydrates, and makes interactive.',
  codeExample: '// Server Component — fetches data and passes serializable props\nasync function ProductPage({ id }: { id: string }) {\n  // Data fetching happens on the server\n  const product = await db.products.findById(id)\n\n  // Only serializable data crosses the boundary\n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <p>{product.description}</p>\n      {/* Props must be JSON-serializable */}\n      <AddToCartButton\n        productId={product.id}\n        price={product.price}\n        name={product.name}\n      />\n    </div>\n  )\n}\n\n// Client Component — receives serialized props\n\'use client\'\nfunction AddToCartButton({ productId, price, name }: {\n  productId: string\n  price: number\n  name: string\n}) {\n  const handleClick = () => {\n    // Client-side logic with the serialized data\n    addToCart({ productId, price, name })\n  }\n  return <button onClick={handleClick}>Add to Cart — ${price}</button>\n}',
  followUp: 'What happens if you try to pass a non-serializable value like a function from a Server Component to a Client Component?',
  keyTakeaway: 'Server Components pass only JSON-serializable props to Client Components via the RSC payload — functions and class instances cannot cross the boundary.',
},
{
  id: 66,
  title: 'How does the context selector pattern improve performance in React?',
  difficulty: 'hard',
  topic: 'patterns-architecture',
  subtopic: 'context-patterns',
  answer: 'The context selector pattern addresses the problem that any change to a context value re-renders every consumer, even if a consumer only reads a small slice of the value. The pattern splits the context into multiple smaller contexts, or uses a subscription-based approach with `useSyncExternalStore` where consumers subscribe to specific slices and only re-render when their selected value changes. Libraries like Zustand and Jotai implement this natively. Another approach is to memoize the context value and use `React.memo` on consumers, though this only prevents re-renders when props are unchanged, not when the consumed context slice is unchanged.',
  codeExample: '// Problem: all consumers re-render when ANY field changes\nconst BigContext = createContext({ user: null, theme: \'light\', locale: \'en\' })\n\n// Solution 1: Split into separate contexts\nconst UserContext = createContext<User | null>(null)\nconst ThemeContext = createContext<\'light\' | \'dark\'>(\'light\')\nconst LocaleContext = createContext<string>(\'en\')\n\n// Only ThemeToggle re-renders when theme changes\nfunction ThemeToggle() {\n  const theme = useContext(ThemeContext)\n  return <button>{theme}</button>\n}\n\n// Solution 2: Zustand selector pattern\nimport { create } from \'zustand\'\n\nconst useStore = create<StoreState>((set) => ({\n  user: null,\n  theme: \'light\',\n  locale: \'en\',\n  setTheme: (theme) => set({ theme }),\n}))\n\n// Only re-renders when theme changes\nfunction ThemeDisplay() {\n  const theme = useStore((state) => state.theme)\n  return <span>{theme}</span>\n}',
  followUp: 'How does `useSyncExternalStore` enable fine-grained subscriptions without React Context?',
  keyTakeaway: 'Context selectors prevent unnecessary re-renders by splitting contexts or using subscription-based stores that only notify consumers of their selected slice.',
},
{
  id: 67,
  title: 'How have custom hooks replaced the render props and HOC patterns?',
  difficulty: 'medium',
  topic: 'patterns-architecture',
  subtopic: 'render-props',
  answer: 'Custom hooks extract stateful logic into reusable functions that can be called directly inside any functional component, eliminating the nesting and indirection that render props and HOCs require. Where a render prop forces a function-as-children pattern and an HOC wraps the component in an extra layer, a custom hook is just a function call that returns values — no wrapper components, no extra React tree nodes, no prop-name collisions. Hooks also compose linearly (call multiple hooks sequentially) rather than nesting deeply. The main scenario where render props still have an edge is when the shared logic needs to produce JSX output as part of its contract.',
  codeExample: '// Before: Render prop pattern (nested, harder to read)\nfunction App() {\n  return (\n    <WindowSize>\n      {({ width, height }) => (\n        <MousePosition>\n          {({ x, y }) => (\n            <div>Window: {width}x{height}, Mouse: {x},{y}</div>\n          )}\n        </MousePosition>\n      )}\n    </WindowSize>\n  )\n}\n\n// After: Custom hooks (flat, composable)\nfunction useWindowSize() {\n  const [size, setSize] = useState({ width: 0, height: 0 })\n  useEffect(() => {\n    const handler = () => setSize({ width: window.innerWidth, height: window.innerHeight })\n    window.addEventListener(\'resize\', handler)\n    handler()\n    return () => window.removeEventListener(\'resize\', handler)\n  }, [])\n  return size\n}\n\nfunction App() {\n  const { width, height } = useWindowSize()\n  const { x, y } = useMousePosition()\n  return <div>Window: {width}x{height}, Mouse: {x},{y}</div>\n}',
  followUp: 'Are there any cases where you would still prefer render props or HOCs over custom hooks?',
  keyTakeaway: 'Custom hooks replaced render props and HOCs by extracting stateful logic into simple, composable functions without wrapper nesting.',
},
{
  id: 68,
  title: 'What are the trade-offs of HOCs versus custom hooks in modern React?',
  difficulty: 'medium',
  topic: 'patterns-architecture',
  subtopic: 'higher-order-components',
  answer: 'HOCs add a wrapper component to the React tree, which can obscure the component hierarchy in DevTools and cause prop-name collisions when multiple HOCs inject overlapping props. They also lose static methods and ref forwarding unless you explicitly handle them. Custom hooks avoid these problems — they run inside the component with no extra tree nodes, return explicitly named values (no collisions), and naturally compose. However, HOCs still have value for cross-cutting concerns in class components, for wrapping third-party components you cannot modify, and when you need to intercept rendering (e.g., conditionally returning a fallback UI before the wrapped component runs).',
  codeExample: '// HOC: wrapper adds a tree node, props can collide\nconst EnhancedComponent = withAuth(withTheme(withLogger(MyComponent)))\n// DevTools shows: <WithAuth><WithTheme><WithLogger><MyComponent /></WithLogger></WithTheme></WithAuth>\n\n// Hooks: flat composition, no extra tree nodes\nfunction MyComponent() {\n  const { user, isAuthenticated } = useAuth()\n  const { theme } = useTheme()\n  useLogger(\'MyComponent\')\n\n  if (!isAuthenticated) return <LoginPrompt />\n  return <div className={theme}>Hello, {user.name}</div>\n}\n// DevTools shows: <MyComponent />',
  followUp: 'How would you migrate an existing HOC-based codebase to custom hooks incrementally?',
  keyTakeaway: 'Custom hooks are preferred over HOCs for flat composition and explicit naming, but HOCs remain useful for wrapping class components and intercepting renders.',
},
{
  id: 69,
  title: 'How do Suspense boundaries work for lazy-loaded components?',
  difficulty: 'easy',
  topic: 'patterns-architecture',
  subtopic: 'lazy-loading',
  answer: 'A `Suspense` boundary catches the promise thrown by a lazy-loaded (or data-fetching) component and renders a `fallback` UI until the promise resolves. You can nest multiple `Suspense` boundaries at different levels of the tree to create granular loading states — for example, a page-level boundary for route transitions and a component-level boundary for a specific widget. When the lazy component finishes loading, React replaces the fallback with the actual content in a single commit. If the promise rejects, you need an `ErrorBoundary` above or around the `Suspense` to catch the failure.',
  codeExample: 'import { Suspense, lazy } from \'react\'\n\nconst HeavyChart = lazy(() => import(\'./HeavyChart\'))\nconst Comments = lazy(() => import(\'./Comments\'))\n\nfunction Dashboard() {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      {/* Page-level skeleton */}\n      <Suspense fallback={<ChartSkeleton />}>\n        <HeavyChart />\n      </Suspense>\n\n      {/* Independent loading state for comments */}\n      <Suspense fallback={<CommentsSkeleton />}>\n        <Comments />\n      </Suspense>\n    </div>\n  )\n}\n\n// Error boundary wraps Suspense to catch load failures\nfunction SafeDashboard() {\n  return (\n    <ErrorBoundary fallback={<p>Failed to load dashboard.</p>}>\n      <Dashboard />\n    </ErrorBoundary>\n  )\n}',
  followUp: 'How does `Suspense` work with concurrent features like `startTransition` to avoid showing fallbacks for fast loads?',
  keyTakeaway: 'Suspense boundaries render fallback UI while lazy components load, and can be nested for granular loading states at different tree levels.',
},
{
  id: 70,
  title: 'How should you handle nested context providers to avoid provider hell?',
  difficulty: 'medium',
  topic: 'patterns-architecture',
  subtopic: 'provider-pattern',
  answer: 'Provider hell occurs when you stack many context providers at the root of your app, creating a deeply nested pyramid of JSX. The primary solution is to compose providers into a single wrapper component that takes `children` and renders all providers in order. Another approach is to use a utility function that reduces an array of providers into nested elements. You should also evaluate whether each provider truly needs to wrap the entire app — providers should be scoped to the smallest subtree that needs them. Libraries like Zustand and Jotai avoid this problem entirely by using module-level stores instead of React Context.',
  codeExample: 'interface ProviderProps {\n  children: React.ReactNode\n}\n\n// Solution: Compose all providers into a single component\nfunction AppProviders({ children }: ProviderProps) {\n  return (\n    <ThemeProvider>\n      <AuthProvider>\n        <LocaleProvider>\n          <NotificationProvider>\n            {children}\n          </NotificationProvider>\n        </LocaleProvider>\n      </AuthProvider>\n    </ThemeProvider>\n  )\n}\n\n// Usage — clean root\nfunction App() {\n  return (\n    <AppProviders>\n      <Router />\n    </AppProviders>\n  )\n}\n\n// Alternative: utility to reduce providers\nfunction ComposeProviders({ providers, children }: {\n  providers: Array<React.ComponentType<ProviderProps>>\n  children: React.ReactNode\n}) {\n  return providers.reduceRight(\n    (acc, Provider) => <Provider>{acc}</Provider>,\n    children\n  )\n}',
  followUp: 'Does the order of nested providers matter, and what bugs can incorrect ordering cause?',
  keyTakeaway: 'Compose multiple providers into a single wrapper component and scope providers to the smallest subtree that needs them.',
},
{
  id: 71,
  title: 'When should you use controlled versus uncontrolled components in complex forms?',
  difficulty: 'hard',
  topic: 'patterns-architecture',
  subtopic: 'controlled-uncontrolled',
  answer: 'Use controlled components when you need real-time validation, conditional field visibility based on input values, computed fields, or programmatic value manipulation (e.g., formatting a phone number as the user types). Use uncontrolled components when you have simple forms where you only need values on submission, when integrating with non-React libraries that manage their own DOM state, or when performance is critical for forms with many fields — since uncontrolled components do not trigger re-renders on every keystroke. Libraries like React Hook Form use an uncontrolled-first approach with refs for performance while providing a controlled-like API through subscriptions.',
  codeExample: '// Controlled: real-time validation and computed fields\nfunction PaymentForm() {\n  const [cardNumber, setCardNumber] = useState(\'\')\n  const [cardType, setCardType] = useState<string | null>(null)\n\n  const handleCardChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const raw = e.target.value.replace(/\\D/g, \'\')\n    const formatted = raw.replace(/(\\d{4})/g, \'$1 \').trim()\n    setCardNumber(formatted)\n    setCardType(detectCardType(raw))\n  }\n\n  return (\n    <div>\n      <input value={cardNumber} onChange={handleCardChange} />\n      {cardType && <span>Card type: {cardType}</span>}\n    </div>\n  )\n}\n\n// Uncontrolled: simple form, values read on submit\nfunction FeedbackForm() {\n  const formRef = useRef<HTMLFormElement>(null)\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault()\n    const data = new FormData(formRef.current!)\n    submitFeedback(Object.fromEntries(data))\n  }\n  return (\n    <form ref={formRef} onSubmit={handleSubmit}>\n      <input name="message" defaultValue="" />\n      <button type="submit">Send</button>\n    </form>\n  )\n}',
  followUp: 'How does React Hook Form achieve controlled-like features while keeping fields uncontrolled for performance?',
  keyTakeaway: 'Use controlled components for real-time validation and dynamic UIs; use uncontrolled components for simple forms and performance-sensitive scenarios.',
},
{
  id: 72,
  title: 'What is the RSC serialization boundary and what types can cross it?',
  difficulty: 'hard',
  topic: 'patterns-architecture',
  subtopic: 'rsc-data-flow',
  answer: 'The RSC serialization boundary is the point where data passes from a Server Component to a Client Component via props. Only values that can be serialized into the RSC wire format are allowed: JSON primitives (strings, numbers, booleans, null), plain objects and arrays of serializable values, React elements (JSX), and special React types like `Suspense` and `lazy`. Functions, class instances, `Date` objects, `Map`, `Set`, `RegExp`, and Symbols cannot cross the boundary. Server Actions (functions annotated with `\'use server\'`) are an exception — they serialize to a reference that the client can call, creating an RPC-like bridge back to the server.',
  codeExample: '// These types CAN cross the boundary:\nasync function ServerParent() {\n  const data = {\n    name: \'Alice\',            // string\n    age: 30,                  // number\n    active: true,             // boolean\n    tags: [\'a\', \'b\'],         // array of primitives\n    nested: { x: 1 },        // plain object\n    element: <b>bold</b>,     // React element\n  }\n  return <ClientChild {...data} />\n}\n\n// These types CANNOT cross:\n// onClick: () => {} — function\n// createdAt: new Date() — Date instance\n// pattern: /\\d+/ — RegExp\n// items: new Map() — Map\n\n// Server Actions are the exception:\n\'use server\'\nasync function submitForm(data: FormData) {\n  // This function reference CAN be passed to a Client Component\n}',
  followUp: 'How would you pass a Date value from a Server Component to a Client Component?',
  keyTakeaway: 'Only JSON-serializable values, React elements, and Server Action references can cross the RSC boundary — no functions, Dates, Maps, or class instances.',
},
{
  id: 73,
  title: 'How do you decide which components should be Server Components versus Client Components?',
  difficulty: 'easy',
  topic: 'patterns-architecture',
  subtopic: 'server-components',
  answer: 'Start by making everything a Server Component by default since they have zero client JavaScript cost. Move a component to the client only when it needs interactivity (`useState`, `useEffect`, event handlers), browser-only APIs (`window`, `localStorage`, `IntersectionObserver`), or third-party libraries that use these. Push the `\'use client\'` boundary as deep into the tree as possible — for example, make the entire blog post a Server Component but make just the like button a Client Component. Static content, data fetching, and layout components should almost always be Server Components.',
  codeExample: '// Server Component — no interactivity needed\nasync function BlogPage({ slug }: { slug: string }) {\n  const post = await getPost(slug)\n  const comments = await getComments(post.id)\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <FormattedDate date={post.publishedAt} />\n      <div>{post.content}</div>\n      <CommentList comments={comments} />\n      {/* Only this small piece is a Client Component */}\n      <CommentForm postId={post.id} />\n    </article>\n  )\n}\n\n// \'use client\' — needs form state and event handlers\n// Only CommentForm JS is shipped to the browser',
  followUp: 'Can a Client Component render Server Components as its children, and how does that work?',
  keyTakeaway: 'Default to Server Components and only add `\'use client\'` where interactivity is required, keeping the boundary as deep as possible.',
},
{
  id: 74,
  title: 'How do you handle error boundaries alongside Suspense in a code-split architecture?',
  difficulty: 'hard',
  topic: 'patterns-architecture',
  subtopic: 'lazy-loading',
  answer: 'Error boundaries and Suspense boundaries serve complementary roles: Suspense handles the pending state (loading fallback) while error boundaries handle the rejected state (failure fallback). In a code-split architecture, you should place an error boundary above or wrapping each Suspense boundary so that if a chunk fails to download (network error, 404), the error boundary catches the promise rejection and shows a recovery UI like a retry button. Without an error boundary, a failed lazy import causes the entire app to crash. You can create a combined component that provides both boundaries with a single wrapper for convenience.',
  codeExample: 'import { Component, Suspense, lazy } from \'react\'\n\n// Reusable error boundary with retry\ninterface Props { children: React.ReactNode; fallback: React.ReactNode }\ninterface State { hasError: boolean }\n\nclass ChunkErrorBoundary extends Component<Props, State> {\n  state: State = { hasError: false }\n\n  static getDerivedStateFromError(): State {\n    return { hasError: true }\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div>\n          <p>Failed to load.</p>\n          <button onClick={() => this.setState({ hasError: false })}>Retry</button>\n        </div>\n      )\n    }\n    return this.props.children\n  }\n}\n\n// Combined: error boundary wraps Suspense\nconst HeavyFeature = lazy(() => import(\'./HeavyFeature\'))\n\nfunction FeatureSection() {\n  return (\n    <ChunkErrorBoundary fallback={<p>Error</p>}>\n      <Suspense fallback={<p>Loading feature...</p>}>\n        <HeavyFeature />\n      </Suspense>\n    </ChunkErrorBoundary>\n  )\n}',
  followUp: 'How would you implement automatic retry with exponential backoff for failed chunk downloads?',
  keyTakeaway: 'Wrap Suspense boundaries with error boundaries so failed chunk downloads show recovery UI instead of crashing the app.',
},
{
  id: 75,
  title: 'How do you handle async data fetching in Server Components without `useEffect`?',
  difficulty: 'hard',
  topic: 'patterns-architecture',
  subtopic: 'server-components',
  answer: 'Server Components are async functions that can use `await` directly in the component body, eliminating the need for `useEffect`, loading state, or data-fetching libraries on the client. You simply `await` your database query, API call, or file read at the top of the component function and use the result in JSX. React and the framework handle streaming the rendered output to the client as data becomes available. This colocation of data fetching and rendering removes the waterfall problem of client-side fetching, since the server can execute all data fetches in parallel or sequentially before sending the final HTML.',
  codeExample: '// Server Component — async/await directly in the component\nasync function TeamPage({ teamId }: { teamId: string }) {\n  // Parallel data fetching on the server\n  const [team, members, recentActivity] = await Promise.all([\n    fetchTeam(teamId),\n    fetchMembers(teamId),\n    fetchActivity(teamId),\n  ])\n\n  return (\n    <div>\n      <h1>{team.name}</h1>\n      <p>{team.description}</p>\n\n      <section>\n        <h2>Members ({members.length})</h2>\n        <ul>\n          {members.map(m => <li key={m.id}>{m.name}</li>)}\n        </ul>\n      </section>\n\n      <section>\n        <h2>Recent Activity</h2>\n        {recentActivity.map(a => (\n          <ActivityItem key={a.id} activity={a} />\n        ))}\n      </section>\n    </div>\n  )\n}\n\n// No useEffect, no loading state, no client-side fetch library needed',
  followUp: 'How does streaming SSR with Suspense improve the perceived performance of Server Component data fetching?',
  keyTakeaway: 'Server Components use `await` directly in the component body for data fetching, eliminating client-side loading states and fetch waterfalls.',
},
{
  id: 76,
  title: 'What does `React.memo` do and how does its default comparison work?',
  difficulty: 'easy',
  topic: 'performance-advanced',
  subtopic: 'react-memo',
  answer: '`React.memo` is a higher-order component that memoizes a functional component, preventing re-renders when its props have not changed. By default it performs a shallow comparison of each prop using `Object.is`, meaning it compares primitive values directly and checks object references for referential equality. If a parent passes a new object or function reference on every render, `React.memo` will not prevent the child from re-rendering unless you stabilize those references with `useMemo` or `useCallback`. You can also pass a custom comparison function as the second argument for more granular control.',
  codeExample: 'import { memo } from \'react\';\n\ninterface UserCardProps {\n  name: string;\n  age: number;\n}\n\n// Default shallow comparison — re-renders only if name or age changes\nconst UserCard = memo(function UserCard({ name, age }: UserCardProps) {\n  console.log(\'UserCard rendered\');\n  return <div>{name} — {age}</div>;\n});\n\n// Custom comparator — only re-render when name changes\nconst UserCardCustom = memo(\n  function UserCardCustom({ name, age }: UserCardProps) {\n    return <div>{name} — {age}</div>;\n  },\n  (prev, next) => prev.name === next.name\n);',
  followUp: 'When would a custom comparison function in `React.memo` actually hurt performance instead of helping?',
  keyTakeaway: '`React.memo` skips re-renders when props are shallowly equal, but unstable object or function references defeat it.',
},
{
  id: 77,
  title: 'What are the most common causes of unnecessary re-renders in React?',
  difficulty: 'medium',
  topic: 'performance-advanced',
  subtopic: 're-renders',
  answer: 'The most common causes are: creating new object or array literals in JSX props on every render, defining inline callback functions that produce new references each time, updating state in a parent component which forces all children to re-render, passing an unstable context value that changes reference on every render, and using index-based keys in lists that cause reconciliation mismatches. Each of these forces React to treat props as changed during its shallow comparison. The fix typically involves hoisting stable references outside the render path, memoizing with `useMemo`/`useCallback`, splitting contexts into smaller pieces, or wrapping children with `React.memo`.',
  codeExample: '// BAD — new object and function on every render\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  return (\n    <Child\n      style={{ color: \'red\' }}        // new object every render\n      onClick={() => setCount(c => c + 1)} // new function every render\n    />\n  );\n}\n\n// GOOD — stable references\nconst stableStyle = { color: \'red\' };\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const handleClick = useCallback(() => setCount(c => c + 1), []);\n  return <Child style={stableStyle} onClick={handleClick} />;\n}',
  followUp: 'How does React\'s reconciliation algorithm decide whether a component needs to re-render versus unmount and remount?',
  keyTakeaway: 'Unstable object references, inline callbacks, parent state changes, and context value churn are the primary causes of unnecessary re-renders.',
},
{
  id: 78,
  title: 'When is `useMemo` actually worth using, and when does it add unnecessary overhead?',
  difficulty: 'medium',
  topic: 'performance-advanced',
  subtopic: 'useMemo-useCallback',
  answer: '`useMemo` is worthwhile when the computation it guards is expensive (complex filtering, sorting, or transformations on large datasets), when it stabilizes an object reference passed to a memoized child so `React.memo` can skip re-renders, or when it prevents recreating a value consumed by other hooks in their dependency arrays. It adds unnecessary overhead when the computation is trivial — like simple arithmetic or short string concatenation — because the cost of comparing dependencies and caching exceeds the cost of recomputing. Over-memoization clutters code, increases memory usage for cached values, and can introduce subtle bugs if the dependency array is wrong.',
  codeExample: '// GOOD use — expensive computation\nconst sortedItems = useMemo(() => {\n  return items\n    .filter(item => item.active)\n    .sort((a, b) => a.score - b.score);\n}, [items]);\n\n// GOOD use — stabilize reference for memoized child\nconst chartData = useMemo(() => ({\n  labels: data.map(d => d.label),\n  values: data.map(d => d.value),\n}), [data]);\n\n// BAD use — trivial computation, overhead exceeds savings\nconst fullName = useMemo(\n  () => `${first} ${last}`,\n  [first, last]\n); // just do: const fullName = `${first} ${last}`;',
  followUp: 'How does the React compiler (React Forget) aim to eliminate the need for manual `useMemo` and `useCallback`?',
  keyTakeaway: 'Use `useMemo` for expensive computations and reference stabilization — skip it for trivial calculations where the overhead exceeds the savings.',
},
{
  id: 79,
  title: 'How does `useTransition` work and when should you use it?',
  difficulty: 'medium',
  topic: 'performance-advanced',
  subtopic: 'useTransition',
  answer: '`useTransition` returns a tuple of `[isPending, startTransition]` that lets you mark state updates as non-urgent transitions. Updates inside `startTransition` are rendered at a lower priority, so React can interrupt them to handle more urgent updates like user input without blocking the UI. The `isPending` boolean is `true` while the transition is in progress, which you can use to show a loading indicator. This is ideal for scenarios where a state change triggers an expensive re-render — like filtering a large list or navigating between tabs — and you want to keep the interface responsive while the heavy work happens in the background.',
  codeExample: 'import { useState, useTransition } from \'react\';\n\nfunction SearchPage({ items }: { items: string[] }) {\n  const [query, setQuery] = useState(\'\');\n  const [filtered, setFiltered] = useState(items);\n  const [isPending, startTransition] = useTransition();\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setQuery(e.target.value); // urgent — update input immediately\n    startTransition(() => {\n      // non-urgent — filter can be deferred\n      setFiltered(items.filter(item =>\n        item.toLowerCase().includes(e.target.value.toLowerCase())\n      ));\n    });\n  };\n\n  return (\n    <div>\n      <input value={query} onChange={handleChange} />\n      {isPending && <span>Filtering...</span>}\n      <ul>{filtered.map(item => <li key={item}>{item}</li>)}</ul>\n    </div>\n  );\n}',
  followUp: 'What happens if a higher-priority update arrives while a transition is mid-render — does React discard the in-progress work?',
  keyTakeaway: '`useTransition` marks state updates as non-urgent so React can keep the UI responsive by deferring expensive re-renders.',
},
{
  id: 80,
  title: 'What is the `use()` hook in React 19 and how does it differ from `useEffect` for data fetching?',
  difficulty: 'hard',
  topic: 'performance-advanced',
  subtopic: 'react-19-use',
  answer: 'The `use()` hook in React 19 can unwrap promises and context values directly inside a component\'s render function. When passed a promise, `use()` suspends the component until the promise resolves, integrating naturally with Suspense boundaries for loading states. Unlike `useEffect`, which runs after paint and requires managing loading/error state manually, `use()` makes the data available synchronously during render once resolved. Critically, `use()` can be called conditionally (inside `if` blocks or loops), breaking the rules-of-hooks constraint that applies to all other hooks — this is because it is designed as a special primitive that integrates with React\'s Suspense mechanism rather than the fiber hook queue.',
  codeExample: 'import { use, Suspense } from \'react\';\n\n// use() unwraps the promise — component suspends until resolved\nfunction UserProfile({ userPromise }: { userPromise: Promise<User> }) {\n  const user = use(userPromise);\n  return <h1>{user.name}</h1>;\n}\n\n// Can be called conditionally — unlike other hooks\nfunction MaybeUser({ userPromise, show }: {\n  userPromise: Promise<User>;\n  show: boolean;\n}) {\n  if (!show) return <p>Hidden</p>;\n  const user = use(userPromise); // valid inside conditional\n  return <h1>{user.name}</h1>;\n}\n\n// Parent provides the promise and Suspense boundary\nfunction App() {\n  const userPromise = fetchUser(1); // create promise outside render\n  return (\n    <Suspense fallback={<p>Loading...</p>}>\n      <UserProfile userPromise={userPromise} />\n    </Suspense>\n  );\n}',
  followUp: 'What happens if you create the promise inside the render function instead of outside it — does `use()` still work correctly?',
  keyTakeaway: 'React 19\'s `use()` hook unwraps promises during render with Suspense integration and can be called conditionally unlike other hooks.',
},
{
  id: 81,
  title: 'How does the React Profiler API help identify performance bottlenecks?',
  difficulty: 'medium',
  topic: 'performance-advanced',
  subtopic: 'profiler',
  answer: 'The `<Profiler>` component measures the rendering cost of its subtree by invoking an `onRender` callback after each commit. The callback receives the component id, the render phase (mount or update), actual render duration, base render duration (time without memoization), start and commit times, and the set of interactions that triggered the render. In React DevTools, the Profiler tab provides a flame graph and ranked chart view that visually highlight which components took the longest to render. You can use this data to identify components that re-render too often or take too long, then apply targeted optimizations like `React.memo`, `useMemo`, or structural changes.',
  codeExample: 'import { Profiler, ProfilerOnRenderCallback } from \'react\';\n\nconst onRender: ProfilerOnRenderCallback = (\n  id,\n  phase,\n  actualDuration,\n  baseDuration,\n  startTime,\n  commitTime\n) => {\n  console.log(`[${id}] ${phase} — actual: ${actualDuration.toFixed(2)}ms, base: ${baseDuration.toFixed(2)}ms`);\n};\n\nfunction App() {\n  return (\n    <Profiler id="Dashboard" onRender={onRender}>\n      <Dashboard />\n    </Profiler>\n  );\n}\n\n// Nest profilers to measure specific subtrees\nfunction Dashboard() {\n  return (\n    <>\n      <Profiler id="Chart" onRender={onRender}><Chart /></Profiler>\n      <Profiler id="Table" onRender={onRender}><Table /></Profiler>\n    </>\n  );\n}',
  followUp: 'What is the difference between actual duration and base duration in the Profiler callback?',
  keyTakeaway: 'The Profiler API and DevTools flame graph reveal which components render most frequently and expensively to guide targeted optimization.',
},
{
  id: 82,
  title: 'What is React\'s concurrent rendering model and how does it differ from synchronous rendering?',
  difficulty: 'hard',
  topic: 'performance-advanced',
  subtopic: 'concurrent-features',
  answer: 'In synchronous (legacy) rendering, once React starts rendering a tree update it must finish the entire pass before yielding back to the browser, which can block user input and cause jank on expensive renders. Concurrent rendering allows React to prepare multiple versions of the UI simultaneously, pause work on a low-priority update to handle urgent interactions, and resume or discard partially completed renders. It uses a cooperative scheduling model that yields to the browser between work units, keeping the main thread responsive. Concurrent mode is not a flag you toggle — it is enabled automatically when you use concurrent features like `useTransition`, `useDeferredValue`, or Suspense for data fetching with `createRoot`.',
  codeExample: '// Concurrent rendering is enabled by using createRoot\nimport { createRoot } from \'react-dom/client\';\n\n// This enables concurrent features automatically\nconst root = createRoot(document.getElementById(\'root\')!);\nroot.render(<App />);\n\n// Legacy synchronous rendering — does NOT support concurrent features\n// import { render } from \'react-dom\';\n// render(<App />, document.getElementById(\'root\'));\n\n// With concurrent rendering, React can:\n// 1. Interrupt low-priority renders to handle urgent input\n// 2. Prepare multiple UI states in memory\n// 3. Yield to the browser between work units\n// 4. Discard stale renders that are no longer needed',
  followUp: 'What is time slicing in the context of concurrent rendering, and how does React decide when to yield to the browser?',
  keyTakeaway: 'Concurrent rendering lets React interrupt, pause, and discard renders to keep the UI responsive — unlike synchronous rendering which blocks until complete.',
},
{
  id: 83,
  title: 'How do React 19 form Actions work and what problem do they solve?',
  difficulty: 'hard',
  topic: 'performance-advanced',
  subtopic: 'react-19-actions',
  answer: 'React 19 introduces the ability to pass async functions directly to the `action` prop on `<form>` elements. When the form is submitted, React calls the action function with the `FormData` object, automatically manages the pending state, and handles errors through error boundaries. This eliminates the boilerplate of manually preventing default submission, tracking loading state with `useState`, and handling errors in try/catch blocks. Actions integrate with `useActionState` for progressive enhancement and `useFormStatus` for pending indicators, and they work with both client and server environments — server actions run on the server and are referenced by a special identifier.',
  codeExample: 'async function submitForm(formData: FormData) {\n  const name = formData.get(\'name\') as string;\n  await saveUser({ name });\n}\n\n// React 19 — pass async function directly to action\nfunction SignupForm() {\n  return (\n    <form action={submitForm}>\n      <input name="name" required />\n      <button type="submit">Sign Up</button>\n    </form>\n  );\n}\n\n// Before React 19 — manual boilerplate\nfunction SignupFormOld() {\n  const [isPending, setIsPending] = useState(false);\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setIsPending(true);\n    try {\n      const formData = new FormData(e.currentTarget as HTMLFormElement);\n      await saveUser({ name: formData.get(\'name\') as string });\n    } finally {\n      setIsPending(false);\n    }\n  };\n  return <form onSubmit={handleSubmit}>...</form>;\n}',
  followUp: 'How do server actions differ from client actions in terms of where the code executes and how they are referenced?',
  keyTakeaway: 'React 19 form Actions let you pass async functions to `<form action>`, automatically handling pending state and errors without manual boilerplate.',
},
{
  id: 84,
  title: 'How does `useDeferredValue` work and how does it compare to debouncing?',
  difficulty: 'hard',
  topic: 'performance-advanced',
  subtopic: 'useDeferredValue',
  answer: '`useDeferredValue` accepts a value and returns a deferred copy that lags behind the original during urgent updates. When the original value changes, React first renders with the stale deferred value (keeping the UI responsive), then schedules a background re-render with the updated value. Unlike debouncing, which delays execution by a fixed time and can feel sluggish, `useDeferredValue` is frame-aware — React renders the deferred update as soon as the main thread is idle, making it as fast as possible without blocking interactions. The deferred value catches up immediately on idle frames and has no fixed timeout. It pairs well with `React.memo` on the expensive child, since the deferred value stays referentially stable during the urgent render.',
  codeExample: 'import { useState, useDeferredValue, memo } from \'react\';\n\n// Expensive list component — memoized so it skips re-render\n// when deferredQuery hasn\'t changed yet\nconst SearchResults = memo(function SearchResults({ query }: { query: string }) {\n  const results = expensiveFilter(allItems, query);\n  return <ul>{results.map(r => <li key={r.id}>{r.name}</li>)}</ul>;\n});\n\nfunction SearchPage() {\n  const [query, setQuery] = useState(\'\');\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n\n  return (\n    <div>\n      <input value={query} onChange={e => setQuery(e.target.value)} />\n      <div style={{ opacity: isStale ? 0.6 : 1 }}>\n        <SearchResults query={deferredQuery} />\n      </div>\n    </div>\n  );\n}',
  followUp: 'When would you choose `useDeferredValue` over `useTransition`, and can they be used together?',
  keyTakeaway: '`useDeferredValue` defers a value update to a background render without a fixed timeout, unlike debouncing which always waits a set delay.',
},
{
  id: 85,
  title: 'How does `useOptimistic` work in React 19 for optimistic UI updates?',
  difficulty: 'hard',
  topic: 'performance-advanced',
  subtopic: 'useOptimistic',
  answer: '`useOptimistic` accepts the current state and an updater function, returning a tuple of `[optimisticState, addOptimistic]`. When you call `addOptimistic` with a payload, the updater function merges it into the current state immediately, giving users instant feedback before the server responds. Once the async action (like a form Action) resolves or rejects, React automatically reverts the optimistic state back to the actual state. This eliminates the manual pattern of temporarily mutating state, tracking pending operations, and rolling back on failure. It integrates seamlessly with React 19 Actions — the optimistic state automatically resets when the parent action completes.',
  codeExample: 'import { useOptimistic } from \'react\';\n\ninterface Message { text: string; sending?: boolean }\n\nfunction Chat({ messages, sendMessage }: {\n  messages: Message[];\n  sendMessage: (text: string) => Promise<void>;\n}) {\n  const [optimisticMessages, addOptimistic] = useOptimistic(\n    messages,\n    (state: Message[], newText: string) => [\n      ...state,\n      { text: newText, sending: true },\n    ]\n  );\n\n  async function handleSubmit(formData: FormData) {\n    const text = formData.get(\'message\') as string;\n    addOptimistic(text); // instantly show the message\n    await sendMessage(text); // server call — reverts on failure\n  }\n\n  return (\n    <form action={handleSubmit}>\n      {optimisticMessages.map((msg, i) => (\n        <p key={i} style={{ opacity: msg.sending ? 0.6 : 1 }}>{msg.text}</p>\n      ))}\n      <input name="message" />\n      <button type="submit">Send</button>\n    </form>\n  );\n}',
  followUp: 'What happens to the optimistic state if the async action throws an error — does React roll back automatically?',
  keyTakeaway: '`useOptimistic` provides instant UI feedback by applying temporary state changes that automatically revert when the async action completes.',
},
{
  id: 86,
  title: 'What strategies prevent a context value change from re-rendering every consumer?',
  difficulty: 'medium',
  topic: 'performance-advanced',
  subtopic: 're-renders',
  answer: 'When a context value changes, every component that calls `useContext` on that context re-renders, regardless of whether it uses the changed portion of the value. The main strategies to prevent this are: split large contexts into smaller, focused contexts so consumers only subscribe to the data they need; memoize the context value object with `useMemo` so its reference only changes when the underlying data changes; use a state management library like Zustand with selectors that only trigger re-renders when the selected slice changes; or apply the "children as props" pattern where the provider wraps `children` rather than directly rendering expensive subtrees, so those subtrees are not re-created when provider state changes.',
  codeExample: '// BAD — single context forces all consumers to re-render\nconst AppContext = createContext<{ user: User; theme: Theme }>(null!);\n\n// GOOD — split into focused contexts\nconst UserContext = createContext<User>(null!);\nconst ThemeContext = createContext<Theme>(null!);\n\n// GOOD — memoize the value to stabilize the reference\nfunction UserProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User>(defaultUser);\n  const value = useMemo(() => ({ user, setUser }), [user]);\n  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;\n}\n\n// GOOD — children-as-props pattern\nfunction ThemeProvider({ children }: { children: ReactNode }) {\n  const [theme, setTheme] = useState<Theme>(\'dark\');\n  // children is a stable reference from the parent — won\'t re-render\n  return <ThemeContext.Provider value={theme}>{children}</ThemeContext.Provider>;\n}',
  followUp: 'Why does `React.memo` on a context consumer not prevent re-renders caused by context value changes?',
  keyTakeaway: 'Split contexts, memoize provider values, use selectors, or apply children-as-props to prevent unnecessary re-renders from context changes.',
},
{
  id: 87,
  title: 'How does `useFormStatus` work and where must it be used?',
  difficulty: 'medium',
  topic: 'performance-advanced',
  subtopic: 'useFormStatus',
  answer: '`useFormStatus` is a React 19 hook that returns the pending status of the nearest parent `<form>` that uses an action. It provides `{ pending, data, method, action }` where `pending` is `true` while the form action is executing. The critical constraint is that `useFormStatus` must be called from a component rendered inside the `<form>` element — it does not work in the same component that renders the form. This is because it reads the status from the form context provided by the `<form>` element, similar to how `useContext` works. It enables you to build reusable submit button components that automatically disable themselves and show loading indicators during submission.',
  codeExample: 'import { useFormStatus } from \'react-dom\';\n\n// Must be a child component INSIDE the <form>\nfunction SubmitButton() {\n  const { pending } = useFormStatus();\n  return (\n    <button type="submit" disabled={pending}>\n      {pending ? \'Saving...\' : \'Save\'}\n    </button>\n  );\n}\n\n// This will NOT work — useFormStatus is in the same component as <form>\n// function BrokenForm() {\n//   const { pending } = useFormStatus(); // always returns pending: false\n//   return <form action={save}><button>{pending ? \'...\' : \'Save\'}</button></form>;\n// }\n\nasync function saveData(formData: FormData) {\n  await fetch(\'/api/save\', { method: \'POST\', body: formData });\n}\n\nfunction MyForm() {\n  return (\n    <form action={saveData}>\n      <input name="title" />\n      <SubmitButton /> {/* useFormStatus works here */}\n    </form>\n  );\n}',
  followUp: 'Can you use `useFormStatus` to access the form data being submitted, and what would you use that for?',
  keyTakeaway: '`useFormStatus` reads the pending state of a parent `<form>` action — it must be called in a child component, not in the form component itself.',
},
{
  id: 88,
  title: 'When should you avoid using `React.memo` and what are the tradeoffs?',
  difficulty: 'medium',
  topic: 'performance-advanced',
  subtopic: 'react-memo',
  answer: 'You should avoid `React.memo` when the component almost always receives different props on every render — the shallow comparison cost is wasted because it will never bail out. Other cases to skip it: leaf components that render cheaply (a simple `<span>` or `<div>` with text), components that accept `children` as a prop since JSX elements create new references each render defeating the memo, and components during early development where premature optimization obscures the code. `React.memo` adds memory overhead by caching the previous props and render result, and incorrect usage can cause stale rendering bugs if you rely on a custom comparator that skips meaningful prop changes.',
  codeExample: 'import { memo, ReactNode } from \'react\';\n\n// GOOD — expensive component with stable primitive props\nconst ExpensiveChart = memo(function ExpensiveChart({ data }: { data: number[] }) {\n  // heavy SVG rendering\n  return <svg>...</svg>;\n});\n\n// BAD — children always creates a new JSX reference\nconst Wrapper = memo(function Wrapper({ children }: { children: ReactNode }) {\n  return <div className="wrapper">{children}</div>;\n  // memo is useless here — children is a new reference every render\n});\n\n// BAD — trivial component, memo overhead > render cost\nconst Label = memo(function Label({ text }: { text: string }) {\n  return <span>{text}</span>;\n});',
  followUp: 'How does the upcoming React Compiler eliminate the need for manual `React.memo` decisions?',
  keyTakeaway: 'Avoid `React.memo` on cheap components, those with children props, or components that always receive new props — the comparison cost outweighs the savings.',
},
{
  id: 89,
  title: 'How does `useActionState` work in React 19 and how does it enable progressive enhancement?',
  difficulty: 'hard',
  topic: 'performance-advanced',
  subtopic: 'useActionState',
  answer: '`useActionState` accepts an action function and an initial state, returning a tuple of `[state, formAction, isPending]`. The action function receives the previous state and the `FormData` as arguments, and its return value becomes the new state. When the returned `formAction` is passed to a `<form action>`, the form works even before JavaScript loads because the action can be a server action that runs on the server. After hydration, React takes over and manages the state on the client. This progressive enhancement means the form is fully functional for users on slow connections or with JavaScript disabled, while providing a rich interactive experience once the app hydrates.',
  codeExample: 'import { useActionState } from \'react\';\n\ninterface FormState {\n  error: string | null;\n  success: boolean;\n}\n\nasync function createPost(\n  prevState: FormState,\n  formData: FormData\n): Promise<FormState> {\n  const title = formData.get(\'title\') as string;\n  if (!title) return { error: \'Title is required\', success: false };\n  await savePost({ title });\n  return { error: null, success: true };\n}\n\nfunction PostForm() {\n  const [state, formAction, isPending] = useActionState(createPost, {\n    error: null,\n    success: false,\n  });\n\n  return (\n    <form action={formAction}>\n      <input name="title" />\n      {state.error && <p className="error">{state.error}</p>}\n      {state.success && <p>Post created!</p>}\n      <button type="submit" disabled={isPending}>\n        {isPending ? \'Creating...\' : \'Create Post\'}\n      </button>\n    </form>\n  );\n}',
  followUp: 'How does `useActionState` differ from combining `useState` with `useTransition` for form handling?',
  keyTakeaway: '`useActionState` manages form action state with progressive enhancement — the form works before JavaScript loads when used with server actions.',
},
{
  id: 90,
  title: 'How do you test components that use hooks like `useState` and `useEffect` with React Testing Library?',
  difficulty: 'medium',
  topic: 'performance-advanced',
  subtopic: 'testing',
  answer: 'React Testing Library tests hooks indirectly through the component that uses them — you render the component, interact with it via user events, and assert on the resulting DOM output. For `useState`, you trigger the state change through user interactions (clicking a button, typing in an input) using `userEvent` and then assert the updated UI. For `useEffect`, you may need to wrap assertions in `waitFor` to handle async side effects. You should never test hook implementation details directly — instead test the behavior the user sees. For custom hooks that need isolated testing, use `renderHook` from `@testing-library/react` which wraps the hook in a minimal test component.',
  codeExample: 'import { render, screen, waitFor } from \'@testing-library/react\';\nimport userEvent from \'@testing-library/user-event\';\nimport { renderHook, act } from \'@testing-library/react\';\n\n// Test a component that uses useState\nit(\'increments counter on click\', async () => {\n  render(<Counter />);\n  expect(screen.getByText(\'Count: 0\')).toBeInTheDocument();\n  await userEvent.click(screen.getByRole(\'button\', { name: /increment/i }));\n  expect(screen.getByText(\'Count: 1\')).toBeInTheDocument();\n});\n\n// Test a component with useEffect (async data)\nit(\'loads user data\', async () => {\n  render(<UserProfile userId="1" />);\n  await waitFor(() => {\n    expect(screen.getByText(\'Alice\')).toBeInTheDocument();\n  });\n});\n\n// Test a custom hook in isolation\nit(\'useCounter hook increments\', () => {\n  const { result } = renderHook(() => useCounter(0));\n  act(() => result.current.increment());\n  expect(result.current.count).toBe(1);\n});',
  followUp: 'Why does React Testing Library discourage testing implementation details like state values or hook call counts?',
  keyTakeaway: 'Test hooks through rendered components and user interactions — use `renderHook` only for custom hooks that need isolated testing.',
},
{
  id: 91,
  title: 'What is time slicing in React\'s concurrent renderer and how does it prevent UI jank?',
  difficulty: 'hard',
  topic: 'performance-advanced',
  subtopic: 'concurrent-features',
  answer: 'Time slicing is React\'s technique of breaking render work into small units and yielding control back to the browser between units so it can process user input, paint frames, and run other tasks. In the concurrent renderer, React uses a work loop that checks `shouldYield()` after processing each fiber node — if more than approximately 5ms has elapsed, it pauses rendering and schedules the remaining work via `MessageChannel` to resume in the next browser task. This prevents a single large render from monopolizing the main thread and causing dropped frames. The key insight is that React can discard incomplete renders if a higher-priority update arrives, so no wasted work appears on screen.',
  codeExample: '// Conceptual illustration of React\'s time slicing work loop\n// (simplified from the actual scheduler implementation)\n\nfunction workLoop(deadline: { timeRemaining: () => number }) {\n  let currentFiber = nextUnitOfWork;\n\n  while (currentFiber && !shouldYield()) {\n    // Process one fiber node (~1 component)\n    currentFiber = performUnitOfWork(currentFiber);\n  }\n\n  if (currentFiber) {\n    // More work to do — yield to browser and continue later\n    scheduleCallback(workLoop);\n  } else {\n    // All work done — commit to DOM in one synchronous batch\n    commitRoot();\n  }\n}\n\n// shouldYield() returns true after ~5ms of work\n// This keeps each task under one frame budget\n// Browser can handle input/paint between yielded slices',
  followUp: 'How does React\'s scheduler prioritize different types of updates during time slicing?',
  keyTakeaway: 'Time slicing breaks render work into ~5ms chunks, yielding to the browser between units so user input and animations stay smooth.',
},
{
  id: 92,
  title: 'How do you build accessible React components with proper ARIA attributes?',
  difficulty: 'medium',
  topic: 'performance-advanced',
  subtopic: 'accessibility',
  answer: 'Building accessible React components starts with using semantic HTML elements (`button`, `nav`, `main`, `dialog`) instead of generic `div`s with click handlers, because native elements provide keyboard support and screen reader semantics for free. When custom widgets are needed, add ARIA roles (`role="tablist"`), states (`aria-expanded`, `aria-selected`), and properties (`aria-label`, `aria-describedby`) that communicate the widget\'s purpose and state to assistive technology. All interactive elements must be keyboard operable — support `Tab` focus, `Enter`/`Space` activation, and arrow key navigation where expected. Use `aria-live` regions for dynamic content updates that screen readers should announce.',
  codeExample: 'interface AccordionItemProps {\n  title: string;\n  children: React.ReactNode;\n  id: string;\n}\n\nfunction AccordionItem({ title, children, id }: AccordionItemProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const headingId = `${id}-heading`;\n  const panelId = `${id}-panel`;\n\n  return (\n    <div>\n      <h3>\n        <button\n          id={headingId}\n          aria-expanded={isOpen}\n          aria-controls={panelId}\n          onClick={() => setIsOpen(prev => !prev)}\n        >\n          {title}\n        </button>\n      </h3>\n      <div\n        id={panelId}\n        role="region"\n        aria-labelledby={headingId}\n        hidden={!isOpen}\n      >\n        {children}\n      </div>\n    </div>\n  );\n}\n\n// Live region for dynamic announcements\nfunction StatusMessage({ message }: { message: string }) {\n  return <div aria-live="polite" role="status">{message}</div>;\n}',
  followUp: 'How would you test the accessibility of this accordion component using React Testing Library and jest-axe?',
  keyTakeaway: 'Use semantic HTML first, add ARIA roles and states for custom widgets, ensure keyboard operability, and use live regions for dynamic updates.',
},
{
  id: 93,
  title: 'How does `useCallback` interact with `React.memo` and when is the combination necessary?',
  difficulty: 'hard',
  topic: 'performance-advanced',
  subtopic: 'useMemo-useCallback',
  answer: '`useCallback` memoizes a function reference so it remains stable across renders as long as its dependencies have not changed. This is necessary when passing callbacks to `React.memo`-wrapped children because without `useCallback`, a new function is created on every parent render, which means the shallow prop comparison in `React.memo` always sees a different reference and never bails out. The combination is only worthwhile when the child component is expensive to render — if the child is cheap, the overhead of `useCallback` plus `React.memo` comparison exceeds the cost of just re-rendering. The dependency array must be correct; stale closures from missing dependencies cause bugs that are harder to diagnose than a redundant re-render.',
  codeExample: 'import { useState, useCallback, memo } from \'react\';\n\n// Expensive child — memoized to skip re-renders\nconst ExpensiveList = memo(function ExpensiveList({\n  items,\n  onItemClick,\n}: {\n  items: string[];\n  onItemClick: (item: string) => void;\n}) {\n  console.log(\'ExpensiveList rendered\');\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={item} onClick={() => onItemClick(item)}>{item}</li>\n      ))}\n    </ul>\n  );\n});\n\nfunction Parent() {\n  const [query, setQuery] = useState(\'\');\n  const [items] = useState([\'apple\', \'banana\', \'cherry\']);\n\n  // Without useCallback, ExpensiveList re-renders on every keystroke\n  const handleItemClick = useCallback((item: string) => {\n    console.log(\'Clicked:\', item);\n  }, []); // stable reference — no dependencies\n\n  return (\n    <div>\n      <input value={query} onChange={e => setQuery(e.target.value)} />\n      <ExpensiveList items={items} onItemClick={handleItemClick} />\n    </div>\n  );\n}',
  followUp: 'What happens if you use `useCallback` without wrapping the child in `React.memo` — is there any benefit?',
  keyTakeaway: '`useCallback` stabilizes function references so `React.memo` children can skip re-renders — only worthwhile when the child render is expensive.',
},
{
  id: 94,
  title: 'How does Suspense for data fetching work and what are the requirements for integrating with it?',
  difficulty: 'hard',
  topic: 'performance-advanced',
  subtopic: 'suspense-data',
  answer: 'Suspense for data fetching works by catching promises thrown during render. When a component tries to read data that is not yet available, the data fetching library throws a promise, and the nearest `<Suspense>` boundary catches it, renders its fallback UI, and re-attempts rendering the component once the promise resolves. This requires a Suspense-compatible data source — you cannot just throw a promise from `useEffect`; the library must implement the Suspense protocol by throwing a promise during the render phase and caching the result for subsequent render attempts. Frameworks like Next.js, Relay, and libraries like TanStack Query and SWR provide Suspense integration. In React 19, the `use()` hook is the official way to consume promises in Suspense-enabled components.',
  codeExample: 'import { Suspense } from \'react\';\n\n// Suspense-compatible data wrapper (simplified)\nfunction createResource<T>(promise: Promise<T>) {\n  let status: \'pending\' | \'fulfilled\' | \'rejected\' = \'pending\';\n  let result: T;\n  let error: unknown;\n  const suspender = promise.then(\n    (r) => { status = \'fulfilled\'; result = r; },\n    (e) => { status = \'rejected\'; error = e; }\n  );\n  return {\n    read(): T {\n      if (status === \'pending\') throw suspender; // Suspense catches this\n      if (status === \'rejected\') throw error;\n      return result;\n    },\n  };\n}\n\nconst userResource = createResource(fetchUser(1));\n\nfunction UserProfile() {\n  const user = userResource.read(); // throws if pending\n  return <h1>{user.name}</h1>;\n}\n\nfunction App() {\n  return (\n    <Suspense fallback={<p>Loading user...</p>}>\n      <UserProfile />\n    </Suspense>\n  );\n}',
  followUp: 'How do nested Suspense boundaries work, and how do you avoid a cascade of loading spinners?',
  keyTakeaway: 'Suspense catches promises thrown during render — the data library must implement the throw-and-cache protocol for it to work.',
},
{
  id: 95,
  title: 'How does `isPending` from `useTransition` differ from loading state managed with `useState`?',
  difficulty: 'medium',
  topic: 'performance-advanced',
  subtopic: 'useTransition',
  answer: '`isPending` from `useTransition` is managed by React\'s concurrent scheduler and automatically tracks whether a transition is still in progress — you never set it manually. It becomes `true` when `startTransition` is called and reverts to `false` once the deferred render completes and commits. With `useState`-based loading, you must manually set `isLoading = true` before the operation and `isLoading = false` after, which is error-prone (you might forget the `false` in an error path) and does not integrate with React\'s priority system. Additionally, `isPending` does not prevent the current UI from being interactive — the old UI remains responsive with the pending indicator overlaid, whereas a `useState` loading flag typically replaces the UI with a spinner.',
  codeExample: 'import { useState, useTransition } from \'react\';\n\n// useTransition — automatic pending, UI stays interactive\nfunction TabPanel() {\n  const [tab, setTab] = useState(\'home\');\n  const [isPending, startTransition] = useTransition();\n\n  const switchTab = (newTab: string) => {\n    startTransition(() => setTab(newTab));\n  };\n\n  return (\n    <div>\n      <nav style={{ opacity: isPending ? 0.7 : 1 }}>\n        <button onClick={() => switchTab(\'home\')}>Home</button>\n        <button onClick={() => switchTab(\'posts\')}>Posts</button>\n      </nav>\n      {/* Old tab content stays visible while pending */}\n      <TabContent tab={tab} />\n    </div>\n  );\n}\n\n// useState loading — manual, replaces UI with spinner\nfunction TabPanelOld() {\n  const [tab, setTab] = useState(\'home\');\n  const [loading, setLoading] = useState(false);\n  // Must manually manage loading in every handler and error path\n}',
  followUp: 'Can you use `isPending` to show a skeleton screen instead of dimming the old content?',
  keyTakeaway: '`isPending` is automatic, scheduler-aware, and keeps the old UI interactive — unlike manual `useState` loading which is error-prone and replaces content.',
},
{
  id: 96,
  title: 'How can `use()` read context values in React 19, and why is this useful?',
  difficulty: 'hard',
  topic: 'performance-advanced',
  subtopic: 'react-19-use',
  answer: 'In React 19, `use()` can accept a context object in addition to promises, making it a universal primitive for reading reactive values. When you call `use(SomeContext)`, it returns the current context value just like `useContext(SomeContext)`. The key advantage is that `use()` can be called conditionally — inside `if` blocks, `try/catch`, or early returns — which is forbidden with `useContext`. This enables patterns like conditionally subscribing to a context only when a feature flag is active, or reading different contexts based on runtime conditions. It simplifies component logic where conditional context consumption previously required splitting into separate components to satisfy the rules of hooks.',
  codeExample: 'import { use, createContext } from \'react\';\n\nconst ThemeContext = createContext<\'light\' | \'dark\'>(\'light\');\nconst AdminContext = createContext<{ role: string }>({ role: \'viewer\' });\n\ninterface DashboardProps {\n  isAdmin: boolean;\n  featureFlags: { darkMode: boolean };\n}\n\n// use() for context — can be called conditionally\nfunction Dashboard({ isAdmin, featureFlags }: DashboardProps) {\n  // Conditional context reading — impossible with useContext\n  if (featureFlags.darkMode) {\n    const theme = use(ThemeContext); // only subscribes when flag is on\n    console.log(\'Dark mode theme:\', theme);\n  }\n\n  if (isAdmin) {\n    const admin = use(AdminContext); // only subscribes for admins\n    return <AdminPanel role={admin.role} />;\n  }\n\n  return <UserDashboard />;\n}\n\n// Before React 19, you needed wrapper components:\n// function MaybeThemed({ active, children }) {\n//   if (!active) return children;\n//   return <ThemedWrapper>{children}</ThemedWrapper>;\n// }',
  followUp: 'Does calling `use(Context)` conditionally mean the component unsubscribes from that context on subsequent renders where the condition is false?',
  keyTakeaway: '`use()` can read context values conditionally — unlike `useContext`, it is not bound by the rules of hooks call-site constraints.',
},
{
  id: 97,
  title: 'How do you write integration tests for React components that interact with APIs using React Testing Library?',
  difficulty: 'hard',
  topic: 'performance-advanced',
  subtopic: 'testing',
  answer: 'Integration tests for API-dependent components use mock service workers (MSW) or manual fetch mocks to intercept network requests at the network level rather than mocking React internals. You set up handlers that return known responses, render the component, and use `waitFor` or `findBy` queries to wait for async data to appear in the DOM. This tests the full flow: component mounts, triggers fetch in `useEffect` or via Suspense, displays loading state, then renders data. For error scenarios, configure the mock to return error responses and assert error UI. This approach avoids testing implementation details — you never assert which fetch function was called, only what the user sees in the DOM.',
  codeExample: 'import { render, screen, waitFor } from \'@testing-library/react\';\nimport { http, HttpResponse } from \'msw\';\nimport { setupServer } from \'msw/node\';\n\nconst server = setupServer(\n  http.get(\'/api/users/1\', () => {\n    return HttpResponse.json({ id: 1, name: \'Alice\' });\n  })\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\nit(\'displays user data after loading\', async () => {\n  render(<UserProfile userId="1" />);\n  expect(screen.getByText(\'Loading...\')).toBeInTheDocument();\n  await waitFor(() => {\n    expect(screen.getByText(\'Alice\')).toBeInTheDocument();\n  });\n});\n\nit(\'displays error on API failure\', async () => {\n  server.use(\n    http.get(\'/api/users/1\', () => {\n      return new HttpResponse(null, { status: 500 });\n    })\n  );\n  render(<UserProfile userId="1" />);\n  await waitFor(() => {\n    expect(screen.getByText(\'Failed to load user\')).toBeInTheDocument();\n  });\n});',
  followUp: 'How does MSW differ from jest.mock for fetch, and why is it generally preferred for integration tests?',
  keyTakeaway: 'Use MSW to intercept network requests at the service worker level, then assert on DOM output with async queries — never mock React internals.',
},
{
  id: 98,
  title: 'What are server actions in React 19 and how do they differ from API routes?',
  difficulty: 'hard',
  topic: 'performance-advanced',
  subtopic: 'react-19-actions',
  answer: 'Server actions are async functions marked with the `\'use server\'` directive that execute on the server but can be called directly from client components. When a client component invokes a server action, React serializes the arguments, sends them as a POST request to the server, executes the function, and returns the result — all without you writing an API endpoint, fetch call, or serialization logic. Unlike traditional API routes, server actions are type-safe end-to-end (the function signature is shared), automatically integrate with React\'s form action system and `useActionState`, and support progressive enhancement when used with `<form action>`. They eliminate the boilerplate of API route handlers, client-side fetch wrappers, and manual request/response serialization.',
  codeExample: '// actions.ts — runs on the server\n\'use server\';\n\nimport { db } from \'@/lib/db\';\n\nexport async function createTodo(formData: FormData): Promise<{ error?: string }> {\n  const title = formData.get(\'title\') as string;\n  if (!title) return { error: \'Title required\' };\n  await db.todos.create({ data: { title } });\n  return {};\n}\n\n// TodoForm.tsx — client component calls server action directly\n\'use client\';\n\nimport { createTodo } from \'./actions\';\nimport { useActionState } from \'react\';\n\nfunction TodoForm() {\n  const [state, formAction, isPending] = useActionState(\n    async (_prev: { error?: string }, formData: FormData) => {\n      return await createTodo(formData);\n    },\n    {}\n  );\n\n  return (\n    <form action={formAction}>\n      <input name="title" />\n      {state.error && <p>{state.error}</p>}\n      <button disabled={isPending}>Add Todo</button>\n    </form>\n  );\n}',
  followUp: 'How does React serialize and deserialize the arguments and return values of server actions behind the scenes?',
  keyTakeaway: 'Server actions run on the server but are called like regular functions from client components — eliminating API route boilerplate with end-to-end type safety.',
},
{
  id: 99,
  title: 'What is the difference between `key` as a reset mechanism and using `useEffect` cleanup for resetting component state?',
  difficulty: 'easy',
  topic: 'performance-advanced',
  subtopic: 'react-memo',
  answer: 'Changing a component\'s `key` prop tells React to unmount the old instance and mount a completely new one, which resets all internal state — `useState`, `useRef`, and DOM state — to their initial values. This is simpler and more reliable than using `useEffect` to watch a prop and reset state manually, because `useEffect` runs after render (causing a flash of stale state) and you must remember to reset every piece of state individually. The `key` approach is declarative: React handles the full teardown and fresh mount automatically. The tradeoff is that changing `key` destroys the entire subtree including DOM nodes, which can be more expensive than a targeted state reset for components with heavy mount costs.',
  codeExample: '// Using key to reset — clean and declarative\nfunction App() {\n  const [userId, setUserId] = useState(1);\n  // Changing key unmounts old EditForm and mounts a new one\n  return <EditForm key={userId} userId={userId} />;\n}\n\nfunction EditForm({ userId }: { userId: number }) {\n  const [draft, setDraft] = useState(\'\'); // resets automatically on remount\n  return <input value={draft} onChange={e => setDraft(e.target.value)} />;\n}\n\n// Using useEffect to reset — fragile and causes flash of stale state\nfunction EditFormManual({ userId }: { userId: number }) {\n  const [draft, setDraft] = useState(\'\');\n  const [errors, setErrors] = useState<string[]>([]);\n  useEffect(() => {\n    setDraft(\'\');    // must remember every piece of state\n    setErrors([]);   // easy to forget one\n  }, [userId]);      // runs AFTER render — brief flash of old state\n  return <input value={draft} onChange={e => setDraft(e.target.value)} />;\n}',
  followUp: 'Are there performance implications of using `key` to reset a component that has expensive initialization logic?',
  keyTakeaway: 'Changing `key` fully remounts a component to reset all state — simpler and more reliable than manual `useEffect`-based resets but destroys the entire subtree.',
},
{
  id: 100,
  title: 'What are the common pitfalls when using `useEffect` that lead to performance problems?',
  difficulty: 'easy',
  topic: 'performance-advanced',
  subtopic: 're-renders',
  answer: 'The most common performance pitfalls with `useEffect` are: omitting the dependency array (which runs the effect after every render), including unstable references like objects or arrays in the dependency array (which triggers the effect on every render even when the values have not changed), triggering state updates inside `useEffect` that cause cascading re-renders, not cleaning up subscriptions or timers (causing memory leaks and stale updates), and using `useEffect` for logic that belongs in event handlers (which adds unnecessary render cycles). Many of these are solved by moving logic to event handlers, stabilizing dependencies with `useMemo`, or using the `useEffectEvent` pattern to read reactive values without adding them as dependencies.',
  codeExample: '// BAD — missing dependency array, runs every render\nuseEffect(() => {\n  fetchData(userId);\n});\n\n// BAD — object dependency recreated every render\nconst options = { page: 1, sort: \'name\' };\nuseEffect(() => {\n  fetchData(options);\n}, [options]); // new reference every render!\n\n// GOOD — stable primitive dependencies\nuseEffect(() => {\n  fetchData({ page, sort });\n}, [page, sort]);\n\n// BAD — unnecessary effect, should be an event handler\nuseEffect(() => {\n  if (submitted) {\n    sendAnalytics(\'form_submit\');\n    setSubmitted(false); // cascading state update\n  }\n}, [submitted]);\n\n// GOOD — move to event handler\nconst handleSubmit = () => {\n  submitForm();\n  sendAnalytics(\'form_submit\');\n};',
  followUp: 'How does the React team recommend deciding whether logic belongs in `useEffect` versus an event handler?',
  keyTakeaway: 'Common `useEffect` pitfalls include missing dependency arrays, unstable references, cascading state updates, and logic that belongs in event handlers.',
}]

export function filterReactQuestions(
  questions: ReactInterviewQuestion[],
  difficulty: 'all' | 'easy' | 'medium' | 'hard',
  topic: string,
): ReactInterviewQuestion[] {
  return questions.filter((q) => {
    if (difficulty !== 'all' && q.difficulty !== difficulty) return false
    if (topic !== 'all' && q.topic !== topic) return false
    return true
  })
}
