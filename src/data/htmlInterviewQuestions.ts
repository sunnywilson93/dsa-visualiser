export type HTMLInterviewTopic =
  | 'core-fundamentals'
  | 'semantic-accessibility'
  | 'forms-media'
  | 'modern-apis'

export interface HTMLInterviewQuestion {
  id: number
  title: string
  difficulty: 'easy' | 'medium' | 'hard'
  topic: HTMLInterviewTopic
  subtopic: string
  answer: string
  codeExample?: string
  followUp: string
  keyTakeaway: string
}

export interface HTMLTopicConfig {
  id: HTMLInterviewTopic
  label: string
  description: string
}

export const htmlTopics: HTMLTopicConfig[] = [
  {
    id: 'core-fundamentals',
    label: 'Core Fundamentals',
    description: 'Document structure, DOCTYPE, elements, attributes, parsing, rendering',
  },
  {
    id: 'semantic-accessibility',
    label: 'Semantic & A11y',
    description: 'Semantic HTML, ARIA, landmarks, screen readers, WCAG',
  },
  {
    id: 'forms-media',
    label: 'Forms & Media',
    description: 'Input types, validation, audio/video, canvas, SVG, responsive images',
  },
  {
    id: 'modern-apis',
    label: 'Modern HTML & APIs',
    description: 'Web Components, Shadow DOM, popover, dialog, CSP, import maps',
  },
]

export const htmlTopicMap: Record<HTMLInterviewTopic, HTMLTopicConfig> =
  Object.fromEntries(htmlTopics.map((t) => [t.id, t])) as Record<HTMLInterviewTopic, HTMLTopicConfig>

export const htmlInterviewQuestions: HTMLInterviewQuestion[] = [
{
  id: 1,
  title: 'What is HTML and what does it stand for?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'basics',
  answer: 'HTML stands for HyperText Markup Language. It is the standard markup language used to create and structure content on the web. HTML uses a system of elements (tags) to define the meaning and structure of content such as headings, paragraphs, links, images, and more. It is not a programming language ‚Äî it is a markup language that tells the browser how to display content.',
  codeExample: '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <title>My Page</title>\n  </head>\n  <body>\n    <h1>Hello, World!</h1>\n    <p>This is a basic HTML document.</p>\n  </body>\n</html>',
  followUp: 'What is the difference between HTML and XHTML?',
  keyTakeaway: 'HTML is the standard markup language for creating web pages and defines the structure and semantics of content.',
},
{
  id: 2,
  title: 'What is the purpose of the DOCTYPE declaration?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'document-structure',
  answer: 'The `<!DOCTYPE html>` declaration tells the browser which version of HTML the document is written in and triggers standards mode rendering. Without it, browsers fall into "quirks mode," which emulates legacy rendering behavior for backward compatibility with older pages. In HTML5, the declaration is simply `<!DOCTYPE html>`, whereas older versions like HTML 4.01 required a reference to a DTD (Document Type Definition). It must appear as the very first line of an HTML document, before the `<html>` tag.',
  codeExample: '<!-- HTML5 DOCTYPE -->\n<!DOCTYPE html>\n\n<!-- HTML 4.01 Strict DOCTYPE (historical) -->\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"\n  "http://www.w3.org/TR/html4/strict.dtd">',
  followUp: 'What is the difference between quirks mode and standards mode?',
  keyTakeaway: 'The DOCTYPE declaration triggers standards mode rendering and tells the browser which HTML version the document uses.',
},
{
  id: 3,
  title: 'What is the difference between block-level and inline elements?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'element-types',
  answer: 'Block-level elements occupy the full width available and always start on a new line, stacking vertically. Examples include `<div>`, `<p>`, `<h1>`-`<h6>`, and `<section>`. Inline elements only take up as much width as their content requires and flow within a line of text without breaking to a new line. Examples include `<span>`, `<a>`, `<strong>`, and `<em>`. In HTML5, these are formally described using content categories like "flow content" and "phrasing content" rather than the older block/inline terminology.',
  codeExample: '<!-- Block-level: takes full width, starts new line -->\n<div>I am a block element</div>\n<p>I am also a block element</p>\n\n<!-- Inline: flows within text -->\n<p>This has an <strong>inline</strong> element inside.</p>\n<p>Click <a href="/about">this link</a> for more.</p>',
  followUp: 'Can you nest a block-level element inside an inline element?',
  keyTakeaway: 'Block-level elements take up the full width and start new lines, while inline elements flow within text and only consume the width of their content.',
},
{
  id: 4,
  title: 'What are HTML attributes? Give examples.',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'attributes',
  answer: 'HTML attributes provide additional information or configuration for elements. They are placed in the opening tag as name-value pairs in the format `name="value"`. Some attributes are global and apply to any element (like `id`, `class`, `style`, `title`), while others are element-specific (like `src` on `<img>`, `href` on `<a>`, `type` on `<input>`). Boolean attributes like `disabled`, `checked`, and `required` do not need a value ‚Äî their presence alone activates the behavior.',
  codeExample: '<!-- Global attributes -->\n<div id="main" class="container" title="Main content">\n\n<!-- Element-specific attributes -->\n<a href="https://example.com" target="_blank" rel="noopener">Link</a>\n<img src="photo.jpg" alt="A photo" width="300" height="200">\n\n<!-- Boolean attributes -->\n<input type="text" required disabled>\n<details open>\n  <summary>Click me</summary>\n  <p>Content here</p>\n</details>',
  followUp: 'What is the difference between HTML attributes and DOM properties?',
  keyTakeaway: 'Attributes are name-value pairs in the opening tag that provide additional configuration or metadata for HTML elements.',
},
{
  id: 5,
  title: 'What is the purpose of the <head> element?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'document-structure',
  answer: 'The `<head>` element is a container for metadata about the document that is not directly displayed on the page. It contains the `<title>` element (required for valid HTML), `<meta>` tags for character encoding and viewport settings, `<link>` elements for stylesheets and favicons, `<script>` tags for JavaScript, and `<style>` blocks for embedded CSS. The information in the `<head>` is crucial for SEO, browser behavior, social sharing previews, and resource loading.',
  codeExample: '<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <meta name="description" content="A brief page description for SEO">\n  <title>My Website</title>\n  <link rel="stylesheet" href="styles.css">\n  <link rel="icon" href="favicon.ico">\n  <script src="app.js" defer></script>\n</head>',
  followUp: 'What is the minimum required content inside the head element?',
  keyTakeaway: 'The `<head>` element contains metadata, resource links, and configuration that the browser uses but does not render as visible content.',
},
{
  id: 6,
  title: 'What is the difference between <div> and <span>?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'element-types',
  answer: 'The `<div>` element is a generic block-level container that occupies the full available width and starts on a new line. The `<span>` element is a generic inline container that only takes up the width of its content and flows within surrounding text. Both are non-semantic ‚Äî they carry no inherent meaning and are used purely for grouping or styling purposes. You should prefer semantic alternatives like `<section>`, `<article>`, or `<nav>` when appropriate, and reserve `<div>` and `<span>` for cases where no semantic element fits.',
  codeExample: '<!-- div: block-level grouping -->\n<div class="card">\n  <h2>Card Title</h2>\n  <p>Card content goes here.</p>\n</div>\n\n<!-- span: inline grouping -->\n<p>The price is <span class="highlight">$29.99</span> today.</p>',
  followUp: 'When should you use a semantic element instead of a div?',
  keyTakeaway: '`<div>` is a block-level generic container and `<span>` is an inline generic container ‚Äî both are non-semantic and used for grouping or styling.',
},
{
  id: 7,
  title: 'What are HTML entities and when would you use them?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'entities',
  answer: 'HTML entities are special character sequences that represent reserved or special characters that cannot be directly typed into HTML source code. They begin with `&` and end with `;`. You must use entities for characters that have special meaning in HTML: `&lt;` for `<`, `&gt;` for `>`, `&amp;` for `&`, and `&quot;` for `"`. Entities are also useful for inserting non-breaking spaces (`&nbsp;`), copyright symbols (`&copy;`), and other characters not easily typed on a keyboard. Numeric references like `&#169;` and Unicode references like `&#x00A9;` are also valid.',
  codeExample: '<!-- Reserved characters that must be escaped -->\n<p>Use &lt;div&gt; to create a container.</p>\n<p>Tom &amp; Jerry</p>\n\n<!-- Special characters -->\n<p>&copy; 2024 My Company</p>\n<p>Price: &euro;49.99</p>\n<p>10&nbsp;&nbsp;&nbsp;extra spaces</p>\n\n<!-- Numeric reference -->\n<p>&#8594; Right arrow</p>',
  followUp: 'What is the difference between named and numeric character references?',
  keyTakeaway: 'HTML entities are encoded character sequences used to display reserved characters like `<`, `>`, and `&` that would otherwise be interpreted as HTML syntax.',
},
{
  id: 8,
  title: 'How do you create a hyperlink in HTML?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'links',
  answer: 'Hyperlinks are created with the `<a>` (anchor) element using the `href` attribute to specify the destination URL. Links can point to external URLs, internal pages, email addresses (`mailto:`), phone numbers (`tel:`), or specific sections of a page using fragment identifiers (`#section-id`). The `target="_blank"` attribute opens the link in a new tab, and when doing so you should include `rel="noopener noreferrer"` for security to prevent the new page from accessing `window.opener`. The link text between the tags should be descriptive for accessibility.',
  codeExample: '<!-- External link -->\n<a href="https://example.com">Visit Example</a>\n\n<!-- Open in new tab (secure) -->\n<a href="https://example.com" target="_blank" rel="noopener noreferrer">\n  External Site\n</a>\n\n<!-- Internal anchor link -->\n<a href="#contact">Jump to Contact</a>\n\n<!-- Email and phone -->\n<a href="mailto:info@example.com">Email Us</a>\n<a href="tel:+15551234567">Call Us</a>\n\n<!-- Download link -->\n<a href="/files/report.pdf" download>Download Report</a>',
  followUp: 'What does rel="noopener noreferrer" do and why is it important?',
  keyTakeaway: 'The `<a>` element with an `href` attribute creates hyperlinks that navigate to URLs, page sections, emails, or trigger downloads.',
},
{
  id: 9,
  title: 'What is the difference between an ordered list and unordered list?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'lists',
  answer: 'An ordered list (`<ol>`) displays items with sequential numbering, indicating that the order matters (e.g., steps in a recipe, rankings). An unordered list (`<ul>`) displays items with bullet points, indicating that sequence is not significant (e.g., a list of features or ingredients). Both use `<li>` elements for individual items. HTML also provides `<dl>` (description list) for term-definition pairs using `<dt>` and `<dd>`. The `<ol>` element supports attributes like `type` (for numbering style), `start` (starting number), and `reversed`.',
  codeExample: '<!-- Ordered list -->\n<ol>\n  <li>Preheat oven to 350¬∞F</li>\n  <li>Mix dry ingredients</li>\n  <li>Bake for 25 minutes</li>\n</ol>\n\n<!-- Unordered list -->\n<ul>\n  <li>HTML</li>\n  <li>CSS</li>\n  <li>JavaScript</li>\n</ul>\n\n<!-- Description list -->\n<dl>\n  <dt>HTML</dt>\n  <dd>HyperText Markup Language</dd>\n  <dt>CSS</dt>\n  <dd>Cascading Style Sheets</dd>\n</dl>',
  followUp: 'Can you nest lists inside each other and how does that affect semantics?',
  keyTakeaway: 'Ordered lists (`<ol>`) convey sequential items with numbering, while unordered lists (`<ul>`) convey non-sequential items with bullets.',
},
{
  id: 10,
  title: 'What is the purpose of the alt attribute on images?',
  difficulty: 'easy',
  topic: 'core-fundamentals',
  subtopic: 'images',
  answer: 'The `alt` attribute provides alternative text that describes the image content. It serves three critical purposes: it is read by screen readers for visually impaired users, it displays as fallback text when the image fails to load, and it helps search engines understand the image for SEO. The `alt` text should be descriptive and contextual ‚Äî not just "image" or "photo." For purely decorative images that convey no information, use an empty `alt=""` attribute so screen readers skip them entirely. Omitting the `alt` attribute is an accessibility violation.',
  codeExample: '<!-- Informative image -->\n<img src="chart.png" alt="Bar chart showing Q4 revenue growth of 25%">\n\n<!-- Functional image (inside a link) -->\n<a href="/">\n  <img src="logo.png" alt="Company Name - Home">\n</a>\n\n<!-- Decorative image -->\n<img src="divider.png" alt="">\n\n<!-- Complex image with long description -->\n<figure>\n  <img src="infographic.png" alt="2024 market trends infographic">\n  <figcaption>Detailed breakdown of market trends across sectors.</figcaption>\n</figure>',
  followUp: 'How do you decide between using alt text and an empty alt attribute?',
  keyTakeaway: 'The `alt` attribute provides text alternatives for images, serving accessibility, fallback display, and SEO purposes.',
},
{
  id: 11,
  title: 'Explain the difference between id and class attributes.',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'attributes',
  answer: 'The `id` attribute assigns a unique identifier to a single element ‚Äî each `id` value must appear only once per page. It is used for fragment navigation (`#section`), JavaScript targeting (`getElementById`), and `<label>` association with form inputs. The `class` attribute assigns one or more reusable class names to elements and can be shared across multiple elements. An element can have multiple classes separated by spaces. In CSS specificity, an `id` selector (`#foo`) has higher specificity (0,1,0,0) than a class selector (`.foo` at 0,0,1,0). Use `class` for styling and reusable patterns, and `id` for unique identification and anchor links.',
  codeExample: '<!-- id: unique, one per page -->\n<section id="contact">\n  <h2>Contact Us</h2>\n</section>\n<a href="#contact">Go to Contact</a>\n\n<!-- class: reusable, multiple per element -->\n<div class="card card--featured">\n  <p class="card__text">Featured item</p>\n</div>\n<div class="card">\n  <p class="card__text">Regular item</p>\n</div>\n\n<!-- label association via id -->\n<label for="email">Email:</label>\n<input id="email" type="email">',
  followUp: 'How does CSS specificity work with IDs versus classes?',
  keyTakeaway: 'The `id` attribute uniquely identifies a single element on the page, while `class` provides reusable labels that can be shared across multiple elements.',
},
{
  id: 12,
  title: 'What are data attributes and how do you use them?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'data-attributes',
  answer: 'Data attributes are custom attributes prefixed with `data-` that allow you to store extra information on HTML elements without affecting rendering or semantics. Any attribute name following the pattern `data-*` is valid. In JavaScript, you access them via the `dataset` property, which converts hyphenated names to camelCase (e.g., `data-user-id` becomes `element.dataset.userId`). In CSS, you can select elements by data attributes using attribute selectors like `[data-status="active"]`. They are ideal for passing configuration to JavaScript components, storing state for CSS hooks, or embedding metadata that does not fit any existing attribute.',
  codeExample: '<!-- Storing metadata on elements -->\n<button data-action="delete" data-item-id="42">\n  Delete\n</button>\n\n<div data-tooltip="Click to expand" data-expanded="false">\n  Content here\n</div>\n\n<!-- JavaScript access -->\n<script>\n  const btn = document.querySelector(\'[data-action="delete"]\');\n  console.log(btn.dataset.action);  // "delete"\n  console.log(btn.dataset.itemId);  // "42" (camelCase)\n</script>\n\n<!-- CSS selection -->\n<style>\n  [data-expanded="true"] { display: block; }\n  [data-expanded="false"] { display: none; }\n</style>',
  followUp: 'What are the performance implications of using data attributes versus JavaScript variables?',
  keyTakeaway: 'Data attributes (`data-*`) provide a standard way to embed custom metadata on HTML elements, accessible via `element.dataset` in JavaScript.',
},
{
  id: 13,
  title: 'What is the difference between <script>, <script async>, and <script defer>?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'script-loading',
  answer: 'A regular `<script>` tag blocks HTML parsing while the script is fetched and executed, which can delay page rendering. The `async` attribute fetches the script in parallel with HTML parsing but executes it immediately when downloaded, pausing the parser ‚Äî execution order is not guaranteed. The `defer` attribute also fetches in parallel but delays execution until after the HTML is fully parsed, and deferred scripts execute in document order. Use `defer` for scripts that depend on the DOM or each other, and `async` for independent scripts like analytics. Both attributes only work on external scripts with a `src` attribute.',
  codeExample: '<!-- Blocks parsing until downloaded and executed -->\n<script src="blocking.js"></script>\n\n<!-- Downloads in parallel, executes immediately when ready -->\n<!-- Order NOT guaranteed -->\n<script async src="analytics.js"></script>\n<script async src="ads.js"></script>\n\n<!-- Downloads in parallel, executes after parsing -->\n<!-- Order IS guaranteed -->\n<script defer src="vendor.js"></script>\n<script defer src="app.js"></script>',
  followUp: 'Where should you place script tags in the document and why?',
  keyTakeaway: '`async` downloads and executes scripts as soon as possible without order guarantees, while `defer` executes after parsing in document order.',
},
{
  id: 14,
  title: 'How does the browser parse an HTML document?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'parsing',
  answer: 'The browser parses HTML incrementally using a tokenizer and tree constructor. The tokenizer reads the raw byte stream (decoded via the character encoding), converts it into tokens (start tags, end tags, character data, comments), and the tree constructor builds the DOM tree from these tokens. Parsing can be paused by synchronous `<script>` tags that need to be fetched and executed. The parser also performs "speculative parsing" ‚Äî it looks ahead for resources like images, stylesheets, and scripts to begin fetching them early even while blocked on a script. The HTML parser is remarkably error-tolerant, automatically correcting issues like missing closing tags and improperly nested elements.',
  codeExample: '<!-- The parser processes this incrementally -->\n<!DOCTYPE html>         <!-- Sets document mode -->\n<html>                  <!-- Creates root element -->\n  <head>                <!-- Enters head parsing mode -->\n    <link rel="stylesheet" href="style.css"> <!-- Triggers fetch -->\n    <script src="app.js"></script>           <!-- Blocks parsing -->\n  </head>\n  <body>                <!-- Enters body parsing mode -->\n    <p>Hello            <!-- Opens paragraph -->\n    <p>World            <!-- Implicitly closes previous <p> -->\n  </body>\n</html>',
  followUp: 'What is speculative parsing and how does it improve performance?',
  keyTakeaway: 'The browser tokenizes and constructs the DOM tree incrementally, pausing for synchronous scripts and auto-correcting malformed markup.',
},
{
  id: 15,
  title: 'What is the difference between innerHTML, textContent, and innerText?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'dom-properties',
  answer: '`innerHTML` gets or sets the HTML markup inside an element, parsing the string as HTML. `textContent` gets or sets the raw text content of an element and all its descendants, ignoring any HTML tags ‚Äî it returns text from hidden elements too and does not trigger reflow. `innerText` is similar to `textContent` but is "CSS-aware," meaning it only returns visible text (respects `display: none`, `visibility`, etc.) and triggers a reflow to compute what is displayed. Setting `innerHTML` with user input creates XSS vulnerabilities because it parses HTML, while `textContent` is safe because it treats everything as plain text.',
  codeExample: '<div id="example">\n  <span style="display:none">Hidden</span>\n  <span>Visible</span>\n</div>\n\n<script>\n  const el = document.getElementById(\'example\');\n\n  el.innerHTML;    // "<span style=\\"display:none\\">Hidden</span>\\n<span>Visible</span>"\n  el.textContent;  // "Hidden\\nVisible" (includes hidden text)\n  el.innerText;    // "Visible" (only visible text)\n\n  // Safe text insertion\n  el.textContent = \'<b>Not bold</b>\';  // Displays literal text\n\n  // Dangerous ‚Äî parses HTML (XSS risk)\n  el.innerHTML = \'<b>Bold</b>\';  // Renders bold text\n</script>',
  followUp: 'Why is innerHTML a potential security risk and what alternatives exist?',
  keyTakeaway: '`innerHTML` parses HTML (XSS risk), `textContent` returns all raw text safely, and `innerText` returns only CSS-visible text.',
},
{
  id: 16,
  title: 'What is the purpose of the <meta> tag? What are common meta tags?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'meta-tags',
  answer: 'The `<meta>` tag provides metadata about the HTML document that is not displayed on the page but is used by browsers, search engines, and social media platforms. Common meta tags include `charset` for character encoding, `viewport` for responsive design configuration, `description` for SEO page summaries, and `robots` for search engine crawling directives. Open Graph (`og:`) meta tags control how pages appear when shared on social media. The `http-equiv` attribute can simulate HTTP headers, such as setting content security policies or refresh intervals.',
  codeExample: '<!-- Character encoding -->\n<meta charset="UTF-8">\n\n<!-- Responsive viewport -->\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n\n<!-- SEO -->\n<meta name="description" content="A guide to HTML meta tags">\n<meta name="robots" content="index, follow">\n\n<!-- Open Graph (social sharing) -->\n<meta property="og:title" content="My Page Title">\n<meta property="og:description" content="Page description for social cards">\n<meta property="og:image" content="https://example.com/image.png">\n\n<!-- HTTP-equiv -->\n<meta http-equiv="Content-Security-Policy" content="default-src \'self\'">',
  followUp: 'How do Open Graph meta tags affect social media sharing?',
  keyTakeaway: 'The `<meta>` tag provides document metadata used by browsers, search engines, and social platforms for encoding, SEO, viewport control, and sharing.',
},
{
  id: 17,
  title: 'Explain the difference between <link>, <a>, and <script> for loading resources.',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'resource-loading',
  answer: 'The `<link>` element establishes a relationship between the current document and an external resource. It is placed in the `<head>` and most commonly used to load stylesheets (`rel="stylesheet"`), preload resources (`rel="preload"`), prefetch pages (`rel="prefetch"`), and specify icons. The `<a>` element creates navigable hyperlinks that the user clicks to go to another resource or page ‚Äî it does not load resources automatically. The `<script>` element loads and executes JavaScript and can be placed in the `<head>` or `<body>`. Unlike `<link>`, `<script>` without `async` or `defer` blocks HTML parsing during download and execution.',
  codeExample: '<!-- <link>: loads resources automatically, non-blocking -->\n<link rel="stylesheet" href="styles.css">\n<link rel="preload" href="font.woff2" as="font" crossorigin>\n<link rel="prefetch" href="/next-page.html">\n<link rel="icon" href="favicon.ico">\n\n<!-- <a>: user-initiated navigation -->\n<a href="https://example.com">Visit Example</a>\n\n<!-- <script>: loads and executes JavaScript -->\n<script src="app.js" defer></script>\n<script type="module" src="module.js"></script>',
  followUp: 'What are the different rel values for the link element and when would you use each?',
  keyTakeaway: '`<link>` loads external resources like stylesheets passively, `<a>` creates user-clickable navigation, and `<script>` loads and executes JavaScript.',
},
{
  id: 18,
  title: 'What is the difference between <b>/<strong> and <i>/<em>?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'text-semantics',
  answer: '`<b>` and `<strong>` both render bold text visually, but `<strong>` carries semantic meaning indicating strong importance ‚Äî screen readers may emphasize it with a different tone. `<b>` is purely presentational, used for stylistically bold text without added importance (e.g., keywords in a summary). Similarly, `<i>` and `<em>` both render italic text, but `<em>` conveys stress emphasis that changes the meaning of a sentence, while `<i>` is used for alternative voice or mood (e.g., foreign words, technical terms, thoughts). The semantic elements (`<strong>`, `<em>`) are preferred for accessibility and SEO because they convey meaning to assistive technologies.',
  codeExample: '<!-- <strong>: semantic importance -->\n<p><strong>Warning:</strong> This action cannot be undone.</p>\n\n<!-- <b>: stylistic boldness, no extra meaning -->\n<p>This recipe calls for <b>flour</b>, <b>sugar</b>, and <b>butter</b>.</p>\n\n<!-- <em>: stress emphasis (changes meaning) -->\n<p>I <em>never</em> said he stole the money.</p>\n\n<!-- <i>: alternative voice -->\n<p>The word <i>schadenfreude</i> comes from German.</p>\n<p>She thought, <i>this can\'t be happening</i>.</p>',
  followUp: 'How do screen readers handle strong and em elements differently?',
  keyTakeaway: '`<strong>` and `<em>` carry semantic meaning (importance and emphasis), while `<b>` and `<i>` are purely presentational with no added semantics.',
},
{
  id: 19,
  title: 'What are void (self-closing) elements in HTML? Give examples.',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'element-types',
  answer: 'Void elements are HTML elements that cannot have any child content and do not have a closing tag. They are "self-closing" by definition. Common void elements include `<img>`, `<input>`, `<br>`, `<hr>`, `<meta>`, `<link>`, `<source>`, `<track>`, `<col>`, `<area>`, `<embed>`, and `<wbr>`. In HTML5, the trailing slash is optional (`<br>` and `<br />` are both valid), but in XHTML all void elements require the self-closing slash. Adding a closing tag to a void element (like `</img>`) is invalid HTML and may cause unexpected parsing behavior.',
  codeExample: '<!-- Common void elements -->\n<img src="photo.jpg" alt="A photo">\n<input type="text" name="username">\n<br>\n<hr>\n<meta charset="UTF-8">\n<link rel="stylesheet" href="styles.css">\n\n<!-- In media elements -->\n<video controls>\n  <source src="video.mp4" type="video/mp4">\n  <track src="captions.vtt" kind="subtitles" srclang="en">\n</video>\n\n<!-- Optional self-closing slash (both valid in HTML5) -->\n<br>\n<br />',
  followUp: 'What happens if you try to add content or a closing tag to a void element?',
  keyTakeaway: 'Void elements like `<img>`, `<input>`, and `<br>` cannot have children or closing tags ‚Äî they are self-contained single tags.',
},
{
  id: 20,
  title: 'What is character encoding and why is <meta charset="UTF-8"> important?',
  difficulty: 'medium',
  topic: 'core-fundamentals',
  subtopic: 'character-encoding',
  answer: 'Character encoding defines how bytes are mapped to characters. `<meta charset="UTF-8">` declares that the document uses UTF-8 encoding, which can represent virtually every character in every human language plus symbols and emoji. Without a declared encoding, the browser must guess, which can result in garbled text (mojibake) ‚Äî particularly for non-ASCII characters like accented letters, CJK characters, or emoji. The `<meta charset>` tag must appear within the first 1024 bytes of the document, ideally as the first element in `<head>`. UTF-8 is the dominant encoding on the web, used by over 98% of all websites.',
  codeExample: '<!-- Must be within first 1024 bytes -->\n<head>\n  <meta charset="UTF-8">\n  <title>Encoding Example</title>\n</head>\n<body>\n  <!-- UTF-8 handles all of these correctly -->\n  <p>English: Hello</p>\n  <p>Japanese: „Åì„Çì„Å´„Å°„ÅØ</p>\n  <p>Arabic: ŸÖÿ±ÿ≠ÿ®ÿß</p>\n  <p>Emoji: üåçüöÄ‚ú®</p>\n  <p>Accented: caf√©, na√Øve, r√©sum√©</p>\n</body>',
  followUp: 'What is the difference between UTF-8 and UTF-16?',
  keyTakeaway: '`<meta charset="UTF-8">` declares UTF-8 encoding, ensuring the browser correctly renders characters from all languages and symbol sets.',
},
{
  id: 21,
  title: 'Explain how the browser\'s critical rendering path works with HTML.',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'rendering',
  answer: 'The critical rendering path is the sequence of steps the browser takes to convert HTML, CSS, and JavaScript into pixels on screen. First, the browser parses HTML to build the DOM tree. In parallel, it parses CSS to construct the CSSOM (CSS Object Model). These two trees are combined into the render tree, which contains only visible elements with their computed styles. The browser then performs layout (reflow) to calculate the geometry and position of each element, followed by paint to fill in pixels, and finally compositing to combine layers. Render-blocking resources like CSS and synchronous JavaScript in the `<head>` delay the first paint because the CSSOM must be complete before rendering.',
  codeExample: '<!-- Optimized critical rendering path -->\n<head>\n  <!-- Critical CSS inlined for fast first paint -->\n  <style>\n    .hero { font-size: 2rem; color: #333; }\n  </style>\n\n  <!-- Non-critical CSS loaded asynchronously -->\n  <link rel="preload" href="full.css" as="style"\n        onload="this.rel=\'stylesheet\'">\n\n  <!-- Preload critical resources -->\n  <link rel="preload" href="hero.webp" as="image">\n\n  <!-- Defer non-critical JS -->\n  <script src="app.js" defer></script>\n</head>',
  followUp: 'How can you measure and optimize the critical rendering path?',
  keyTakeaway: 'The critical rendering path transforms HTML and CSS into the DOM, CSSOM, render tree, layout, paint, and compositing to produce visible pixels.',
},
{
  id: 22,
  title: 'What is the HTML parser\'s error handling behavior and how does it differ from XML?',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'parsing',
  answer: 'The HTML parser is extremely fault-tolerant by design ‚Äî it never throws parse errors to the user. When it encounters invalid markup like missing closing tags, improperly nested elements, or duplicate attributes, it applies a complex set of error recovery rules defined in the HTML specification. For example, the parser will auto-close a `<p>` tag when it encounters another block element, insert implied `<head>` and `<body>` elements if missing, and adopt misplaced elements into reasonable positions. XML (and XHTML served as `application/xhtml+xml`) is the opposite ‚Äî it is strict and will stop parsing entirely, showing a fatal error on the first well-formedness violation. This design choice makes HTML resilient but means that two different browsers may handle edge cases slightly differently.',
  codeExample: '<!-- HTML parser auto-corrects all of these -->\n\n<!-- Missing closing tags: parser auto-closes -->\n<p>First paragraph\n<p>Second paragraph\n\n<!-- Missing html/head/body: parser inserts them -->\n<!DOCTYPE html>\n<title>Minimal</title>\n<h1>Works fine</h1>\n\n<!-- Misnested tags: parser uses adoption agency -->\n<b>Bold <i>and italic</b> still italic?</i>\n<!-- Parsed as: <b>Bold <i>and italic</i></b><i> still italic?</i> -->\n\n<!-- Duplicate attributes: parser keeps first -->\n<div class="first" class="second">Uses "first"</div>',
  followUp: 'What is the adoption agency algorithm in the HTML parser?',
  keyTakeaway: 'The HTML parser silently recovers from errors using specification-defined rules, unlike XML which halts on any well-formedness violation.',
},
{
  id: 23,
  title: 'What is the DOM and how does it relate to HTML?',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'dom',
  answer: 'The Document Object Model (DOM) is a programming interface that represents an HTML document as a tree of node objects. When the browser parses an HTML document, it creates a DOM tree where each HTML element, attribute, and text content becomes a node. The DOM is not the same as the HTML source ‚Äî the parser may add missing elements (like `<tbody>` in tables), fix nesting errors, and execute scripts that modify the tree. JavaScript interacts with the page exclusively through the DOM API, using methods like `document.querySelector()`, `createElement()`, and `addEventListener()`. The DOM is also the bridge between HTML structure and CSS styling, as the browser matches CSS selectors against DOM nodes.',
  codeExample: '<!-- HTML source -->\n<ul id="list">\n  <li>Item 1</li>\n  <li>Item 2</li>\n</ul>\n\n<script>\n  // DOM tree representation:\n  // Document\n  //   ‚îî‚îÄ‚îÄ html\n  //       ‚îú‚îÄ‚îÄ head\n  //       ‚îî‚îÄ‚îÄ body\n  //           ‚îî‚îÄ‚îÄ ul#list\n  //               ‚îú‚îÄ‚îÄ li ("Item 1")\n  //               ‚îî‚îÄ‚îÄ li ("Item 2")\n\n  const list = document.getElementById(\'list\');\n  const newItem = document.createElement(\'li\');\n  newItem.textContent = \'Item 3\';\n  list.appendChild(newItem);  // DOM now differs from original HTML\n\n  // DOM node types\n  console.log(list.nodeType);            // 1 (Element)\n  console.log(list.firstChild.nodeType); // 3 (Text - whitespace)\n</script>',
  followUp: 'What is the difference between the DOM and the virtual DOM used by frameworks like React?',
  keyTakeaway: 'The DOM is an in-memory tree representation of the parsed HTML document that JavaScript uses to read and manipulate the page.',
},
{
  id: 24,
  title: 'Explain content models in HTML5 (flow, phrasing, embedded, etc.).',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'content-models',
  answer: 'HTML5 replaced the simple block/inline distinction with seven overlapping content categories that define what elements can contain and where they can be placed. Flow content is the broadest category and includes most elements used in the `<body>`. Phrasing content (roughly the old "inline") includes text-level elements like `<span>`, `<a>`, `<em>`, and `<img>`. Embedded content includes elements that embed external resources: `<img>`, `<video>`, `<iframe>`, `<canvas>`. Interactive content includes elements that respond to user interaction: `<a>`, `<button>`, `<input>`, `<select>`. Heading content (`<h1>`-`<h6>`, `<hgroup>`) and sectioning content (`<article>`, `<section>`, `<nav>`, `<aside>`) define document outline. Metadata content (`<meta>`, `<link>`, `<script>`) appears in the `<head>`. These categories determine valid nesting ‚Äî for example, `<p>` can only contain phrasing content, so placing a `<div>` inside a `<p>` is invalid.',
  codeExample: '<!-- Flow content: most body elements -->\n<div>Flow content container</div>\n<p>Paragraph is flow content</p>\n\n<!-- Phrasing content: text-level elements -->\n<p>Text with <em>emphasis</em> and <a href="#">links</a></p>\n\n<!-- Embedded content -->\n<img src="photo.jpg" alt="Embedded content">\n<video src="clip.mp4" controls></video>\n\n<!-- Sectioning content -->\n<article>\n  <section>\n    <h2>Heading content</h2>\n    <p>Phrasing inside flow</p>\n  </section>\n</article>\n\n<!-- INVALID: div (flow) inside p (only allows phrasing) -->\n<!-- <p><div>This is invalid</div></p> -->\n<!-- Parser will close <p> before <div> -->',
  followUp: 'How do content categories affect the document outline algorithm?',
  keyTakeaway: 'HTML5 defines seven content categories (flow, phrasing, embedded, interactive, heading, sectioning, metadata) that govern valid element nesting.',
},
{
  id: 25,
  title: 'What are the performance implications of DOM size and depth?',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'performance',
  answer: 'Large and deeply nested DOMs significantly impact performance across multiple browser subsystems. Each DOM node consumes memory, and a page with thousands of nodes increases the memory footprint substantially. CSS selector matching becomes slower as the browser must evaluate selectors against more nodes, and complex selectors on deep trees compound this cost. Layout (reflow) calculations scale with the number of affected nodes ‚Äî a reflow at the top of a deep tree cascades through all descendants. JavaScript DOM queries like `querySelectorAll` scan more nodes, and event delegation through deep trees means longer propagation paths. Google recommends fewer than 1,500 total DOM nodes, a maximum depth of 32 levels, and no parent element with more than 60 child nodes for optimal Lighthouse performance scores.',
  codeExample: '<!-- AVOID: deeply nested, overly complex DOM -->\n<div>\n  <div>\n    <div>\n      <div>\n        <div>\n          <span>Unnecessary nesting</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<!-- BETTER: flattened structure -->\n<section class="content">\n  <span>Direct child</span>\n</section>\n\n<!-- Virtualization for large lists -->\n<!-- Instead of rendering 10,000 rows: -->\n<!-- Only render visible rows + buffer -->\n<div class="virtual-list" style="height: 400px; overflow: auto;">\n  <!-- Windowed: only ~20 visible rows rendered -->\n</div>',
  followUp: 'What strategies can you use to reduce DOM size in large applications?',
  keyTakeaway: 'Large DOM trees degrade performance in memory usage, CSS matching, layout reflow, and JavaScript queries ‚Äî aim for under 1,500 nodes.',
},
{
  id: 26,
  title: 'How does HTML template parsing differ from regular HTML parsing?',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'parsing',
  answer: 'The `<template>` element is parsed by the browser but its contents are stored in a separate `DocumentFragment` that is inert ‚Äî not part of the active document. This means images inside a template will not load, scripts will not execute, styles will not apply, and form elements will not participate in form submission. The parser enters a special "in template" insertion mode where it processes the markup into the template\'s `content` property rather than the main DOM tree. This makes templates ideal for defining reusable markup structures that are instantiated on demand via JavaScript using `template.content.cloneNode(true)`. Unlike `display: none` or script-based templates, the `<template>` element benefits from browser-native parsing without side effects.',
  codeExample: '<template id="card-template">\n  <div class="card">\n    <h3 class="card-title"></h3>\n    <p class="card-body"></p>\n  </div>\n</template>\n\n<div id="container"></div>\n\n<script>\n  const template = document.getElementById(\'card-template\');\n  const container = document.getElementById(\'container\');\n\n  // Template content is inert until cloned\n  console.log(template.content); // DocumentFragment\n\n  function addCard(title, body) {\n    const clone = template.content.cloneNode(true);\n    clone.querySelector(\'.card-title\').textContent = title;\n    clone.querySelector(\'.card-body\').textContent = body;\n    container.appendChild(clone);\n  }\n\n  addCard(\'First Card\', \'Card content here.\');\n  addCard(\'Second Card\', \'More content.\');\n</script>',
  followUp: 'How do Web Components use the template element together with Shadow DOM?',
  keyTakeaway: 'The `<template>` element is parsed into an inert `DocumentFragment` ‚Äî its contents do not load, execute, or render until explicitly cloned into the DOM.',
},
{
  id: 27,
  title: 'What is the difference between the DOM tree and the render tree?',
  difficulty: 'hard',
  topic: 'core-fundamentals',
  subtopic: 'rendering',
  answer: 'The DOM tree is the complete structural representation of the HTML document, including every element, text node, and comment. The render tree (also called the layout tree or frame tree) is a subset that contains only the elements that will actually be painted on screen, combined with their computed CSS styles. Elements with `display: none` exist in the DOM but are excluded from the render tree entirely. Pseudo-elements like `::before` and `::after` exist in the render tree but not in the DOM. The `<head>` element and its children are in the DOM but never in the render tree. Visibility hidden elements remain in the render tree (they occupy space) but are simply not painted. The render tree is what the browser uses for layout calculations and painting.',
  codeExample: '<!-- DOM tree includes ALL of these -->\n<head>\n  <style>\n    .hidden { display: none; }\n    .invisible { visibility: hidden; }\n    .pseudo::before { content: "‚òÖ "; }\n  </style>\n</head>\n<body>\n  <h1>Visible heading</h1>           <!-- In DOM + render tree -->\n  <div class="hidden">Hidden</div>   <!-- In DOM only (not rendered) -->\n  <div class="invisible">Ghost</div> <!-- In DOM + render tree (no paint) -->\n  <p class="pseudo">With star</p>    <!-- In DOM + render tree -->\n  <!-- ::before pseudo-element -->    <!-- In render tree only (not in DOM) -->\n  <script>/* ... */</script>          <!-- In DOM only -->\n</body>\n\n<!-- DOM: ~8 elements  |  Render tree: ~4 boxes + 1 pseudo -->',
  followUp: 'How does the browser handle elements transitioning between display none and visible?',
  keyTakeaway: 'The DOM tree contains all parsed elements, while the render tree only includes visible elements with computed styles ‚Äî `display: none` elements are excluded.',
},
{
  id: 28,
  title: 'What is semantic HTML and why is it important?',
  difficulty: 'easy',
  topic: 'semantic-accessibility',
  subtopic: 'semantics',
  answer: 'Semantic HTML means using HTML elements that clearly describe their meaning and purpose rather than relying on generic containers like `<div>` and `<span>`. Elements like `<header>`, `<nav>`, `<main>`, `<article>`, and `<footer>` communicate the role of content to browsers, screen readers, and search engines. Semantic markup improves accessibility because assistive technologies can build a meaningful page outline and allow users to navigate by landmarks. It also benefits SEO because search engines better understand the page structure and content hierarchy, and it improves code maintainability because developers can understand the document structure at a glance.',
  codeExample: '<!-- Non-semantic (bad) -->\n<div class="header">\n  <div class="nav">...</div>\n</div>\n<div class="main">\n  <div class="article">...</div>\n  <div class="sidebar">...</div>\n</div>\n<div class="footer">...</div>\n\n<!-- Semantic (good) -->\n<header>\n  <nav>...</nav>\n</header>\n<main>\n  <article>...</article>\n  <aside>...</aside>\n</main>\n<footer>...</footer>',
  followUp: 'Can you have multiple header or footer elements on one page?',
  keyTakeaway: 'Semantic HTML uses meaningful elements that communicate content purpose to browsers, assistive technologies, and search engines.',
},
{
  id: 29,
  title: 'Name five semantic HTML5 elements and their purposes.',
  difficulty: 'easy',
  topic: 'semantic-accessibility',
  subtopic: 'semantic-elements',
  answer: '`<article>` represents a self-contained, independently distributable piece of content such as a blog post, news story, or forum post. `<nav>` identifies a section of navigation links, typically the main site navigation or table of contents. `<figure>` encapsulates self-contained content like images, diagrams, or code listings, often with a `<figcaption>` description. `<time>` represents a specific date, time, or duration in a machine-readable format using the `datetime` attribute. `<mark>` highlights text that is relevant in the current context, such as search result matches. Each element carries inherent semantics that assistive technologies and search engines can interpret.',
  codeExample: '<!-- article: self-contained content -->\n<article>\n  <h2>Breaking News</h2>\n  <p>Story content here...</p>\n</article>\n\n<!-- nav: navigation section -->\n<nav aria-label="Main">\n  <ul>\n    <li><a href="/">Home</a></li>\n    <li><a href="/about">About</a></li>\n  </ul>\n</nav>\n\n<!-- figure + figcaption -->\n<figure>\n  <img src="chart.png" alt="Revenue chart">\n  <figcaption>Q4 2024 revenue by region</figcaption>\n</figure>\n\n<!-- time: machine-readable date -->\n<p>Published on <time datetime="2024-03-15">March 15, 2024</time></p>\n\n<!-- mark: highlighted text -->\n<p>Search results for: <mark>semantic HTML</mark></p>',
  followUp: 'How does the article element differ from the section element?',
  keyTakeaway: 'Semantic HTML5 elements like `<article>`, `<nav>`, `<figure>`, `<time>`, and `<mark>` convey specific content meaning beyond visual presentation.',
},
{
  id: 30,
  title: 'What are <header>, <footer>, <main>, <nav>, and <aside> used for?',
  difficulty: 'easy',
  topic: 'semantic-accessibility',
  subtopic: 'landmark-elements',
  answer: '`<header>` contains introductory content or navigational aids for its nearest sectioning ancestor ‚Äî typically logos, headings, and navigation. `<footer>` contains footer information for its nearest sectioning ancestor, such as copyright, contact info, and related links. `<main>` represents the dominant content of the `<body>` and must be unique per page (only one `<main>` without the `hidden` attribute). `<nav>` identifies a section with navigation links, usually the primary site navigation or a table of contents. `<aside>` contains content tangentially related to the surrounding content, like sidebars, pull quotes, or related links. These elements map directly to ARIA landmark roles, enabling screen reader users to jump between page regions.',
  codeExample: '<body>\n  <header>\n    <img src="logo.svg" alt="Site logo">\n    <nav aria-label="Primary">\n      <a href="/">Home</a>\n      <a href="/blog">Blog</a>\n    </nav>\n  </header>\n\n  <main>\n    <article>\n      <h1>Article Title</h1>\n      <p>Main content goes here.</p>\n    </article>\n\n    <aside>\n      <h2>Related Articles</h2>\n      <ul>\n        <li><a href="/post-2">Related Post</a></li>\n      </ul>\n    </aside>\n  </main>\n\n  <footer>\n    <p>&copy; 2024 My Site. All rights reserved.</p>\n    <nav aria-label="Footer">\n      <a href="/privacy">Privacy</a>\n      <a href="/terms">Terms</a>\n    </nav>\n  </footer>\n</body>',
  followUp: 'What ARIA landmark roles do these elements implicitly map to?',
  keyTakeaway: 'These landmark elements define page regions (banner, navigation, main content, complementary, footer) that assistive technologies use for navigation.',
},
{
  id: 31,
  title: 'What is the role of the <article> element?',
  difficulty: 'easy',
  topic: 'semantic-accessibility',
  subtopic: 'semantic-elements',
  answer: 'The `<article>` element represents a self-contained composition that could be independently distributed or syndicated ‚Äî such as a blog post, news article, forum post, product card, or user comment. The key test is whether the content makes sense on its own, outside the context of the rest of the page. Articles can be nested (e.g., comments within a blog post), and each article should typically include a heading. Screen readers announce the element as an "article" landmark, helping users identify distinct content pieces. The `<article>` element implicitly has the ARIA role of `article`.',
  codeExample: '<!-- Blog post article -->\n<article>\n  <header>\n    <h2>Understanding Semantic HTML</h2>\n    <time datetime="2024-03-15">March 15, 2024</time>\n    <span>By Jane Doe</span>\n  </header>\n  <p>Article body content...</p>\n  <footer>\n    <p>Tags: HTML, Accessibility</p>\n  </footer>\n</article>\n\n<!-- Nested articles (comments) -->\n<article>\n  <h2>Blog Post Title</h2>\n  <p>Post content...</p>\n\n  <section>\n    <h3>Comments</h3>\n    <article>\n      <p>Great article!</p>\n      <footer>‚Äî User1, <time datetime="2024-03-16">March 16</time></footer>\n    </article>\n    <article>\n      <p>Very helpful, thanks!</p>\n      <footer>‚Äî User2, <time datetime="2024-03-17">March 17</time></footer>\n    </article>\n  </section>\n</article>',
  followUp: 'When should you use article versus section?',
  keyTakeaway: 'The `<article>` element represents self-contained content that makes sense independently, such as a blog post, comment, or product card.',
},
{
  id: 32,
  title: 'What is the difference between <section> and <div>?',
  difficulty: 'easy',
  topic: 'semantic-accessibility',
  subtopic: 'semantic-elements',
  answer: 'The `<section>` element represents a thematic grouping of content, typically with a heading. It carries semantic meaning ‚Äî it tells browsers and assistive technologies that the enclosed content forms a distinct, related group within the page. A `<div>` is a generic container with no semantic meaning; it exists purely for styling or scripting purposes. The rule of thumb is: if the content would logically appear as an entry in the document outline with its own heading, use `<section>`. If you only need a wrapper for layout or CSS hooks, use `<div>`. Screen readers can announce sections as regions when they have an accessible name (via `aria-label` or `aria-labelledby`).',
  codeExample: '<!-- section: thematic grouping with meaning -->\n<section aria-labelledby="features-heading">\n  <h2 id="features-heading">Features</h2>\n  <ul>\n    <li>Fast performance</li>\n    <li>Easy to use</li>\n  </ul>\n</section>\n\n<section aria-labelledby="pricing-heading">\n  <h2 id="pricing-heading">Pricing</h2>\n  <p>Plans start at $9/month.</p>\n</section>\n\n<!-- div: generic wrapper for layout -->\n<div class="grid-container">\n  <div class="card">Card 1</div>\n  <div class="card">Card 2</div>\n</div>',
  followUp: 'When would you use a section without a heading?',
  keyTakeaway: '`<section>` is a semantic thematic grouping that typically has a heading, while `<div>` is a non-semantic generic container for styling.',
},
{
  id: 33,
  title: 'Why is heading hierarchy (h1-h6) important?',
  difficulty: 'easy',
  topic: 'semantic-accessibility',
  subtopic: 'headings',
  answer: 'Heading hierarchy creates a logical document outline that is critical for accessibility, SEO, and content structure. Screen reader users frequently navigate pages by jumping between headings ‚Äî a 2017 WebAIM survey found that 67.5% of screen reader users navigate by headings as their primary strategy. Headings must follow a sequential order without skipping levels (e.g., `<h1>` followed by `<h2>`, not `<h1>` followed by `<h4>`). Each page should have one `<h1>` representing the primary topic, with `<h2>`-`<h6>` creating nested subsections. Search engines use heading hierarchy to understand content structure and importance.',
  codeExample: '<!-- Correct heading hierarchy -->\n<h1>Web Development Guide</h1>\n\n<h2>HTML Fundamentals</h2>\n<h3>Document Structure</h3>\n<h3>Semantic Elements</h3>\n\n<h2>CSS Styling</h2>\n<h3>Selectors</h3>\n<h4>Class Selectors</h4>\n<h4>ID Selectors</h4>\n<h3>Layout</h3>\n\n<!-- WRONG: skips heading levels -->\n<!-- <h1>Title</h1> -->\n<!-- <h4>Subsection</h4> -->\n\n<!-- Screen readers generate an outline like: -->\n<!-- 1. Web Development Guide -->\n<!--   1.1 HTML Fundamentals -->\n<!--     1.1.1 Document Structure -->\n<!--     1.1.2 Semantic Elements -->\n<!--   1.2 CSS Styling -->\n<!--     1.2.1 Selectors -->\n<!--       1.2.1.1 Class Selectors -->\n<!--       1.2.1.2 ID Selectors -->\n<!--     1.2.2 Layout -->',
  followUp: 'Is it valid to have multiple h1 elements on a page?',
  keyTakeaway: 'A logical heading hierarchy (h1-h6 without skipping levels) is essential for screen reader navigation, SEO, and content structure.',
},
{
  id: 34,
  title: 'What does ARIA stand for and what is its purpose?',
  difficulty: 'easy',
  topic: 'semantic-accessibility',
  subtopic: 'aria',
  answer: 'ARIA stands for Accessible Rich Internet Applications. It is a set of HTML attributes defined by the W3C WAI (Web Accessibility Initiative) that supplement native HTML semantics to make dynamic web content and custom UI components accessible to assistive technologies. ARIA provides roles (like `role="dialog"`, `role="tabpanel"`), states (like `aria-expanded="true"`, `aria-checked="false"`), and properties (like `aria-label`, `aria-describedby`) that communicate information to screen readers. The first rule of ARIA is "don\'t use ARIA if you can use a native HTML element with built-in semantics" ‚Äî for example, use `<button>` instead of `<div role="button">`.',
  codeExample: '<!-- AVOID: ARIA where native HTML works -->\n<div role="button" tabindex="0" aria-pressed="false">\n  Click me\n</div>\n\n<!-- BETTER: native HTML with built-in semantics -->\n<button type="button">Click me</button>\n\n<!-- ARIA is needed for custom widgets -->\n<div role="tablist">\n  <button role="tab" aria-selected="true" aria-controls="panel-1">\n    Tab 1\n  </button>\n  <button role="tab" aria-selected="false" aria-controls="panel-2">\n    Tab 2\n  </button>\n</div>\n<div role="tabpanel" id="panel-1">Panel 1 content</div>\n<div role="tabpanel" id="panel-2" hidden>Panel 2 content</div>',
  followUp: 'What are the five rules of ARIA usage?',
  keyTakeaway: 'ARIA (Accessible Rich Internet Applications) provides roles, states, and properties that make custom interactive components accessible to assistive technologies.',
},
{
  id: 35,
  title: 'What is the purpose of the role attribute?',
  difficulty: 'easy',
  topic: 'semantic-accessibility',
  subtopic: 'aria',
  answer: 'The `role` attribute defines the semantic purpose of an element for assistive technologies, overriding or supplementing its native semantics. Roles fall into several categories: landmark roles (`banner`, `navigation`, `main`, `complementary`), widget roles (`button`, `tab`, `dialog`, `slider`), document structure roles (`heading`, `list`, `table`), and live region roles (`alert`, `status`, `log`). Many HTML5 elements have implicit roles ‚Äî `<nav>` has `role="navigation"`, `<button>` has `role="button"` ‚Äî so you should not redundantly assign roles that match the element\'s native semantics. The `role` attribute does not add behavior or keyboard interaction; it only affects how the element is announced to screen readers.',
  codeExample: '<!-- Implicit roles (no role attribute needed) -->\n<nav>...</nav>          <!-- implicit role="navigation" -->\n<main>...</main>        <!-- implicit role="main" -->\n<button>...</button>    <!-- implicit role="button" -->\n\n<!-- Explicit roles for custom components -->\n<div role="alert">Form submission failed!</div>\n\n<div role="dialog" aria-labelledby="dialog-title" aria-modal="true">\n  <h2 id="dialog-title">Confirm Action</h2>\n  <p>Are you sure?</p>\n  <button>Yes</button>\n  <button>Cancel</button>\n</div>\n\n<!-- Search landmark -->\n<form role="search">\n  <input type="search" aria-label="Search site">\n  <button type="submit">Search</button>\n</form>',
  followUp: 'What is the difference between implicit and explicit ARIA roles?',
  keyTakeaway: 'The `role` attribute defines an element\'s semantic purpose for assistive technologies but does not add behavior or keyboard interaction.',
},
{
  id: 36,
  title: 'What are ARIA landmarks and how do they map to HTML5 semantic elements?',
  difficulty: 'medium',
  topic: 'semantic-accessibility',
  subtopic: 'aria-landmarks',
  answer: 'ARIA landmarks are roles that identify major page regions, allowing screen reader users to jump directly between sections. The key mappings are: `<header>` (page-level) maps to `role="banner"`, `<nav>` maps to `role="navigation"`, `<main>` maps to `role="main"`, `<aside>` maps to `role="complementary"`, `<footer>` (page-level) maps to `role="contentinfo"`, and `<form>` with an accessible name maps to `role="form"`. The `role="search"` landmark has no native HTML equivalent (until the `<search>` element was introduced). When using multiple instances of the same landmark (e.g., two `<nav>` elements), you must differentiate them with `aria-label` or `aria-labelledby` so screen reader users can tell them apart.',
  codeExample: '<!-- Landmark mapping -->\n<header>             <!-- role="banner" -->\n  <nav aria-label="Primary">  <!-- role="navigation" -->\n    <a href="/">Home</a>\n  </nav>\n</header>\n\n<main>               <!-- role="main" -->\n  <article>...</article>\n</main>\n\n<aside>              <!-- role="complementary" -->\n  <h2>Sidebar</h2>\n</aside>\n\n<footer>             <!-- role="contentinfo" -->\n  <nav aria-label="Footer">  <!-- second nav, differentiated -->\n    <a href="/privacy">Privacy</a>\n  </nav>\n</footer>\n\n<!-- search landmark (no native element before <search>) -->\n<form role="search" aria-label="Site search">\n  <input type="search" aria-label="Search">\n  <button type="submit">Go</button>\n</form>',
  followUp: 'How do screen reader users navigate using landmarks?',
  keyTakeaway: 'ARIA landmarks map to HTML5 semantic elements, enabling screen reader users to jump between major page regions like navigation, main content, and footer.',
},
{
  id: 37,
  title: 'Explain the difference between aria-label, aria-labelledby, and aria-describedby.',
  difficulty: 'medium',
  topic: 'semantic-accessibility',
  subtopic: 'aria-labels',
  answer: '`aria-label` provides a text label directly as a string attribute value, used when no visible text label exists on the page. `aria-labelledby` references the `id` of one or more visible elements whose text content becomes the accessible name ‚Äî it overrides both the element\'s native label and any `aria-label`. `aria-describedby` references the `id` of elements that provide supplementary description, announced after the accessible name and role. The key difference is that `aria-label` and `aria-labelledby` define what an element IS (its name), while `aria-describedby` provides additional context ABOUT the element. Screen readers typically announce the name first, then the role, then the description.',
  codeExample: '<!-- aria-label: direct text label (no visible label) -->\n<button aria-label="Close dialog">\n  <svg><!-- X icon --></svg>\n</button>\n\n<!-- aria-labelledby: references visible text -->\n<h2 id="billing-title">Billing Information</h2>\n<form aria-labelledby="billing-title">\n  <!-- Screen reader: "Billing Information, form" -->\n</form>\n\n<!-- aria-describedby: supplementary description -->\n<label for="password">Password</label>\n<input id="password" type="password"\n       aria-describedby="password-hint">\n<p id="password-hint">\n  Must be at least 8 characters with one number.\n</p>\n<!-- SR: "Password, edit text, Must be at least 8 characters..." -->\n\n<!-- Combined: labelledby + describedby -->\n<div id="dialog-title">Delete File</div>\n<div id="dialog-desc">This action cannot be undone.</div>\n<div role="dialog"\n     aria-labelledby="dialog-title"\n     aria-describedby="dialog-desc">\n</div>',
  followUp: 'In what order does aria-labelledby override other labeling mechanisms?',
  keyTakeaway: '`aria-label` and `aria-labelledby` define the accessible name, while `aria-describedby` adds supplementary description announced after the name and role.',
},
{
  id: 38,
  title: 'What is a skip navigation link and why is it important?',
  difficulty: 'medium',
  topic: 'semantic-accessibility',
  subtopic: 'navigation',
  answer: 'A skip navigation link is a hidden anchor link placed at the very top of a page that becomes visible on focus and allows keyboard and screen reader users to bypass repetitive content (like navigation menus) and jump directly to the main content. Without it, keyboard users must tab through every navigation link on every page load before reaching the content ‚Äî a frustrating and time-consuming experience. It is a WCAG 2.1 Level A requirement (Success Criterion 2.4.1: "Bypass Blocks"). The link is typically visually hidden using CSS and positioned off-screen until it receives focus, at which point it slides into view.',
  codeExample: '<!-- Skip link at very top of body -->\n<body>\n  <a href="#main-content" class="skip-link">\n    Skip to main content\n  </a>\n\n  <header>\n    <nav>\n      <!-- Many navigation links here -->\n      <a href="/">Home</a>\n      <a href="/about">About</a>\n      <a href="/services">Services</a>\n      <a href="/blog">Blog</a>\n      <a href="/contact">Contact</a>\n    </nav>\n  </header>\n\n  <main id="main-content">\n    <h1>Page Content</h1>\n  </main>\n</body>\n\n<style>\n  .skip-link {\n    position: absolute;\n    top: -40px;\n    left: 0;\n    padding: 8px;\n    background: #000;\n    color: #fff;\n    z-index: 100;\n  }\n  .skip-link:focus {\n    top: 0;\n  }\n</style>',
  followUp: 'Are there other WCAG techniques for bypassing repeated content blocks?',
  keyTakeaway: 'Skip navigation links allow keyboard users to bypass repetitive content and jump to main content, fulfilling WCAG 2.4.1 requirements.',
},
{
  id: 39,
  title: 'How do screen readers interpret HTML tables?',
  difficulty: 'medium',
  topic: 'semantic-accessibility',
  subtopic: 'tables-accessibility',
  answer: 'Screen readers use table semantics to provide navigation and context. When a table uses proper `<th>` headers, the screen reader announces column and row headers as the user navigates between cells, providing context like "Column: Price, Row: Widget A, $29.99." The `scope` attribute on `<th>` (`scope="col"` or `scope="row"`) explicitly associates headers with their cells. The `<caption>` element provides an accessible name for the entire table. For complex tables with multi-level headers, `headers` and `id` attributes create explicit associations. Screen readers offer table-specific keyboard shortcuts to move between cells. Using tables for layout (without `role="presentation"`) confuses screen readers because they announce layout divs as data tables.',
  codeExample: '<!-- Accessible data table -->\n<table>\n  <caption>Q4 2024 Sales by Region</caption>\n  <thead>\n    <tr>\n      <th scope="col">Region</th>\n      <th scope="col">Revenue</th>\n      <th scope="col">Growth</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th scope="row">North</th>\n      <td>$1.2M</td>\n      <td>+15%</td>\n    </tr>\n    <tr>\n      <th scope="row">South</th>\n      <td>$980K</td>\n      <td>+8%</td>\n    </tr>\n  </tbody>\n</table>\n\n<!-- Layout table (suppresses table semantics) -->\n<table role="presentation">\n  <tr>\n    <td>Layout column 1</td>\n    <td>Layout column 2</td>\n  </tr>\n</table>',
  followUp: 'How do you handle complex tables with merged cells for accessibility?',
  keyTakeaway: 'Screen readers use `<th>`, `scope`, and `<caption>` to announce table headers and context as users navigate between cells.',
},
{
  id: 40,
  title: 'What is tab order and how does tabindex affect it?',
  difficulty: 'medium',
  topic: 'semantic-accessibility',
  subtopic: 'focus-management',
  answer: 'Tab order is the sequence in which elements receive focus when the user presses the Tab key. By default, interactive elements (`<a>`, `<button>`, `<input>`, `<select>`, `<textarea>`) are focusable in DOM source order. The `tabindex` attribute modifies this behavior: `tabindex="0"` makes a non-interactive element focusable in natural DOM order (useful for custom widgets). `tabindex="-1"` makes an element programmatically focusable via `element.focus()` but removes it from the Tab sequence (useful for managing focus in dialogs or SPAs). Positive `tabindex` values (e.g., `tabindex="1"`) create a custom tab order but are strongly discouraged because they override the natural flow and create confusing navigation patterns ‚Äî rearrange the DOM instead.',
  codeExample: '<!-- Natural tab order follows DOM order -->\n<button>First</button>    <!-- Tab stop 1 -->\n<input type="text">       <!-- Tab stop 2 -->\n<a href="#">Link</a>      <!-- Tab stop 3 -->\n\n<!-- tabindex="0": add to tab order -->\n<div role="button" tabindex="0">\n  Custom button (focusable via Tab)\n</div>\n\n<!-- tabindex="-1": focusable only via JS -->\n<div id="error-message" tabindex="-1">\n  Error: Please fix the form.\n</div>\n<script>\n  // Programmatically move focus after validation\n  document.getElementById(\'error-message\').focus();\n</script>\n\n<!-- AVOID: positive tabindex -->\n<!-- <input tabindex="3"> -->\n<!-- <input tabindex="1"> -->\n<!-- <input tabindex="2"> -->\n<!-- Confusing! Rearrange DOM instead -->',
  followUp: 'How do you create a focus trap for modal dialogs?',
  keyTakeaway: '`tabindex="0"` adds elements to the tab order, `tabindex="-1"` allows programmatic focus only, and positive values should be avoided.',
},
{
  id: 41,
  title: 'What are live regions and when would you use aria-live?',
  difficulty: 'medium',
  topic: 'semantic-accessibility',
  subtopic: 'live-regions',
  answer: 'ARIA live regions are areas of the page that screen readers automatically announce when their content changes dynamically, without the user needing to navigate to them. The `aria-live` attribute has three values: `"polite"` waits for the user to finish their current interaction before announcing (for non-urgent updates like status messages), `"assertive"` interrupts immediately (for urgent notifications like errors), and `"off"` disables announcements. Implicit live regions exist via roles: `role="alert"` is assertive, `role="status"` is polite, and `role="log"` is polite with append-only behavior. The live region element must exist in the DOM before its content changes ‚Äî dynamically adding an element with `aria-live` may not be announced.',
  codeExample: '<!-- Polite: announced after current speech finishes -->\n<div aria-live="polite" aria-atomic="true">\n  <!-- Content updates announced politely -->\n</div>\n\n<!-- Status message (implicit polite live region) -->\n<div role="status">3 results found</div>\n\n<!-- Alert (implicit assertive live region) -->\n<div role="alert">Error: Password is required.</div>\n\n<!-- Chat log (polite, only new additions announced) -->\n<div role="log" aria-live="polite" aria-relevant="additions">\n  <p>User1: Hello!</p>\n  <p>User2: Hi there!</p>\n  <!-- New messages announced as they appear -->\n</div>\n\n<!-- aria-atomic: announce entire region vs just changes -->\n<div aria-live="polite" aria-atomic="true">\n  <span>Score:</span> <span>42</span>\n  <!-- Announces "Score: 42" not just "42" -->\n</div>',
  followUp: 'What is the difference between aria-relevant additions, removals, and text?',
  keyTakeaway: 'Live regions (`aria-live`) automatically announce dynamic content changes to screen readers ‚Äî `"polite"` waits, `"assertive"` interrupts immediately.',
},
{
  id: 42,
  title: 'How do you make a custom interactive component accessible?',
  difficulty: 'medium',
  topic: 'semantic-accessibility',
  subtopic: 'custom-widgets',
  answer: 'Making a custom interactive component accessible requires four key aspects. First, assign the correct ARIA `role` so assistive technologies know what the widget is (e.g., `role="tablist"`, `role="menu"`). Second, manage keyboard interaction following the WAI-ARIA Authoring Practices ‚Äî for example, arrow keys to navigate within a tab list, Enter/Space to activate items, and Escape to close. Third, manage ARIA states that reflect the current condition (`aria-selected`, `aria-expanded`, `aria-checked`, `aria-disabled`). Fourth, manage focus correctly ‚Äî roving `tabindex` for composite widgets (one child has `tabindex="0"`, others have `tabindex="-1"`), and visible focus indicators. Always prefer native HTML elements when possible, as they provide all of this for free.',
  codeExample: '<!-- Accessible custom toggle button -->\n<button\n  role="switch"\n  aria-checked="false"\n  onclick="this.setAttribute(\'aria-checked\',\n    this.getAttribute(\'aria-checked\') === \'true\' ? \'false\' : \'true\'\n  )">\n  Dark Mode\n</button>\n\n<!-- Accessible custom dropdown (roving tabindex) -->\n<div role="listbox" aria-label="Select color" aria-activedescendant="opt-red">\n  <div role="option" id="opt-red" tabindex="0" aria-selected="true">\n    Red\n  </div>\n  <div role="option" id="opt-blue" tabindex="-1" aria-selected="false">\n    Blue\n  </div>\n  <div role="option" id="opt-green" tabindex="-1" aria-selected="false">\n    Green\n  </div>\n</div>\n\n<!-- Keyboard handling (conceptual) -->\n<script>\n  // Arrow keys move between options\n  // Enter/Space select the focused option\n  // Home/End jump to first/last option\n</script>',
  followUp: 'What is the roving tabindex pattern and when do you use it versus aria-activedescendant?',
  keyTakeaway: 'Custom interactive components need correct ARIA roles, keyboard interaction patterns, state management, and focus handling to be accessible.',
},
{
  id: 43,
  title: 'What is the difference between aria-hidden="true" and display: none?',
  difficulty: 'medium',
  topic: 'semantic-accessibility',
  subtopic: 'visibility',
  answer: '`aria-hidden="true"` removes an element and all its descendants from the accessibility tree, making them invisible to screen readers, but the element remains visually visible and interactive on the page. `display: none` removes the element from both the visual rendering and the accessibility tree ‚Äî it is completely hidden from everyone. A third option, the `.sr-only` / "visually hidden" pattern, does the opposite: it hides content visually while keeping it accessible to screen readers. Use `aria-hidden="true"` for decorative visuals like icons next to text labels that would be redundant for screen readers. Never use `aria-hidden="true"` on focusable elements ‚Äî this creates a confusing state where an element can receive focus but is invisible to assistive technology.',
  codeExample: '<!-- aria-hidden: visible but removed from accessibility tree -->\n<button>\n  <svg aria-hidden="true"><!-- decorative icon --></svg>\n  Delete Item\n</button>\n\n<!-- display: none: hidden from everyone -->\n<div style="display: none;">\n  This is completely hidden.\n</div>\n\n<!-- visibility: hidden: invisible but occupies space -->\n<div style="visibility: hidden;">\n  Takes up space but not visible or accessible.\n</div>\n\n<!-- Visually hidden: invisible but accessible to SR -->\n<style>\n  .sr-only {\n    position: absolute;\n    width: 1px;\n    height: 1px;\n    padding: 0;\n    margin: -1px;\n    overflow: hidden;\n    clip: rect(0, 0, 0, 0);\n    white-space: nowrap;\n    border: 0;\n  }\n</style>\n<span class="sr-only">Additional context for screen readers</span>\n\n<!-- DANGER: never hide focusable elements with aria-hidden -->\n<!-- <a href="#" aria-hidden="true">Broken pattern</a> -->',
  followUp: 'What is the inert attribute and how does it compare to aria-hidden?',
  keyTakeaway: '`aria-hidden="true"` hides from screen readers only, `display: none` hides from everyone, and visually-hidden CSS hides visually while remaining accessible.',
},
{
  id: 44,
  title: 'How should you structure a page for optimal screen reader navigation?',
  difficulty: 'medium',
  topic: 'semantic-accessibility',
  subtopic: 'page-structure',
  answer: 'Optimal screen reader page structure starts with a skip navigation link, followed by semantic landmark elements (`<header>`, `<nav>`, `<main>`, `<aside>`, `<footer>`) that provide region-based navigation. Use a logical heading hierarchy (`<h1>` through `<h6>`) without skipping levels, as most screen reader users navigate by headings. Ensure all landmarks with duplicates have unique labels (e.g., two `<nav>` elements should have different `aria-label` values). Group related form fields with `<fieldset>` and `<legend>`. Use lists (`<ul>`, `<ol>`) for collections so screen readers announce the count ("list, 5 items"). Provide descriptive link text (avoid "click here") and ensure all interactive elements have accessible names.',
  codeExample: '<body>\n  <a href="#main" class="skip-link">Skip to content</a>\n\n  <header>\n    <nav aria-label="Primary">\n      <ul>\n        <li><a href="/" aria-current="page">Home</a></li>\n        <li><a href="/about">About</a></li>\n      </ul>\n    </nav>\n  </header>\n\n  <main id="main">\n    <h1>Page Title</h1>\n\n    <section aria-labelledby="intro-heading">\n      <h2 id="intro-heading">Introduction</h2>\n      <p>Content with <a href="/details">detailed information</a>.</p>\n    </section>\n\n    <section aria-labelledby="form-heading">\n      <h2 id="form-heading">Contact Form</h2>\n      <form>\n        <fieldset>\n          <legend>Personal Information</legend>\n          <label for="name">Full Name</label>\n          <input id="name" type="text" required>\n        </fieldset>\n      </form>\n    </section>\n  </main>\n\n  <aside aria-label="Related articles">\n    <h2>Related</h2>\n    <ul>\n      <li><a href="/post-1">Related article title</a></li>\n    </ul>\n  </aside>\n\n  <footer>\n    <nav aria-label="Footer">\n      <a href="/privacy">Privacy Policy</a>\n    </nav>\n  </footer>\n</body>',
  followUp: 'How do you test a page with a screen reader?',
  keyTakeaway: 'Structure pages with skip links, semantic landmarks, logical heading hierarchy, labeled regions, and descriptive link text for screen reader navigation.',
},
{
  id: 45,
  title: 'What is the accessibility tree and how does it relate to the DOM?',
  difficulty: 'medium',
  topic: 'semantic-accessibility',
  subtopic: 'accessibility-tree',
  answer: 'The accessibility tree is a simplified representation of the DOM that browsers generate for assistive technologies. While the DOM contains every element, the accessibility tree only includes semantically relevant nodes ‚Äî each with a role, name, state, and value. The browser computes the accessibility tree by mapping HTML elements to their accessible roles (`<button>` becomes role "button"), calculating accessible names (from labels, `aria-label`, text content), and determining states (`aria-expanded`, `disabled`). Elements with `aria-hidden="true"` and their descendants are pruned from the tree. Decorative elements and purely presentational containers are typically excluded. You can inspect the accessibility tree in browser DevTools (Chrome\'s Accessibility tab in the Elements panel) to verify how assistive technologies will perceive your page.',
  codeExample: '<!-- DOM structure -->\n<nav aria-label="Main">\n  <ul>\n    <li>\n      <a href="/">\n        <svg aria-hidden="true"><!-- icon --></svg>\n        Home\n      </a>\n    </li>\n  </ul>\n</nav>\n\n<!--\nAccessibility tree (simplified):\n  navigation "Main"\n    list\n      listitem\n        link "Home"\n\nNote:\n- <ul> becomes "list"\n- <li> becomes "listitem"\n- <a> becomes "link" with name "Home"\n- <svg> is pruned (aria-hidden)\n- <nav> becomes "navigation" with name "Main"\n-->\n\n<!-- Inspect in Chrome DevTools: -->\n<!-- Elements panel ‚Üí Accessibility tab ‚Üí Accessibility Tree -->',
  followUp: 'How does the browser compute the accessible name for an element?',
  keyTakeaway: 'The accessibility tree is a simplified DOM representation containing only semantic information (role, name, state, value) used by assistive technologies.',
},
{
  id: 46,
  title: 'Explain the WCAG 2.1 AA requirements relevant to HTML.',
  difficulty: 'hard',
  topic: 'semantic-accessibility',
  subtopic: 'wcag',
  answer: 'WCAG 2.1 AA is organized around four principles (POUR): Perceivable, Operable, Understandable, and Robust. Key HTML-relevant requirements include: all non-text content needs text alternatives (1.1.1), content must be adaptable and presentable in different ways without losing meaning (1.3.1 ‚Äî proper semantic structure), sufficient color contrast of 4.5:1 for normal text and 3:1 for large text (1.4.3), all functionality must be keyboard accessible (2.1.1), users must be able to bypass repeated blocks (2.4.1 ‚Äî skip links), pages need descriptive titles (2.4.2), focus order must be logical (2.4.3), link purpose must be determinable from text (2.4.4), consistent navigation across pages (3.2.3), input errors must be identified and described (3.3.1), and HTML must be parsed without errors so assistive technologies can reliably interpret it (4.1.1 and 4.1.2).',
  codeExample: '<!-- 1.1.1: Text alternatives -->\n<img src="chart.png" alt="Revenue grew 25% in Q4">\n\n<!-- 1.3.1: Semantic structure -->\n<nav aria-label="Main"><ul><li><a href="/">Home</a></li></ul></nav>\n\n<!-- 2.1.1: Keyboard accessible -->\n<button onclick="handleClick()">Submit</button>\n<!-- Not: <div onclick="handleClick()">Submit</div> -->\n\n<!-- 2.4.1: Bypass blocks -->\n<a href="#main" class="skip-link">Skip to content</a>\n\n<!-- 2.4.2: Page titles -->\n<title>Contact Us - My Company</title>\n\n<!-- 3.3.1: Error identification -->\n<label for="email">Email</label>\n<input id="email" type="email" aria-invalid="true"\n       aria-describedby="email-error">\n<p id="email-error" role="alert">\n  Please enter a valid email address.\n</p>\n\n<!-- 4.1.2: Name, role, value -->\n<button aria-expanded="false" aria-controls="menu">Menu</button>',
  followUp: 'What is the difference between WCAG A, AA, and AAA conformance levels?',
  keyTakeaway: 'WCAG 2.1 AA requires text alternatives, semantic structure, keyboard access, bypass blocks, focus order, error handling, and sufficient color contrast.',
},
{
  id: 47,
  title: 'How do you implement accessible drag and drop?',
  difficulty: 'hard',
  topic: 'semantic-accessibility',
  subtopic: 'drag-drop',
  answer: 'Accessible drag and drop requires providing an equivalent keyboard-accessible alternative since screen reader and keyboard users cannot use mouse-based drag gestures. The recommended approach is to offer action menus or keyboard shortcuts: each draggable item gets a button (e.g., "Move item") that opens a menu with options like "Move up," "Move down," "Move to section X." Use `aria-grabbed` (deprecated but still used) or `aria-roledescription` to communicate the draggable nature. Provide live region announcements (`aria-live="assertive"`) for operation status: "Item grabbed," "Moved to position 3 of 5," "Item dropped." The ARIA drag-and-drop properties (`aria-dropeffect`) have been deprecated in ARIA 1.1, so focus on providing a fully functional keyboard alternative rather than trying to make the drag gesture itself accessible.',
  codeExample: '<!-- Accessible sortable list with keyboard alternative -->\n<ul role="listbox" aria-label="Reorderable tasks">\n  <li role="option" aria-selected="false">\n    <span>Task: Write documentation</span>\n    <button aria-label="Reorder: Write documentation"\n            aria-haspopup="true"\n            aria-expanded="false">\n      ‚ãÆ\n    </button>\n    <!-- Dropdown menu -->\n    <ul role="menu" hidden>\n      <li role="menuitem">Move to top</li>\n      <li role="menuitem">Move up</li>\n      <li role="menuitem">Move down</li>\n      <li role="menuitem">Move to bottom</li>\n    </ul>\n  </li>\n</ul>\n\n<!-- Live region for announcements -->\n<div aria-live="assertive" class="sr-only" id="dnd-status">\n  <!-- JS updates: "Write documentation moved to position 2 of 5" -->\n</div>\n\n<!-- Keyboard instructions -->\n<p class="sr-only">\n  Use arrow keys to select items. Press Space to grab,\n  arrow keys to move, Space to drop, Escape to cancel.\n</p>',
  followUp: 'What keyboard patterns does the WAI-ARIA Authoring Practices recommend for sortable lists?',
  keyTakeaway: 'Accessible drag and drop requires a keyboard-based alternative (action menus or keyboard shortcuts) with live region announcements for status updates.',
},
{
  id: 48,
  title: 'What is the inert attribute and how does it improve accessibility?',
  difficulty: 'hard',
  topic: 'semantic-accessibility',
  subtopic: 'inert',
  answer: 'The `inert` attribute is a boolean HTML attribute that makes an element and all its descendants non-interactive and invisible to assistive technologies. When applied, the subtree cannot receive focus, cannot be clicked, cannot be selected, is removed from the accessibility tree, and is excluded from find-in-page searches. It is the native HTML solution for creating focus traps without complex JavaScript ‚Äî when a modal dialog is open, you apply `inert` to everything outside the dialog, ensuring keyboard and screen reader users are confined to the dialog content. Before `inert`, developers had to manually manage `aria-hidden`, `tabindex="-1"`, and pointer-events on all background elements. The `inert` attribute handles all of these concerns in a single declaration and properly cascades to all descendants.',
  codeExample: '<!-- Modal dialog with inert background -->\n<body>\n  <div id="app" inert>\n    <!-- All content here becomes non-interactive -->\n    <header>\n      <nav>\n        <a href="/">Home</a> <!-- Not focusable -->\n        <button>Menu</button> <!-- Not clickable -->\n      </nav>\n    </header>\n    <main>\n      <p>Background content...</p>\n    </main>\n  </div>\n\n  <!-- Dialog is NOT inert, so it remains interactive -->\n  <dialog open aria-labelledby="dialog-title">\n    <h2 id="dialog-title">Confirm Delete</h2>\n    <p>This action is permanent.</p>\n    <button autofocus>Cancel</button>\n    <button>Delete</button>\n  </dialog>\n</body>\n\n<script>\n  function openDialog() {\n    document.getElementById(\'app\').inert = true;\n    dialog.showModal();\n  }\n  function closeDialog() {\n    document.getElementById(\'app\').inert = false;\n    dialog.close();\n  }\n</script>',
  followUp: 'How does the inert attribute interact with the dialog element\'s built-in modal behavior?',
  keyTakeaway: 'The `inert` attribute makes an entire subtree non-interactive and inaccessible, providing a native solution for focus containment in modals.',
},
{
  id: 49,
  title: 'How do you handle focus management in single-page applications?',
  difficulty: 'hard',
  topic: 'semantic-accessibility',
  subtopic: 'focus-management',
  answer: 'In single-page applications (SPAs), client-side route changes do not trigger a full page load, so screen readers are not notified of navigation. You must manually manage focus on route transitions by moving focus to the new content ‚Äî typically to the main heading (`<h1>`) or a container element with `tabindex="-1"`. Announce the new page title using `document.title` and optionally an `aria-live` region. When opening modals, trap focus inside by listening for Tab/Shift+Tab at the boundaries and cycling back, and restore focus to the triggering element when the modal closes. For dynamic content like form validation errors, move focus to the first error or use `aria-live` regions. Loading states should be communicated with `aria-busy="true"` on the updating region and announced via live regions.',
  codeExample: '<!-- Route change: focus the heading -->\n<main>\n  <h1 id="page-title" tabindex="-1">New Page Title</h1>\n  <p>Page content loaded via SPA navigation.</p>\n</main>\n\n<!-- Route change announcement -->\n<div aria-live="polite" class="sr-only" id="route-announcer">\n  <!-- JS sets: "Navigated to About page" -->\n</div>\n\n<script>\n  // On route change\n  function onRouteChange(pageTitle) {\n    document.title = pageTitle;\n\n    // Move focus to heading\n    const heading = document.getElementById(\'page-title\');\n    heading.focus();\n\n    // Announce navigation\n    document.getElementById(\'route-announcer\')\n      .textContent = `Navigated to ${pageTitle}`;\n  }\n\n  // Modal focus trap\n  function trapFocus(modal) {\n    const focusable = modal.querySelectorAll(\n      \'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])\'\n    );\n    const first = focusable[0];\n    const last = focusable[focusable.length - 1];\n\n    modal.addEventListener(\'keydown\', (e) => {\n      if (e.key === \'Tab\') {\n        if (e.shiftKey && document.activeElement === first) {\n          e.preventDefault();\n          last.focus();\n        } else if (!e.shiftKey && document.activeElement === last) {\n          e.preventDefault();\n          first.focus();\n        }\n      }\n    });\n  }\n</script>',
  followUp: 'How do frameworks like React handle focus management with their router components?',
  keyTakeaway: 'SPAs require manual focus management on route changes, focus trapping in modals, and live region announcements for dynamic content updates.',
},
{
  id: 50,
  title: 'What are the accessibility considerations for dynamic content updates?',
  difficulty: 'hard',
  topic: 'semantic-accessibility',
  subtopic: 'dynamic-content',
  answer: 'Dynamic content updates present unique accessibility challenges because screen readers cannot visually detect changes on the page. Use `aria-live` regions to announce updates: `"polite"` for non-urgent changes (search results, status updates) and `"assertive"` for urgent notifications (errors, alerts). Set `aria-atomic="true"` when the entire region should be re-announced, or `"false"` when only changes should be read. Use `aria-busy="true"` on containers that are loading to prevent premature announcements, and remove it when the update completes. For infinite scroll or lazy-loaded content, ensure new content is keyboard-navigable and announce the count of new items. Toast notifications should use `role="status"` or `role="alert"` and auto-dismiss only after sufficient reading time (minimum 5 seconds). Never move focus unexpectedly ‚Äî let the user control when they interact with new content.',
  codeExample: '<!-- Loading state -->\n<div aria-busy="true" aria-live="polite">\n  <p>Loading results...</p>\n</div>\n\n<!-- After load completes -->\n<div aria-busy="false" aria-live="polite">\n  <p>Showing 25 results</p>\n  <!-- results rendered here -->\n</div>\n\n<!-- Toast notification -->\n<div role="status" class="toast">\n  Settings saved successfully.\n</div>\n\n<!-- Error notification (urgent) -->\n<div role="alert">\n  Connection lost. Changes may not be saved.\n</div>\n\n<!-- Infinite scroll announcement -->\n<div aria-live="polite" class="sr-only" id="scroll-status">\n  <!-- "Loaded 10 more items. Showing 30 of 150 total." -->\n</div>\n\n<!-- Form validation -->\n<form aria-describedby="form-errors">\n  <div id="form-errors" role="alert" aria-live="assertive">\n    <!-- Populated on submit: "2 errors found: Name is required. Email is invalid." -->\n  </div>\n  <label for="name">Name</label>\n  <input id="name" type="text" aria-invalid="true"\n         aria-describedby="name-error">\n  <p id="name-error">Name is required.</p>\n</form>',
  followUp: 'How do you handle accessible notifications that should auto-dismiss?',
  keyTakeaway: 'Dynamic updates require `aria-live` regions, `aria-busy` for loading states, appropriate urgency levels, and never moving focus unexpectedly.',
},
{
  id: 51,
  title: 'How do you implement an accessible modal dialog pattern?',
  difficulty: 'hard',
  topic: 'semantic-accessibility',
  subtopic: 'modal-pattern',
  answer: 'An accessible modal dialog requires trapping focus within the dialog, returning focus to the triggering element on close, and using `role="dialog"` with `aria-modal="true"` and `aria-labelledby` pointing to the dialog title. You must also listen for the Escape key to close, prevent background scrolling, and ensure screen readers cannot interact with content behind the dialog by applying `aria-hidden="true"` or `inert` to sibling elements. The native `<dialog>` element with `showModal()` handles many of these concerns automatically, including focus trapping and backdrop rendering.',
  codeExample: '<button id="openBtn">Open Dialog</button>\n<dialog id="myDialog" aria-labelledby="dialogTitle">\n  <h2 id="dialogTitle">Confirm Action</h2>\n  <p>Are you sure you want to proceed?</p>\n  <button id="confirmBtn">Confirm</button>\n  <button id="cancelBtn">Cancel</button>\n</dialog>\n<script>\n  openBtn.onclick = () => myDialog.showModal();\n  cancelBtn.onclick = () => myDialog.close();\n</script>',
  followUp: 'What is the `inert` attribute and how does it simplify modal implementations?',
  keyTakeaway: 'Accessible modals require focus trapping, keyboard handling, and ARIA attributes, but the native `<dialog>` element automates most of these concerns.',
},
{
  id: 52,
  title: 'What is the accessibility impact of using `<iframe>` and how do you mitigate issues?',
  difficulty: 'hard',
  topic: 'semantic-accessibility',
  subtopic: 'iframes',
  answer: 'Iframes create a separate browsing context that can be opaque to assistive technologies. Screen readers may struggle to convey the relationship between the parent document and iframe content, and keyboard users can get trapped inside an iframe if it does not properly manage focus. To mitigate these issues, always provide a descriptive `title` attribute on the `<iframe>` so screen readers can announce its purpose. Use `sandbox` to restrict capabilities, set `loading="lazy"` for off-screen iframes, and ensure the embedded content itself is accessible. Consider using `aria-hidden="true"` for purely decorative iframes.',
  codeExample: '<iframe\n  src="https://example.com/widget"\n  title="Customer feedback form"\n  sandbox="allow-forms allow-scripts"\n  loading="lazy"\n  width="600"\n  height="400"\n></iframe>\n\n<!-- Decorative iframe -->\n<iframe\n  src="background-animation.html"\n  title=""\n  aria-hidden="true"\n  tabindex="-1"\n></iframe>',
  followUp: 'What does the `sandbox` attribute do and what are its individual permission flags?',
  keyTakeaway: 'Iframes must have a descriptive `title` attribute and careful focus management to remain accessible to screen readers and keyboard users.',
},
{
  id: 53,
  title: 'Explain the relationship between HTML semantics and SEO',
  difficulty: 'hard',
  topic: 'semantic-accessibility',
  subtopic: 'seo',
  answer: 'Search engines use HTML semantics to understand page structure, content hierarchy, and relevance. Proper use of heading levels (`<h1>` through `<h6>`) establishes a document outline that helps crawlers determine topic importance. Semantic elements like `<article>`, `<nav>`, `<main>`, and `<aside>` signal content roles, while `<title>`, meta descriptions, and structured data (JSON-LD) provide explicit metadata. Semantic HTML also improves accessibility, which is itself a ranking signal. Using `<a>` for navigation instead of JavaScript click handlers ensures crawlability, and proper `alt` text on images enables image search indexing.',
  codeExample: '<!DOCTYPE html>\n<html lang="en">\n<head>\n  <title>Best Practices for Semantic HTML ‚Äî My Blog</title>\n  <meta name="description" content="Learn how semantic HTML improves SEO and accessibility." />\n  <script type="application/ld+json">\n  {\n    "@context": "https://schema.org",\n    "@type": "Article",\n    "headline": "Best Practices for Semantic HTML",\n    "author": { "@type": "Person", "name": "Jane Doe" }\n  }\n  </script>\n</head>\n<body>\n  <header><nav aria-label="Main">...</nav></header>\n  <main>\n    <article>\n      <h1>Best Practices for Semantic HTML</h1>\n      <p>...</p>\n    </article>\n  </main>\n</body>\n</html>',
  followUp: 'How does structured data (JSON-LD) enhance search engine results beyond basic SEO?',
  keyTakeaway: 'Semantic HTML gives search engines a clear understanding of page structure, content hierarchy, and meaning, directly impacting crawlability and rankings.',
},
{
  id: 54,
  title: 'What are the different input types available in HTML5?',
  difficulty: 'easy',
  topic: 'forms-media',
  subtopic: 'input-types',
  answer: 'HTML5 introduced many new input types beyond the classic `text`, `password`, `checkbox`, `radio`, and `hidden`. These include `email`, `url`, `tel`, `number`, `range`, `date`, `datetime-local`, `month`, `week`, `time`, `color`, and `search`. Each type provides built-in validation, appropriate virtual keyboards on mobile devices, and native UI controls like date pickers and color choosers. Browsers that do not support a given type gracefully fall back to a plain text input.',
  codeExample: '<input type="email" placeholder="user@example.com" required />\n<input type="date" min="2024-01-01" max="2025-12-31" />\n<input type="range" min="0" max="100" step="5" />\n<input type="color" value="#ff6600" />\n<input type="tel" pattern="[0-9]{3}-[0-9]{4}" />\n<input type="number" min="1" max="10" step="1" />',
  followUp: 'How do browsers handle unsupported input types?',
  keyTakeaway: 'HTML5 input types provide built-in validation, optimized mobile keyboards, and native UI controls without requiring JavaScript.',
},
{
  id: 55,
  title: 'What is the purpose of the `<label>` element and how do you associate it with an input?',
  difficulty: 'easy',
  topic: 'forms-media',
  subtopic: 'labels',
  answer: 'The `<label>` element provides an accessible text description for a form control. It can be associated with an input in two ways: explicitly, by setting the `for` attribute to match the input\'s `id`, or implicitly, by nesting the input inside the `<label>`. When properly associated, clicking the label focuses or toggles the input, which improves usability especially for checkboxes and radio buttons. Screen readers announce the label text when a user focuses the associated control, making labels essential for accessibility.',
  codeExample: '<!-- Explicit association -->\n<label for="username">Username</label>\n<input id="username" type="text" name="username" />\n\n<!-- Implicit association -->\n<label>\n  <input type="checkbox" name="agree" />\n  I agree to the terms\n</label>',
  followUp: 'What happens when a form control has no associated label?',
  keyTakeaway: 'Labels associate descriptive text with form controls via `for`/`id` pairing or nesting, improving both usability and accessibility.',
},
{
  id: 56,
  title: 'What is the difference between the `action` and `method` attributes on a `<form>`?',
  difficulty: 'easy',
  topic: 'forms-media',
  subtopic: 'form-attributes',
  answer: 'The `action` attribute specifies the URL where the form data is sent upon submission. If omitted, the form submits to the current page URL. The `method` attribute specifies the HTTP method used: `GET` appends form data as URL query parameters and is suitable for idempotent requests like search, while `POST` sends data in the request body and is appropriate for creating or modifying resources. `POST` is preferred for sensitive data since query strings appear in browser history and server logs.',
  codeExample: '<!-- GET method for search -->\n<form action="/search" method="get">\n  <input type="text" name="q" />\n  <button type="submit">Search</button>\n</form>\n\n<!-- POST method for login -->\n<form action="/api/login" method="post">\n  <input type="email" name="email" />\n  <input type="password" name="password" />\n  <button type="submit">Log In</button>\n</form>',
  followUp: 'What is the `enctype` attribute and when do you need to change it from the default?',
  keyTakeaway: '`action` defines the submission URL and `method` defines the HTTP verb, with `GET` for safe queries and `POST` for data mutations.',
},
{
  id: 57,
  title: 'How do you embed images in HTML and what attributes should you include?',
  difficulty: 'easy',
  topic: 'forms-media',
  subtopic: 'images',
  answer: 'Images are embedded with the `<img>` element, which requires the `src` attribute pointing to the image file and an `alt` attribute providing alternative text for screen readers and broken image fallbacks. You should always include explicit `width` and `height` attributes to reserve layout space and prevent cumulative layout shift (CLS). The `loading="lazy"` attribute defers off-screen images for performance, and `decoding="async"` allows the browser to decode the image off the main thread.',
  codeExample: '<img\n  src="/images/hero.webp"\n  alt="A mountain landscape at sunset"\n  width="1200"\n  height="800"\n  loading="lazy"\n  decoding="async"\n/>',
  followUp: 'What is cumulative layout shift and how do `width` and `height` attributes help prevent it?',
  keyTakeaway: 'Every `<img>` needs `src`, `alt`, `width`, and `height` at minimum, with `loading="lazy"` for off-screen images.',
},
{
  id: 58,
  title: 'What is the `<picture>` element and why is it useful?',
  difficulty: 'easy',
  topic: 'forms-media',
  subtopic: 'responsive-images',
  answer: 'The `<picture>` element is a container that lets you define multiple image sources for different conditions, such as viewport width, pixel density, or image format support. It contains one or more `<source>` elements with `media` and `type` attributes, plus a fallback `<img>` element. The browser selects the first matching `<source>` and ignores the rest. This enables art direction (different crops for different screens) and format negotiation (serving WebP or AVIF to supported browsers while falling back to JPEG).',
  codeExample: '<picture>\n  <source\n    media="(min-width: 800px)"\n    srcset="hero-desktop.avif"\n    type="image/avif"\n  />\n  <source\n    media="(min-width: 800px)"\n    srcset="hero-desktop.webp"\n    type="image/webp"\n  />\n  <source\n    srcset="hero-mobile.webp"\n    type="image/webp"\n  />\n  <img src="hero-mobile.jpg" alt="Hero banner" width="400" height="300" />\n</picture>',
  followUp: 'When would you use `<picture>` instead of `srcset` on an `<img>` element?',
  keyTakeaway: '`<picture>` enables art direction and format negotiation by letting the browser choose the best source from multiple candidates.',
},
{
  id: 59,
  title: 'How do you embed video and audio in HTML5?',
  difficulty: 'easy',
  topic: 'forms-media',
  subtopic: 'media-elements',
  answer: 'HTML5 provides the `<video>` and `<audio>` elements for native media playback without plugins. Both accept `src` for a single source or nested `<source>` elements for multiple formats. Common attributes include `controls` (shows playback UI), `autoplay`, `muted`, `loop`, and `preload`. The `<video>` element additionally supports `poster` for a preview image and `width`/`height` for dimensions. Fallback content between the tags is displayed in browsers that do not support the element.',
  codeExample: '<video controls width="640" height="360" poster="preview.jpg" preload="metadata">\n  <source src="video.webm" type="video/webm" />\n  <source src="video.mp4" type="video/mp4" />\n  <track src="captions.vtt" kind="subtitles" srclang="en" label="English" />\n  Your browser does not support the video element.\n</video>\n\n<audio controls preload="none">\n  <source src="podcast.ogg" type="audio/ogg" />\n  <source src="podcast.mp3" type="audio/mpeg" />\n</audio>',
  followUp: 'What is the `preload` attribute and what are its possible values?',
  keyTakeaway: '`<video>` and `<audio>` provide native media playback with `<source>` elements for format fallbacks and `<track>` for captions.',
},
{
  id: 60,
  title: 'What is the purpose of the `<fieldset>` and `<legend>` elements?',
  difficulty: 'easy',
  topic: 'forms-media',
  subtopic: 'form-grouping',
  answer: 'The `<fieldset>` element groups related form controls together, and the `<legend>` provides a caption for that group. This is especially important for accessibility: screen readers announce the legend text as a group label, giving context to each control within the fieldset. A common use case is grouping radio buttons or checkboxes under a shared question. The `<fieldset>` can also be disabled with the `disabled` attribute, which disables all contained form controls at once.',
  codeExample: '<form>\n  <fieldset>\n    <legend>Shipping Address</legend>\n    <label for="street">Street</label>\n    <input id="street" type="text" name="street" />\n    <label for="city">City</label>\n    <input id="city" type="text" name="city" />\n  </fieldset>\n\n  <fieldset>\n    <legend>Payment Method</legend>\n    <label><input type="radio" name="payment" value="card" /> Credit Card</label>\n    <label><input type="radio" name="payment" value="paypal" /> PayPal</label>\n  </fieldset>\n</form>',
  followUp: 'What happens to form controls inside a disabled `<fieldset>`?',
  keyTakeaway: '`<fieldset>` groups related form controls and `<legend>` labels the group, providing essential context for screen readers.',
},
{
  id: 61,
  title: 'Explain HTML5 client-side form validation attributes',
  difficulty: 'medium',
  topic: 'forms-media',
  subtopic: 'form-validation',
  answer: 'HTML5 provides several attributes for declarative client-side validation. `required` ensures a field is not empty, `pattern` validates against a regular expression, `min` and `max` set numeric or date bounds, `minlength` and `maxlength` constrain text length, and `step` defines valid numeric intervals. Type-specific validation is also built in: `type="email"` checks for a valid email format and `type="url"` checks for a valid URL. The browser displays native error messages and prevents submission when validation fails. The `novalidate` attribute on the form or `formnovalidate` on a submit button can bypass this validation.',
  codeExample: '<form>\n  <input type="text" required minlength="3" maxlength="50"\n    placeholder="Username (3-50 chars)" />\n\n  <input type="email" required\n    placeholder="Email address" />\n\n  <input type="number" min="18" max="120" step="1"\n    placeholder="Age" />\n\n  <input type="text" pattern="[A-Z]{2}\\d{4}"\n    title="Two uppercase letters followed by four digits"\n    placeholder="Code (e.g., AB1234)" />\n\n  <button type="submit">Submit</button>\n</form>',
  followUp: 'How do you customize the native validation error messages?',
  keyTakeaway: 'HTML5 validation attributes like `required`, `pattern`, `min`, `max`, and `minlength` provide declarative form validation without JavaScript.',
},
{
  id: 62,
  title: 'What is the constraint validation API?',
  difficulty: 'medium',
  topic: 'forms-media',
  subtopic: 'validation-api',
  answer: 'The constraint validation API is a set of DOM properties and methods on form elements that allow JavaScript to interact with HTML5 validation. Key properties include `validity` (a `ValidityState` object with flags like `valueMissing`, `typeMismatch`, `patternMismatch`, and `tooShort`), `validationMessage` (the browser\'s error string), and `willValidate` (whether the element participates in validation). Methods include `checkValidity()` (returns boolean and fires `invalid` event), `reportValidity()` (shows the native error UI), and `setCustomValidity()` (sets a custom error message, passing an empty string clears it).',
  codeExample: '<form id="myForm">\n  <input id="email" type="email" required />\n  <input id="age" type="number" min="18" />\n  <button type="submit">Submit</button>\n</form>\n<script>\n  const age = document.getElementById(\'age\');\n  age.addEventListener(\'input\', () => {\n    if (age.validity.rangeUnderflow) {\n      age.setCustomValidity(\'You must be at least 18 years old.\');\n    } else {\n      age.setCustomValidity(\'\');\n    }\n  });\n\n  myForm.addEventListener(\'submit\', (e) => {\n    if (!myForm.checkValidity()) {\n      e.preventDefault();\n      myForm.reportValidity();\n    }\n  });\n</script>',
  followUp: 'What are all the properties available on the `ValidityState` object?',
  keyTakeaway: 'The constraint validation API provides `checkValidity()`, `setCustomValidity()`, and the `ValidityState` object for programmatic control over HTML5 form validation.',
},
{
  id: 63,
  title: 'How does the `<datalist>` element work?',
  difficulty: 'medium',
  topic: 'forms-media',
  subtopic: 'datalist',
  answer: 'The `<datalist>` element provides an autocomplete dropdown of predefined suggestions for an `<input>` element. You connect them by setting the input\'s `list` attribute to the `<datalist>`\'s `id`. Unlike `<select>`, the user is not restricted to the provided options and can type any value. The browser filters suggestions as the user types. It works with various input types including `text`, `email`, `url`, `range`, and `color`. The `<datalist>` itself is hidden and only appears when the associated input is focused.',
  codeExample: '<label for="browser">Choose a browser:</label>\n<input type="text" id="browser" list="browsers" />\n<datalist id="browsers">\n  <option value="Chrome" />\n  <option value="Firefox" />\n  <option value="Safari" />\n  <option value="Edge" />\n</datalist>\n\n<!-- With range input -->\n<input type="range" min="0" max="100" step="25" list="ticks" />\n<datalist id="ticks">\n  <option value="0" label="0%" />\n  <option value="50" label="50%" />\n  <option value="100" label="100%" />\n</datalist>',
  followUp: 'What are the limitations of `<datalist>` compared to custom autocomplete components?',
  keyTakeaway: '`<datalist>` provides native autocomplete suggestions linked to an input via the `list` attribute, while still allowing freeform entry.',
},
{
  id: 64,
  title: 'What is the difference between `<input type="submit">` and `<button type="submit">`?',
  difficulty: 'medium',
  topic: 'forms-media',
  subtopic: 'buttons',
  answer: 'Both submit a form, but `<button type="submit">` is far more flexible. An `<input type="submit">` is a void element whose label is set via the `value` attribute and can only contain plain text. A `<button>` has an opening and closing tag, so it can contain HTML content like icons, `<span>` elements, or images. Both participate in form submission and can carry `name`/`value` pairs, `formaction`, `formmethod`, and `formnovalidate` overrides. Note that a `<button>` inside a form defaults to `type="submit"` if no type is specified, which can cause accidental submissions.',
  codeExample: '<!-- Input submit ‚Äî plain text only -->\n<input type="submit" value="Submit Form" />\n\n<!-- Button submit ‚Äî can contain rich HTML -->\n<button type="submit">\n  <svg aria-hidden="true"><!-- icon --></svg>\n  Submit Form\n</button>\n\n<!-- Button with form overrides -->\n<button type="submit" formaction="/draft" formmethod="post" formnovalidate>\n  Save as Draft\n</button>\n\n<!-- Always set type to avoid accidental submission -->\n<button type="button" onclick="doSomething()">Click Me</button>',
  followUp: 'Why should you always explicitly set `type` on a `<button>` element?',
  keyTakeaway: '`<button type="submit">` can contain rich HTML content while `<input type="submit">` only supports plain text via its `value` attribute.',
},
{
  id: 65,
  title: 'How do you implement a responsive image strategy in HTML?',
  difficulty: 'medium',
  topic: 'forms-media',
  subtopic: 'responsive-images',
  answer: 'A responsive image strategy combines `srcset`, `sizes`, and the `<picture>` element. Use `srcset` with width descriptors (`w`) to provide the browser with multiple resolutions of the same image, and `sizes` to tell the browser how wide the image will be at each breakpoint so it can pick the optimal file. For art direction (different crops or aspect ratios at different breakpoints), wrap `<source>` elements with `media` queries inside `<picture>`. For format negotiation, use `<source>` with the `type` attribute. Always include `width` and `height` on the fallback `<img>` to prevent layout shift.',
  codeExample: '<!-- Resolution switching with srcset + sizes -->\n<img\n  srcset="photo-400.jpg 400w, photo-800.jpg 800w, photo-1200.jpg 1200w"\n  sizes="(max-width: 600px) 100vw, (max-width: 1000px) 50vw, 33vw"\n  src="photo-800.jpg"\n  alt="Responsive photo"\n  width="800"\n  height="600"\n  loading="lazy"\n/>\n\n<!-- Art direction with <picture> -->\n<picture>\n  <source media="(max-width: 600px)" srcset="hero-portrait.webp" type="image/webp" />\n  <source media="(min-width: 601px)" srcset="hero-landscape.webp" type="image/webp" />\n  <img src="hero-landscape.jpg" alt="Hero" width="1200" height="600" />\n</picture>',
  followUp: 'How does the browser decide which image to download from `srcset`?',
  keyTakeaway: 'Combine `srcset` with `sizes` for resolution switching and `<picture>` with `<source>` for art direction and format negotiation.',
},
{
  id: 66,
  title: 'What is the `<canvas>` element and how does it differ from SVG?',
  difficulty: 'medium',
  topic: 'forms-media',
  subtopic: 'canvas-vs-svg',
  answer: 'The `<canvas>` element provides a bitmap drawing surface that you manipulate via JavaScript using the 2D rendering context or WebGL. It is immediate-mode: once pixels are drawn, the canvas has no memory of individual objects. SVG, by contrast, is a retained-mode, vector-based XML format where each shape is a DOM element that can be styled with CSS, animated, and made accessible. Canvas excels at high-performance rendering with many objects (games, data visualizations with thousands of points), while SVG is better for scalable graphics, icons, and interactive diagrams where individual elements need event handling and accessibility.',
  codeExample: '<!-- Canvas: pixel-based, imperative -->\n<canvas id="myCanvas" width="400" height="300">Fallback text</canvas>\n<script>\n  const ctx = document.getElementById(\'myCanvas\').getContext(\'2d\');\n  ctx.fillStyle = \'#3b82f6\';\n  ctx.fillRect(10, 10, 150, 100);\n  ctx.beginPath();\n  ctx.arc(300, 150, 50, 0, Math.PI * 2);\n  ctx.fill();\n</script>\n\n<!-- SVG: vector-based, declarative -->\n<svg width="400" height="300" role="img" aria-label="Blue shapes">\n  <rect x="10" y="10" width="150" height="100" fill="#3b82f6" />\n  <circle cx="300" cy="150" r="50" fill="#3b82f6" />\n</svg>',
  followUp: 'When would you choose Canvas over SVG for a data visualization?',
  keyTakeaway: 'Canvas is a pixel-based immediate-mode surface controlled by JavaScript, while SVG is a vector-based retained-mode format with DOM elements.',
},
{
  id: 67,
  title: 'What are the different ways to embed SVG in an HTML page?',
  difficulty: 'medium',
  topic: 'forms-media',
  subtopic: 'svg',
  answer: 'SVG can be embedded in several ways, each with trade-offs. Inline SVG places the `<svg>` markup directly in HTML, giving full access to CSS styling and JavaScript manipulation. An `<img>` tag with an SVG `src` is simple but blocks CSS and JS access to SVG internals. CSS `background-image` works for decorative SVGs but has the same limitations. The `<object>` element loads an external SVG file while preserving its internal DOM for scripting. The `<use>` element within an inline SVG can reference symbols from an external sprite file. Each method affects cacheability, styling capability, and accessibility differently.',
  codeExample: '<!-- 1. Inline SVG ‚Äî full CSS/JS access -->\n<svg width="24" height="24" viewBox="0 0 24 24" aria-hidden="true">\n  <path d="M12 2L2 22h20L12 2z" fill="currentColor" />\n</svg>\n\n<!-- 2. img tag ‚Äî simple, no internal access -->\n<img src="icon.svg" alt="Warning icon" width="24" height="24" />\n\n<!-- 3. object tag ‚Äî external file, scriptable -->\n<object data="diagram.svg" type="image/svg+xml" width="400" height="300">\n  Fallback content\n</object>\n\n<!-- 4. SVG sprite with use -->\n<svg aria-hidden="true">\n  <use href="sprites.svg#icon-warning" />\n</svg>',
  followUp: 'What are the performance implications of inline SVG versus external SVG files?',
  keyTakeaway: 'SVG can be embedded inline, via `<img>`, `<object>`, CSS backgrounds, or sprite `<use>` references, each offering different levels of styling and scripting access.',
},
{
  id: 68,
  title: 'What is the `srcset` attribute and how does it work?',
  difficulty: 'medium',
  topic: 'forms-media',
  subtopic: 'responsive-images',
  answer: 'The `srcset` attribute on `<img>` (and `<source>`) provides the browser with a list of image candidates and their descriptors so it can choose the most appropriate one. Width descriptors (`w`) declare each image\'s intrinsic pixel width, and the browser combines this with the `sizes` attribute and device pixel ratio to select the best file. Pixel density descriptors (`x`) like `1x`, `2x`, `3x` are simpler and let the browser pick based solely on display density. When using `w` descriptors, the `sizes` attribute is required so the browser knows the image\'s rendered width at each breakpoint.',
  codeExample: '<!-- Width descriptors ‚Äî browser picks based on viewport + DPR -->\n<img\n  srcset="photo-320.jpg 320w, photo-640.jpg 640w, photo-1280.jpg 1280w"\n  sizes="(max-width: 480px) 100vw, (max-width: 960px) 50vw, 33vw"\n  src="photo-640.jpg"\n  alt="A scenic landscape"\n/>\n\n<!-- Pixel density descriptors ‚Äî simpler, fixed layout size -->\n<img\n  srcset="logo.png 1x, logo@2x.png 2x, logo@3x.png 3x"\n  src="logo.png"\n  alt="Company logo"\n  width="200"\n  height="60"\n/>',
  followUp: 'Can `w` and `x` descriptors be mixed in the same `srcset`?',
  keyTakeaway: '`srcset` provides multiple image candidates with width (`w`) or density (`x`) descriptors so the browser can select the optimal file for the user\'s device.',
},
{
  id: 69,
  title: 'How do you handle file uploads in HTML forms?',
  difficulty: 'medium',
  topic: 'forms-media',
  subtopic: 'file-upload',
  answer: 'File uploads use `<input type="file">`, and the form must set `enctype="multipart/form-data"` with `method="post"` for the server to receive the file data. The `accept` attribute restricts selectable file types using MIME types or extensions (e.g., `accept="image/*"` or `accept=".pdf,.doc"`). The `multiple` attribute allows selecting more than one file. JavaScript can access selected files via the `FileList` on `input.files`, enabling client-side validation of file size and type before upload. The File API also enables reading file contents with `FileReader` for previews.',
  codeExample: '<form action="/upload" method="post" enctype="multipart/form-data">\n  <label for="avatar">Upload avatar:</label>\n  <input\n    type="file"\n    id="avatar"\n    name="avatar"\n    accept="image/png, image/jpeg, image/webp"\n  />\n\n  <label for="docs">Upload documents:</label>\n  <input\n    type="file"\n    id="docs"\n    name="docs"\n    accept=".pdf,.docx"\n    multiple\n  />\n\n  <button type="submit">Upload</button>\n</form>\n<script>\n  document.getElementById(\'avatar\').addEventListener(\'change\', (e) => {\n    const file = e.target.files[0];\n    if (file.size > 5 * 1024 * 1024) alert(\'File must be under 5MB\');\n  });\n</script>',
  followUp: 'How would you implement a drag-and-drop file upload area?',
  keyTakeaway: 'File uploads require `<input type="file">` with `enctype="multipart/form-data"` on the form, and `accept` and `multiple` for controlling file selection.',
},
{
  id: 70,
  title: 'What is the `<output>` element used for?',
  difficulty: 'medium',
  topic: 'forms-media',
  subtopic: 'form-output',
  answer: 'The `<output>` element represents the result of a calculation or user action within a form. It has a `for` attribute that takes a space-separated list of `id`s of the input elements that contributed to the result, establishing a semantic relationship. It also supports `name` for form submission and `form` to associate with a form outside its DOM tree. Screen readers announce changes to `<output>` because it has an implicit `role="status"` with `aria-live="polite"`, making it ideal for displaying dynamic results accessibly.',
  codeExample: '<form oninput="result.value = Number(a.value) + Number(b.value)">\n  <label for="a">Value A:</label>\n  <input type="number" id="a" name="a" value="0" />\n\n  <label for="b">Value B:</label>\n  <input type="number" id="b" name="b" value="0" />\n\n  <p>Sum: <output name="result" for="a b">0</output></p>\n</form>\n\n<!-- Range slider with live output -->\n<form oninput="vol.value = volume.value">\n  <label for="volume">Volume:</label>\n  <input type="range" id="volume" name="volume" min="0" max="100" value="50" />\n  <output name="vol" for="volume">50</output>\n</form>',
  followUp: 'How does the implicit ARIA live region on `<output>` benefit screen reader users?',
  keyTakeaway: '`<output>` semantically represents a computed result in a form and acts as an implicit ARIA live region for accessible dynamic updates.',
},
{
  id: 71,
  title: 'How does the `<canvas>` element handle pixel density and retina displays?',
  difficulty: 'hard',
  topic: 'forms-media',
  subtopic: 'canvas',
  answer: 'By default, a `<canvas>` renders at 1x resolution regardless of the display\'s pixel density, resulting in blurry output on retina (high-DPI) screens. To fix this, you must scale the canvas backing store by `window.devicePixelRatio`. Set the canvas element\'s `width` and `height` attributes to the display size multiplied by the device pixel ratio, then use CSS to constrain the visual size to the original dimensions. Finally, call `ctx.scale(dpr, dpr)` so all drawing operations use logical coordinates. This approach renders crisp graphics at the native display resolution while maintaining consistent coordinate math.',
  codeExample: '<canvas id="hires" style="width: 400px; height: 300px;"></canvas>\n<script>\n  const canvas = document.getElementById(\'hires\');\n  const ctx = canvas.getContext(\'2d\');\n  const dpr = window.devicePixelRatio || 1;\n\n  // Scale the backing store\n  canvas.width = 400 * dpr;\n  canvas.height = 300 * dpr;\n\n  // Scale drawing context to match\n  ctx.scale(dpr, dpr);\n\n  // Now draw in logical pixels\n  ctx.fillStyle = \'#3b82f6\';\n  ctx.fillRect(10, 10, 100, 80);\n  ctx.font = \'16px sans-serif\';\n  ctx.fillText(\'Crisp on retina!\', 10, 120);\n</script>',
  followUp: 'How does `OffscreenCanvas` improve canvas performance on high-DPI displays?',
  keyTakeaway: 'Canvas must be scaled by `devicePixelRatio` in its backing store dimensions and drawing context to render crisply on retina displays.',
},
{
  id: 72,
  title: 'What is the `formnovalidate` attribute and when would you use it?',
  difficulty: 'hard',
  topic: 'forms-media',
  subtopic: 'form-validation',
  answer: 'The `formnovalidate` attribute on a submit button bypasses HTML5 constraint validation for that specific submission while leaving validation intact for other submit buttons in the same form. This is essential for "Save as Draft" functionality where you want users to save incomplete data without triggering required field errors, while the primary "Submit" button still enforces full validation. It is a boolean attribute that can be placed on `<button type="submit">` or `<input type="submit">`. The form-level `novalidate` attribute disables validation entirely, but `formnovalidate` offers per-button control.',
  codeExample: '<form action="/submit" method="post">\n  <label for="title">Title (required):</label>\n  <input type="text" id="title" name="title" required />\n\n  <label for="body">Body (required):</label>\n  <textarea id="body" name="body" required></textarea>\n\n  <!-- This button validates -->\n  <button type="submit">Publish</button>\n\n  <!-- This button skips validation -->\n  <button type="submit" formnovalidate formaction="/draft">\n    Save as Draft\n  </button>\n</form>',
  followUp: 'Can `formnovalidate` be set dynamically via JavaScript?',
  keyTakeaway: '`formnovalidate` on a submit button bypasses form validation for that specific submission, enabling patterns like save-as-draft alongside validated publish.',
},
{
  id: 73,
  title: 'How do you implement accessible form error handling?',
  difficulty: 'hard',
  topic: 'forms-media',
  subtopic: 'form-accessibility',
  answer: 'Accessible form error handling requires multiple techniques working together. Use `aria-describedby` on inputs to link them to their error messages, and `aria-invalid="true"` to mark fields with errors. An error summary at the top of the form (linked via `aria-live="assertive"` or by moving focus to it) ensures screen reader users are notified immediately. Each error message should be specific and actionable. Use `role="alert"` or inject error text into existing `aria-describedby` containers so screen readers announce changes. Visual indicators like color should be supplemented with icons or text, since color alone is insufficient for colorblind users.',
  codeExample: '<form id="regForm" novalidate>\n  <!-- Error summary -->\n  <div id="errorSummary" role="alert" aria-live="assertive" hidden>\n    <h2>Please fix the following errors:</h2>\n    <ul id="errorList"></ul>\n  </div>\n\n  <div>\n    <label for="email">Email *</label>\n    <input\n      type="email"\n      id="email"\n      name="email"\n      required\n      aria-describedby="emailError"\n      aria-invalid="false"\n    />\n    <span id="emailError" class="error" hidden>\n      Please enter a valid email address.\n    </span>\n  </div>\n\n  <button type="submit">Register</button>\n</form>\n<script>\n  regForm.addEventListener(\'submit\', (e) => {\n    const email = document.getElementById(\'email\');\n    if (!email.validity.valid) {\n      e.preventDefault();\n      email.setAttribute(\'aria-invalid\', \'true\');\n      document.getElementById(\'emailError\').hidden = false;\n      document.getElementById(\'errorSummary\').hidden = false;\n      email.focus();\n    }\n  });\n</script>',
  followUp: 'Should you use native browser validation, custom validation, or both?',
  keyTakeaway: 'Accessible form errors require `aria-invalid`, `aria-describedby`, a live error summary, and visual indicators beyond color alone.',
},
{
  id: 74,
  title: 'What are the security considerations for HTML forms?',
  difficulty: 'hard',
  topic: 'forms-media',
  subtopic: 'form-security',
  answer: 'HTML forms are a primary attack vector for web applications. Key concerns include cross-site request forgery (CSRF), which is mitigated by including a unique token in a hidden field that the server validates. Cross-site scripting (XSS) can occur when user input from forms is rendered without sanitization. Forms should always use `method="post"` for state-changing operations to avoid sensitive data appearing in URLs and browser history. The `autocomplete="off"` attribute prevents browsers from caching sensitive fields. HTTPS is essential to prevent form data interception. Server-side validation is mandatory because client-side validation can be trivially bypassed.',
  codeExample: '<form action="/transfer" method="post" autocomplete="off">\n  <!-- CSRF token -->\n  <input type="hidden" name="csrf_token" value="a1b2c3d4e5f6" />\n\n  <!-- Honeypot field to catch bots -->\n  <div style="display: none;" aria-hidden="true">\n    <input type="text" name="website" tabindex="-1" autocomplete="off" />\n  </div>\n\n  <label for="amount">Amount:</label>\n  <input\n    type="number"\n    id="amount"\n    name="amount"\n    min="1"\n    max="10000"\n    required\n    autocomplete="off"\n  />\n\n  <label for="recipient">Recipient:</label>\n  <input type="text" id="recipient" name="recipient" required />\n\n  <button type="submit">Transfer</button>\n</form>',
  followUp: 'How does the `SameSite` cookie attribute help protect against CSRF?',
  keyTakeaway: 'Form security requires CSRF tokens, HTTPS, server-side validation, and careful handling of autocomplete and sensitive data exposure.',
},
{
  id: 75,
  title: 'How does `<source>` element negotiation work for `<picture>`, `<video>`, and `<audio>`?',
  difficulty: 'hard',
  topic: 'forms-media',
  subtopic: 'source-negotiation',
  answer: 'The browser evaluates `<source>` elements in document order and selects the first one whose conditions are met. For `<picture>`, the browser checks each `<source>`\'s `media` attribute (viewport conditions) and `type` attribute (format support), selecting the first match and using that source for the child `<img>`. For `<video>` and `<audio>`, the browser evaluates `type` attributes (including the `codecs` parameter) and picks the first format it can play, ignoring the rest. If no `<source>` matches, the fallback `<img>` src is used for `<picture>`, and fallback content between the media tags is shown. The `media` attribute is only supported on `<source>` within `<picture>`, not within `<video>` or `<audio>`.',
  codeExample: '<!-- Picture: media + type negotiation -->\n<picture>\n  <source media="(min-width: 1024px)" srcset="wide.avif" type="image/avif" />\n  <source media="(min-width: 1024px)" srcset="wide.webp" type="image/webp" />\n  <source srcset="narrow.avif" type="image/avif" />\n  <source srcset="narrow.webp" type="image/webp" />\n  <img src="narrow.jpg" alt="Responsive hero" />\n</picture>\n\n<!-- Video: codec negotiation -->\n<video controls>\n  <source src="movie.av1.mp4" type=\'video/mp4; codecs="av01.0.05M.08"\' />\n  <source src="movie.h265.mp4" type=\'video/mp4; codecs="hvc1"\' />\n  <source src="movie.h264.mp4" type=\'video/mp4; codecs="avc1.42E01E"\' />\n  <source src="movie.webm" type="video/webm" />\n</video>',
  followUp: 'Why does source order matter and what happens if you put the JPEG source first in a `<picture>` element?',
  keyTakeaway: 'The browser evaluates `<source>` elements top-to-bottom, selecting the first whose `media` and `type` conditions match, so order determines priority.',
},
{
  id: 76,
  title: 'What is the `capture` attribute on file inputs and how does it work on mobile?',
  difficulty: 'hard',
  topic: 'forms-media',
  subtopic: 'file-upload',
  answer: 'The `capture` attribute on `<input type="file">` instructs mobile browsers to bypass the file picker and directly open the device camera or microphone for capturing new media. When set to `"user"`, it opens the front-facing camera, and `"environment"` opens the rear-facing camera. Combined with the `accept` attribute, it controls whether the camera captures photos (`accept="image/*"`) or video (`accept="video/*"`). On desktop browsers, the attribute is generally ignored. The attribute is a progressive enhancement: if the device lacks a camera, the browser falls back to the standard file picker.',
  codeExample: '<!-- Capture photo with rear camera -->\n<label for="photo">Take a photo:</label>\n<input\n  type="file"\n  id="photo"\n  accept="image/*"\n  capture="environment"\n/>\n\n<!-- Capture selfie with front camera -->\n<label for="selfie">Take a selfie:</label>\n<input\n  type="file"\n  id="selfie"\n  accept="image/*"\n  capture="user"\n/>\n\n<!-- Record video -->\n<label for="video">Record a video:</label>\n<input\n  type="file"\n  id="video"\n  accept="video/*"\n  capture="environment"\n/>\n\n<!-- Record audio -->\n<label for="audio">Record audio:</label>\n<input\n  type="file"\n  id="audio"\n  accept="audio/*"\n  capture\n/>',
  followUp: 'How does the `capture` attribute interact with the `multiple` attribute?',
  keyTakeaway: 'The `capture` attribute opens the device camera or microphone directly for media capture, with `"user"` for front-facing and `"environment"` for rear-facing.',
},
{
  id: 77,
  title: 'How do you handle cross-origin images and the `crossorigin` attribute?',
  difficulty: 'hard',
  topic: 'forms-media',
  subtopic: 'cors',
  answer: 'The `crossorigin` attribute on `<img>`, `<video>`, `<audio>`, `<link>`, and `<script>` elements controls how the browser handles CORS requests for cross-origin resources. Without it, cross-origin images load normally but become "tainted": they cannot be read by `<canvas>` (`getImageData()` or `toDataURL()` will throw a security error). Setting `crossorigin="anonymous"` sends the request without credentials and requires the server to respond with `Access-Control-Allow-Origin`. Setting `crossorigin="use-credentials"` includes cookies and requires the server to also set `Access-Control-Allow-Credentials: true`. The server must send the proper CORS headers regardless of the attribute value.',
  codeExample: '<!-- Anonymous: no credentials, enables canvas reading -->\n<img\n  src="https://cdn.example.com/photo.jpg"\n  crossorigin="anonymous"\n  alt="Cross-origin photo"\n/>\n\n<!-- With credentials: sends cookies -->\n<img\n  src="https://api.example.com/avatar"\n  crossorigin="use-credentials"\n  alt="User avatar"\n/>\n\n<script>\n  // Without crossorigin, this would throw a SecurityError\n  const canvas = document.createElement(\'canvas\');\n  const ctx = canvas.getContext(\'2d\');\n  const img = document.querySelector(\'img[crossorigin]\');\n  img.onload = () => {\n    ctx.drawImage(img, 0, 0);\n    const data = ctx.getImageData(0, 0, 100, 100); // Works with CORS\n  };\n</script>',
  followUp: 'What happens if the server does not include the correct CORS headers when `crossorigin` is set?',
  keyTakeaway: 'The `crossorigin` attribute enables CORS requests for media elements, preventing canvas tainting and allowing programmatic access to cross-origin resources.',
},
{
  id: 78,
  title: 'What are the best practices for accessible multimedia content?',
  difficulty: 'hard',
  topic: 'forms-media',
  subtopic: 'media-accessibility',
  answer: 'Accessible multimedia requires captions, transcripts, and audio descriptions. Use the `<track>` element with `kind="subtitles"` or `kind="captions"` for synchronized text in WebVTT format. Provide `kind="descriptions"` for audio descriptions of visual content for blind users. A full text transcript should be available alongside any audio or video content. Never rely on `autoplay` as it can disorient screen reader users; if autoplay is necessary, the media must be `muted`. Ensure custom video players have keyboard-accessible controls with proper ARIA labels. Use `aria-label` or `aria-labelledby` on the media element itself to describe its purpose.',
  codeExample: '<figure>\n  <video\n    controls\n    width="640"\n    height="360"\n    aria-labelledby="videoTitle"\n    preload="metadata"\n  >\n    <source src="talk.mp4" type="video/mp4" />\n    <track\n      src="captions-en.vtt"\n      kind="captions"\n      srclang="en"\n      label="English captions"\n      default\n    />\n    <track\n      src="captions-es.vtt"\n      kind="subtitles"\n      srclang="es"\n      label="Spanish subtitles"\n    />\n    <track\n      src="descriptions.vtt"\n      kind="descriptions"\n      srclang="en"\n      label="Audio descriptions"\n    />\n  </video>\n  <figcaption id="videoTitle">Conference Talk: Web Accessibility in 2025</figcaption>\n</figure>\n\n<details>\n  <summary>View full transcript</summary>\n  <div class="transcript">...</div>\n</details>',
  followUp: 'What is the difference between `kind="captions"` and `kind="subtitles"` on a `<track>` element?',
  keyTakeaway: 'Accessible multimedia requires captions via `<track>`, text transcripts, audio descriptions, keyboard-accessible controls, and no unexpected autoplay.',
},
{
  id: 79,
  title: 'What is the `<dialog>` element and how do you use it?',
  difficulty: 'easy',
  topic: 'modern-apis',
  subtopic: 'dialog',
  answer: 'The `<dialog>` element is a native HTML element for creating modal and non-modal dialog boxes. Calling `showModal()` opens it as a modal with a backdrop that prevents interaction with the rest of the page, traps focus inside, and closes on Escape key press. Calling `show()` opens it as a non-modal dialog. The `close()` method closes it and fires a `close` event. The `::backdrop` pseudo-element allows styling the overlay behind a modal dialog. It also has a `returnValue` property that captures the value from any button with `method="dialog"` on a contained form.',
  codeExample: '<dialog id="myDialog">\n  <h2>Confirm Delete</h2>\n  <p>This action cannot be undone.</p>\n  <form method="dialog">\n    <button value="cancel">Cancel</button>\n    <button value="confirm">Confirm</button>\n  </form>\n</dialog>\n\n<button onclick="myDialog.showModal()">Delete Item</button>\n\n<script>\n  myDialog.addEventListener(\'close\', () => {\n    if (myDialog.returnValue === \'confirm\') {\n      // Perform delete\n    }\n  });\n</script>\n\n<style>\n  dialog::backdrop {\n    background: rgba(0, 0, 0, 0.5);\n  }\n</style>',
  followUp: 'What is the difference between `show()` and `showModal()` on a dialog element?',
  keyTakeaway: 'The `<dialog>` element provides native modal and non-modal dialogs with built-in focus trapping, Escape key handling, and backdrop styling.',
},
{
  id: 80,
  title: 'What are the `<details>` and `<summary>` elements?',
  difficulty: 'easy',
  topic: 'modern-apis',
  subtopic: 'disclosure',
  answer: 'The `<details>` element creates a native disclosure widget that the user can toggle open or closed. The `<summary>` element provides the visible heading that the user clicks to expand or collapse the content. If no `<summary>` is provided, the browser shows a default "Details" label. The `open` attribute controls the initial state and can be toggled programmatically. A `toggle` event fires when the state changes. These elements are accessible by default: screen readers announce the expanded/collapsed state, and they work with keyboard navigation without any JavaScript.',
  codeExample: '<details>\n  <summary>System Requirements</summary>\n  <ul>\n    <li>Node.js 18 or higher</li>\n    <li>4 GB RAM minimum</li>\n    <li>macOS, Windows, or Linux</li>\n  </ul>\n</details>\n\n<!-- Open by default -->\n<details open>\n  <summary>FAQ: How do I reset my password?</summary>\n  <p>Go to Settings, click Security, then click Reset Password.</p>\n</details>\n\n<script>\n  document.querySelector(\'details\').addEventListener(\'toggle\', (e) => {\n    console.log(e.target.open ? \'opened\' : \'closed\');\n  });\n</script>',
  followUp: 'Can you use `<details>` elements to create an accordion where only one panel is open at a time?',
  keyTakeaway: '`<details>` and `<summary>` create a native, accessible disclosure widget with toggle functionality and no JavaScript required.',
},
{
  id: 81,
  title: 'What is the `loading="lazy"` attribute and which elements support it?',
  difficulty: 'easy',
  topic: 'modern-apis',
  subtopic: 'lazy-loading',
  answer: 'The `loading="lazy"` attribute defers loading of off-screen resources until the user scrolls near them, reducing initial page load time and saving bandwidth. It is natively supported on `<img>` and `<iframe>` elements. The browser determines the distance threshold for when to start loading. The alternative value `loading="eager"` (the default) loads the resource immediately. You should not lazy-load images that are visible in the initial viewport (above the fold), such as hero images or LCP elements, as this would delay their rendering and hurt Core Web Vitals scores.',
  codeExample: '<!-- Lazy load off-screen images -->\n<img\n  src="photo.jpg"\n  alt="Lazy loaded photo"\n  width="800"\n  height="600"\n  loading="lazy"\n  decoding="async"\n/>\n\n<!-- Lazy load iframe -->\n<iframe\n  src="https://www.youtube.com/embed/abc123"\n  width="560"\n  height="315"\n  loading="lazy"\n  title="Video tutorial"\n></iframe>\n\n<!-- Do NOT lazy load above-the-fold / LCP images -->\n<img\n  src="hero.jpg"\n  alt="Hero banner"\n  width="1200"\n  height="600"\n  loading="eager"\n  fetchpriority="high"\n/>',
  followUp: 'What is the `fetchpriority` attribute and how does it complement `loading`?',
  keyTakeaway: '`loading="lazy"` defers off-screen `<img>` and `<iframe>` loading until needed, but should not be used on above-the-fold content.',
},
{
  id: 82,
  title: 'What is the `<template>` element used for?',
  difficulty: 'easy',
  topic: 'modern-apis',
  subtopic: 'template',
  answer: 'The `<template>` element holds HTML content that is parsed by the browser but not rendered or executed until explicitly cloned and inserted into the DOM via JavaScript. Its content lives in a `DocumentFragment` accessible via the `content` property. Scripts inside a template do not execute, images do not load, and styles do not apply until the template is instantiated. This makes it ideal for defining reusable markup patterns, dynamic list items, or Web Component structures that are stamped out on demand without the overhead of hidden `display: none` elements.',
  codeExample: '<template id="cardTemplate">\n  <article class="card">\n    <h3 class="card-title"></h3>\n    <p class="card-body"></p>\n    <button>Read More</button>\n  </article>\n</template>\n\n<div id="container"></div>\n\n<script>\n  const template = document.getElementById(\'cardTemplate\');\n  const container = document.getElementById(\'container\');\n\n  const data = [\n    { title: \'First Post\', body: \'Hello world\' },\n    { title: \'Second Post\', body: \'Another entry\' },\n  ];\n\n  data.forEach(item => {\n    const clone = template.content.cloneNode(true);\n    clone.querySelector(\'.card-title\').textContent = item.title;\n    clone.querySelector(\'.card-body\').textContent = item.body;\n    container.appendChild(clone);\n  });\n</script>',
  followUp: 'How do `<template>` elements differ from using `display: none` on a container?',
  keyTakeaway: '`<template>` holds inert HTML that is parsed but not rendered until cloned into the DOM via JavaScript, making it ideal for reusable markup patterns.',
},
{
  id: 83,
  title: 'What is the `contenteditable` attribute?',
  difficulty: 'easy',
  topic: 'modern-apis',
  subtopic: 'contenteditable',
  answer: 'The `contenteditable` attribute makes any HTML element editable by the user directly in the browser, turning it into a rich-text editor. Setting it to `"true"` enables editing, `"false"` disables it, and `"plaintext-only"` (where supported) restricts input to plain text without formatting. The element emits `input` events as the user types, and its content can be read via `innerHTML` or `textContent`. While convenient, `contenteditable` is notoriously inconsistent across browsers in how it generates markup, making it challenging for production rich-text editors without a library like ProseMirror or TipTap.',
  codeExample: '<!-- Rich text editable -->\n<div\n  contenteditable="true"\n  role="textbox"\n  aria-label="Write your comment"\n  aria-multiline="true"\n  style="min-height: 100px; border: 1px solid #ccc; padding: 8px;"\n>\n  Start typing here...\n</div>\n\n<!-- Plain text only -->\n<div contenteditable="plaintext-only">\n  Only plain text allowed\n</div>\n\n<script>\n  document.querySelector(\'[contenteditable]\').addEventListener(\'input\', (e) => {\n    console.log(\'Content:\', e.target.innerHTML);\n  });\n</script>',
  followUp: 'Why is raw `contenteditable` considered problematic for building rich-text editors?',
  keyTakeaway: '`contenteditable` makes any element user-editable in the browser, but cross-browser inconsistencies make it unreliable without a dedicated editing library.',
},
{
  id: 84,
  title: 'What are Web Components and their main building blocks?',
  difficulty: 'medium',
  topic: 'modern-apis',
  subtopic: 'web-components',
  answer: 'Web Components are a set of browser-native APIs for creating reusable, encapsulated custom HTML elements. The three main building blocks are Custom Elements (define new HTML tags with `customElements.define()`), Shadow DOM (provides encapsulated DOM and styling via `attachShadow()`), and HTML Templates (`<template>` and `<slot>` elements for declarative markup). Together, these allow you to create components with their own lifecycle callbacks (`connectedCallback`, `disconnectedCallback`, `attributeChangedCallback`), scoped styles that do not leak out or get affected by external CSS, and composable content projection through slots.',
  codeExample: 'class MyAlert extends HTMLElement {\n  static observedAttributes = [\'type\'];\n\n  constructor() {\n    super();\n    const shadow = this.attachShadow({ mode: \'open\' });\n    shadow.innerHTML = `\n      <style>\n        :host { display: block; padding: 12px; border-radius: 4px; }\n        :host([type="error"]) { background: #fee; color: #c00; }\n        :host([type="success"]) { background: #efe; color: #060; }\n      </style>\n      <slot></slot>\n    `;\n  }\n\n  connectedCallback() {\n    this.setAttribute(\'role\', \'alert\');\n  }\n\n  attributeChangedCallback(name, oldVal, newVal) {\n    // React to attribute changes\n  }\n}\n\ncustomElements.define(\'my-alert\', MyAlert);\n\n// Usage: <my-alert type="error">Something went wrong</my-alert>',
  followUp: 'How do Web Components compare to framework components like React or Vue components?',
  keyTakeaway: 'Web Components combine Custom Elements, Shadow DOM, and HTML Templates to create reusable, encapsulated HTML elements with native browser support.',
},
{
  id: 85,
  title: 'How does the Shadow DOM work and why is it useful?',
  difficulty: 'medium',
  topic: 'modern-apis',
  subtopic: 'shadow-dom',
  answer: 'The Shadow DOM creates an encapsulated DOM subtree attached to an element via `attachShadow({ mode: "open" })` or `{ mode: "closed" }`. Styles defined inside the shadow tree do not affect the outer document, and external styles do not penetrate into it (with the exception of inherited properties like `font-family` and `color`). The shadow root acts as a scoping boundary for selectors, IDs, and `querySelector`. In `open` mode, JavaScript can access the shadow root via `element.shadowRoot`; in `closed` mode, it returns `null`. CSS custom properties (variables) cross the shadow boundary, making them the primary theming mechanism.',
  codeExample: 'class StyledCard extends HTMLElement {\n  constructor() {\n    super();\n    const shadow = this.attachShadow({ mode: \'open\' });\n    shadow.innerHTML = `\n      <style>\n        /* Scoped ‚Äî won\'t leak out */\n        :host {\n          display: block;\n          border: 1px solid var(--card-border, #ddd);\n          border-radius: 8px;\n          padding: 16px;\n        }\n        h2 { margin: 0 0 8px; color: var(--card-heading-color, #333); }\n        ::slotted(p) { margin: 0; }\n      </style>\n      <h2><slot name="title">Default Title</slot></h2>\n      <slot></slot>\n    `;\n  }\n}\ncustomElements.define(\'styled-card\', StyledCard);\n\n// External CSS variables can theme it:\n// styled-card { --card-border: blue; --card-heading-color: navy; }',
  followUp: 'What is the difference between `open` and `closed` shadow DOM modes?',
  keyTakeaway: 'Shadow DOM encapsulates styles and DOM structure within a component, preventing style leakage while allowing theming through CSS custom properties.',
},
{
  id: 86,
  title: 'What are custom elements and how do you define them?',
  difficulty: 'medium',
  topic: 'modern-apis',
  subtopic: 'custom-elements',
  answer: 'Custom elements let you define new HTML tags by extending `HTMLElement` (autonomous custom elements) or a built-in element like `HTMLButtonElement` (customized built-in elements). You register them with `customElements.define(\'my-tag\', MyClass)`. The tag name must contain a hyphen to avoid conflicts with future HTML elements. Custom elements have lifecycle callbacks: `constructor()` for initialization, `connectedCallback()` when added to the DOM, `disconnectedCallback()` when removed, `attributeChangedCallback()` for observed attribute changes, and `adoptedCallback()` when moved to a new document. The `static observedAttributes` array declares which attributes trigger the callback.',
  codeExample: 'class CounterButton extends HTMLElement {\n  static observedAttributes = [\'count\'];\n\n  constructor() {\n    super();\n    this.count = 0;\n    this.attachShadow({ mode: \'open\' });\n  }\n\n  connectedCallback() {\n    this.render();\n    this.shadowRoot.querySelector(\'button\')\n      .addEventListener(\'click\', () => this.increment());\n  }\n\n  disconnectedCallback() {\n    // Clean up event listeners if needed\n  }\n\n  attributeChangedCallback(name, oldVal, newVal) {\n    if (name === \'count\') {\n      this.count = Number(newVal);\n      this.render();\n    }\n  }\n\n  increment() {\n    this.count++;\n    this.setAttribute(\'count\', this.count);\n    this.dispatchEvent(new CustomEvent(\'count-changed\', { detail: this.count }));\n  }\n\n  render() {\n    this.shadowRoot.innerHTML = `<button>Count: ${this.count}</button>`;\n  }\n}\n\ncustomElements.define(\'counter-button\', CounterButton);',
  followUp: 'What is `customElements.whenDefined()` and when would you use it?',
  keyTakeaway: 'Custom elements extend `HTMLElement` with lifecycle callbacks and are registered via `customElements.define()` with a hyphenated tag name.',
},
{
  id: 87,
  title: 'What is the `<slot>` element used for in Web Components?',
  difficulty: 'medium',
  topic: 'modern-apis',
  subtopic: 'slots',
  answer: 'The `<slot>` element is a placeholder inside a Shadow DOM template where the component consumer can inject their own content (known as "light DOM" content). A default (unnamed) `<slot>` captures all unslotted children, while named slots (e.g., `<slot name="header">`) capture children with a matching `slot="header"` attribute. If no content is provided for a slot, the fallback content inside the `<slot>` tags is shown. The `::slotted()` CSS pseudo-element allows styling projected content from within the shadow root. The `slotchange` event fires when the distributed nodes change.',
  codeExample: '<!-- Component definition -->\n<template id="cardTemplate">\n  <style>\n    ::slotted(h2) { color: navy; margin: 0; }\n    ::slotted(p) { color: #666; }\n    .footer { border-top: 1px solid #eee; padding-top: 8px; }\n  </style>\n  <div class="card">\n    <slot name="header"><h2>Default Header</h2></slot>\n    <slot>Default body content</slot>\n    <div class="footer">\n      <slot name="footer"></slot>\n    </div>\n  </div>\n</template>\n\n<!-- Usage -->\n<my-card>\n  <h2 slot="header">Custom Title</h2>\n  <p>This goes into the default slot.</p>\n  <span slot="footer">Posted today</span>\n</my-card>',
  followUp: 'Can you nest slots or use a slot inside another component\'s shadow DOM?',
  keyTakeaway: '`<slot>` enables content projection in Web Components, allowing consumers to inject light DOM content into named or default placeholders in the shadow tree.',
},
{
  id: 88,
  title: 'What is the `popover` attribute in HTML?',
  difficulty: 'medium',
  topic: 'modern-apis',
  subtopic: 'popover',
  answer: 'The `popover` attribute is a native HTML API for creating dismissible popup content like tooltips, menus, and toasts without JavaScript. An element with `popover` (defaults to `popover="auto"`) is hidden by default and rendered in the top layer when shown, meaning it appears above all other content without z-index management. Auto popovers implement "light dismiss" (clicking outside or pressing Escape closes them) and auto-close other auto popovers. Manual popovers (`popover="manual"`) require explicit closing. A `<button>` with `popovertarget="id"` toggles the popover, and `popovertargetaction` can be set to `"show"`, `"hide"`, or `"toggle"`.',
  codeExample: '<!-- Auto popover with toggle button -->\n<button popovertarget="mypopover">Toggle Menu</button>\n<div id="mypopover" popover>\n  <nav>\n    <a href="/profile">Profile</a>\n    <a href="/settings">Settings</a>\n    <a href="/logout">Log Out</a>\n  </nav>\n</div>\n\n<!-- Manual popover (no light dismiss) -->\n<button popovertarget="toast" popovertargetaction="show">Show Toast</button>\n<div id="toast" popover="manual" role="status">\n  Item saved successfully!\n  <button popovertarget="toast" popovertargetaction="hide">Dismiss</button>\n</div>\n\n<style>\n  [popover] {\n    padding: 16px;\n    border: 1px solid #ccc;\n    border-radius: 8px;\n  }\n  [popover]::backdrop {\n    background: rgba(0, 0, 0, 0.1);\n  }\n</style>',
  followUp: 'How does the popover API interact with the CSS `anchor()` function for positioning?',
  keyTakeaway: 'The `popover` attribute creates native dismissible popups rendered in the top layer, with auto popovers supporting light dismiss behavior.',
},
{
  id: 89,
  title: 'What is the HTML Drag and Drop API?',
  difficulty: 'medium',
  topic: 'modern-apis',
  subtopic: 'drag-drop',
  answer: 'The HTML Drag and Drop API enables dragging elements and dropping them onto targets using native browser events. Make an element draggable by setting `draggable="true"`. The drag source fires `dragstart`, `drag`, and `dragend` events. Drop targets listen for `dragenter`, `dragover`, `dragleave`, and `drop` events. You must call `e.preventDefault()` on `dragover` to allow dropping, as the default behavior prevents it. Data is transferred between source and target via the `DataTransfer` object on the event, using `setData()` and `getData()`. The API also supports dragging files from the desktop into the browser.',
  codeExample: '<div id="item" draggable="true">Drag me</div>\n<div id="target">Drop here</div>\n\n<script>\n  const item = document.getElementById(\'item\');\n  const target = document.getElementById(\'target\');\n\n  item.addEventListener(\'dragstart\', (e) => {\n    e.dataTransfer.setData(\'text/plain\', item.id);\n    e.dataTransfer.effectAllowed = \'move\';\n  });\n\n  target.addEventListener(\'dragover\', (e) => {\n    e.preventDefault(); // Required to allow drop\n    e.dataTransfer.dropEffect = \'move\';\n  });\n\n  target.addEventListener(\'drop\', (e) => {\n    e.preventDefault();\n    const id = e.dataTransfer.getData(\'text/plain\');\n    target.appendChild(document.getElementById(id));\n  });\n\n  // File drop from desktop\n  target.addEventListener(\'drop\', (e) => {\n    const files = e.dataTransfer.files;\n    // Process dropped files\n  });\n</script>',
  followUp: 'What are the accessibility concerns with drag-and-drop interfaces and how do you address them?',
  keyTakeaway: 'The Drag and Drop API uses `draggable="true"`, DataTransfer for payload, and requires `preventDefault()` on `dragover` to enable dropping.',
},
{
  id: 90,
  title: 'How do you implement preloading and prefetching with HTML?',
  difficulty: 'medium',
  topic: 'modern-apis',
  subtopic: 'resource-hints',
  answer: 'HTML provides several `<link>` elements for resource hints that optimize loading. `rel="preload"` fetches a resource needed for the current page with high priority (e.g., critical fonts, hero images, or key scripts) and requires an `as` attribute to set the correct priority and content type. `rel="prefetch"` fetches resources likely needed for future navigations with low priority during idle time. `rel="preconnect"` establishes early connections (DNS + TCP + TLS) to known third-party origins. `rel="dns-prefetch"` resolves DNS only. `rel="modulepreload"` is specifically for ES modules, parsing and compiling them in advance.',
  codeExample: '<head>\n  <!-- Preconnect to third-party origins -->\n  <link rel="preconnect" href="https://fonts.googleapis.com" />\n  <link rel="preconnect" href="https://cdn.example.com" crossorigin />\n\n  <!-- DNS prefetch as fallback -->\n  <link rel="dns-prefetch" href="https://analytics.example.com" />\n\n  <!-- Preload critical resources for current page -->\n  <link rel="preload" href="/fonts/inter.woff2" as="font" type="font/woff2" crossorigin />\n  <link rel="preload" href="/hero.webp" as="image" />\n  <link rel="preload" href="/critical.css" as="style" />\n\n  <!-- Module preload -->\n  <link rel="modulepreload" href="/app.js" />\n\n  <!-- Prefetch resources for likely next navigation -->\n  <link rel="prefetch" href="/next-page.html" />\n  <link rel="prefetch" href="/data/next-page.json" as="fetch" />\n</head>',
  followUp: 'What happens if you preload a resource but never use it on the page?',
  keyTakeaway: 'Use `preload` for critical current-page resources, `prefetch` for future navigations, and `preconnect` for early third-party connections.',
},
{
  id: 91,
  title: 'What is the `<base>` element and when would you use it?',
  difficulty: 'medium',
  topic: 'modern-apis',
  subtopic: 'base-element',
  answer: 'The `<base>` element specifies a base URL and/or default target for all relative URLs and hyperlinks in the document. It must appear in the `<head>` and only the first `<base>` element with each attribute is used. The `href` attribute sets the base URL that all relative paths resolve against, and the `target` attribute sets the default browsing context for links (e.g., `_blank`). It is useful when serving content from a different base path than the document location, such as in email templates or when an app is hosted under a subdirectory. However, it can cause confusion because it affects all relative URLs including anchors, images, scripts, and stylesheets.',
  codeExample: '<head>\n  <!-- All relative URLs resolve from this base -->\n  <base href="https://cdn.example.com/assets/" />\n\n  <!-- This resolves to https://cdn.example.com/assets/styles/main.css -->\n  <link rel="stylesheet" href="styles/main.css" />\n</head>\n<body>\n  <!-- This resolves to https://cdn.example.com/assets/images/logo.png -->\n  <img src="images/logo.png" alt="Logo" />\n\n  <!-- Absolute URLs are not affected -->\n  <a href="https://example.com/about">About</a>\n\n  <!-- Fragment links are affected ‚Äî this goes to base + #section -->\n  <!-- Use href="currentpage.html#section" to work around this -->\n  <a href="#section">Jump to section</a>\n</body>',
  followUp: 'What are the potential pitfalls of using `<base>` with fragment identifiers and JavaScript?',
  keyTakeaway: '`<base>` sets a document-wide base URL for resolving all relative paths, useful for subdirectory hosting but requiring caution with fragments and anchors.',
},
{
  id: 92,
  title: 'How do `<meta>` viewport settings affect responsive design?',
  difficulty: 'medium',
  topic: 'modern-apis',
  subtopic: 'viewport',
  answer: 'The `<meta name="viewport">` tag controls how the browser\'s viewport scales and sizes content on mobile devices. Without it, mobile browsers render the page at a desktop-width virtual viewport (typically 980px) and scale it down, making text unreadable. Setting `width=device-width` makes the viewport match the device\'s screen width, and `initial-scale=1` sets the initial zoom level. The `user-scalable=no` and `maximum-scale=1` values prevent pinch-to-zoom, which is generally an accessibility anti-pattern and should be avoided. The `interactive-widget=resizes-visual` controls how the virtual keyboard affects layout.',
  codeExample: '<!-- Standard responsive viewport -->\n<meta name="viewport" content="width=device-width, initial-scale=1" />\n\n<!-- BAD: Disables zoom ‚Äî accessibility violation -->\n<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1" />\n\n<!-- Control virtual keyboard behavior -->\n<meta name="viewport" content="width=device-width, initial-scale=1, interactive-widget=resizes-visual" />\n\n<!-- Theme color for browser chrome -->\n<meta name="theme-color" content="#1a1a2e" media="(prefers-color-scheme: dark)" />\n<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)" />',
  followUp: 'What is the difference between the visual viewport and the layout viewport on mobile browsers?',
  keyTakeaway: '`<meta name="viewport" content="width=device-width, initial-scale=1">` is essential for responsive design, and disabling zoom harms accessibility.',
},
{
  id: 93,
  title: 'What is the Intersection Observer API and how does it relate to HTML?',
  difficulty: 'medium',
  topic: 'modern-apis',
  subtopic: 'intersection-observer',
  answer: 'The Intersection Observer API asynchronously monitors when an HTML element enters or exits the viewport (or a specified container element). Unlike scroll event listeners, it runs off the main thread and does not cause layout thrashing, making it highly performant. Common HTML-related use cases include lazy-loading images, infinite scrolling, triggering animations when elements become visible, tracking ad viewability, and implementing sticky header behavior. You create an observer with a callback and options (root element, rootMargin, and threshold), then call `observe()` on target elements. The callback receives `IntersectionObserverEntry` objects with properties like `isIntersecting` and `intersectionRatio`.',
  codeExample: '<img class="lazy" data-src="photo1.jpg" alt="Photo 1" width="400" height="300" />\n<img class="lazy" data-src="photo2.jpg" alt="Photo 2" width="400" height="300" />\n\n<script>\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        const img = entry.target;\n        img.src = img.dataset.src;\n        img.classList.remove(\'lazy\');\n        observer.unobserve(img);\n      }\n    });\n  }, {\n    rootMargin: \'200px 0px\', // Start loading 200px before visible\n    threshold: 0\n  });\n\n  document.querySelectorAll(\'img.lazy\').forEach(img => observer.observe(img));\n</script>',
  followUp: 'How does the native `loading="lazy"` attribute relate to Intersection Observer?',
  keyTakeaway: 'Intersection Observer efficiently detects when HTML elements enter the viewport, enabling performant lazy loading, animations, and scroll-driven behavior.',
},
{
  id: 94,
  title: 'How do you implement service worker registration from HTML?',
  difficulty: 'hard',
  topic: 'modern-apis',
  subtopic: 'service-workers',
  answer: 'Service workers are registered from a page\'s JavaScript using `navigator.serviceWorker.register()`, typically triggered by a `<script>` in the HTML document. The service worker file must be served over HTTPS (except on localhost) and its scope is determined by its location or the `scope` option. Best practice is to register the service worker after the page has loaded to avoid competing for bandwidth during initial render. The HTML page can also include `<link rel="manifest">` for PWA configuration that works alongside the service worker. The registration returns a promise that resolves to a `ServiceWorkerRegistration` object with `installing`, `waiting`, and `active` properties.',
  codeExample: '<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8" />\n  <meta name="viewport" content="width=device-width, initial-scale=1" />\n  <link rel="manifest" href="/manifest.json" />\n  <meta name="theme-color" content="#1a1a2e" />\n</head>\n<body>\n  <div id="app"></div>\n\n  <script>\n    if (\'serviceWorker\' in navigator) {\n      window.addEventListener(\'load\', async () => {\n        try {\n          const reg = await navigator.serviceWorker.register(\'/sw.js\', {\n            scope: \'/\',\n          });\n          reg.addEventListener(\'updatefound\', () => {\n            const newWorker = reg.installing;\n            newWorker.addEventListener(\'statechange\', () => {\n              if (newWorker.state === \'activated\') {\n                // Notify user of update\n              }\n            });\n          });\n        } catch (err) {\n          console.error(\'SW registration failed:\', err);\n        }\n      });\n    }\n  </script>\n</body>\n</html>',
  followUp: 'What is the service worker lifecycle and how do `install`, `activate`, and `fetch` events work?',
  keyTakeaway: 'Service workers are registered via JavaScript in the HTML page, should be loaded after page load, and require HTTPS for security.',
},
{
  id: 95,
  title: 'What is Declarative Shadow DOM and why was it introduced?',
  difficulty: 'hard',
  topic: 'modern-apis',
  subtopic: 'declarative-shadow-dom',
  answer: 'Declarative Shadow DOM (DSD) allows attaching a shadow root to an element using HTML markup via `<template shadowrootmode="open">` (or `"closed"`), without requiring JavaScript. This is critical for server-side rendering (SSR) of Web Components, because traditional Shadow DOM can only be created imperatively with `attachShadow()`, meaning the component\'s encapsulated content is invisible until JavaScript loads and executes. With DSD, the browser processes the template during HTML parsing and immediately attaches the shadow root, enabling Web Components to render their encapsulated content before any JavaScript runs. The template element is consumed during parsing and does not remain in the DOM.',
  codeExample: '<!-- Declarative Shadow DOM ‚Äî works without JavaScript -->\n<my-card>\n  <template shadowrootmode="open">\n    <style>\n      :host { display: block; padding: 16px; border: 1px solid #ddd; }\n      ::slotted(h2) { margin: 0; color: navy; }\n    </style>\n    <slot name="title"></slot>\n    <slot></slot>\n  </template>\n  <h2 slot="title">Server-Rendered Card</h2>\n  <p>This content is visible immediately, no JS required.</p>\n</my-card>\n\n<!-- The component class can still hydrate -->\n<script>\n  class MyCard extends HTMLElement {\n    connectedCallback() {\n      // Shadow root already exists from DSD\n      // this.shadowRoot is already populated\n    }\n  }\n  customElements.define(\'my-card\', MyCard);\n</script>',
  followUp: 'How does Declarative Shadow DOM handle hydration when the JavaScript component class loads?',
  keyTakeaway: 'Declarative Shadow DOM enables server-side rendering of Web Components by attaching shadow roots via HTML templates without JavaScript.',
},
{
  id: 96,
  title: 'How does the `Content-Security-Policy` meta tag work?',
  difficulty: 'hard',
  topic: 'modern-apis',
  subtopic: 'csp',
  answer: 'The `<meta http-equiv="Content-Security-Policy">` tag allows defining a Content Security Policy directly in HTML, restricting which resources the browser can load and execute. It uses directives like `default-src`, `script-src`, `style-src`, `img-src`, `connect-src`, and `frame-src` to whitelist allowed origins for each resource type. Values include `\'self\'` (same origin), `\'none\'`, specific URLs, `\'unsafe-inline\'`, `\'unsafe-eval\'`, and nonce or hash values for inline scripts. While HTTP headers are preferred for CSP delivery (they support more directives like `frame-ancestors` and `report-uri`), the meta tag is useful when you cannot control server headers, such as on static hosting.',
  codeExample: '<!-- Basic CSP via meta tag -->\n<meta http-equiv="Content-Security-Policy"\n  content="default-src \'self\';\n    script-src \'self\' \'nonce-abc123\';\n    style-src \'self\' \'unsafe-inline\';\n    img-src \'self\' https://cdn.example.com;\n    connect-src \'self\' https://api.example.com;\n    font-src \'self\' https://fonts.gstatic.com;\n    frame-src \'none\';\n    object-src \'none\';\n    base-uri \'self\'" />\n\n<!-- Inline script must use the matching nonce -->\n<script nonce="abc123">\n  // This script is allowed by the nonce\n  console.log(\'Authorized script\');\n</script>\n\n<!-- This script would be BLOCKED (no matching nonce) -->\n<!-- <script>alert(\'blocked\')</script> -->',
  followUp: 'What is the difference between delivering CSP via HTTP headers versus meta tags?',
  keyTakeaway: 'The CSP meta tag restricts resource loading by origin and type, mitigating XSS attacks, though HTTP headers are preferred for full directive support.',
},
{
  id: 97,
  title: 'What are import maps and how do they change module loading?',
  difficulty: 'hard',
  topic: 'modern-apis',
  subtopic: 'import-maps',
  answer: 'Import maps are a browser-native feature defined via `<script type="importmap">` that let you control how ES module specifiers are resolved, enabling bare specifiers (like `import React from "react"`) to work directly in the browser without a bundler. The map is a JSON object with `imports` (top-level mappings) and optional `scopes` (context-specific overrides) keys. This allows aliasing package names to CDN URLs, mapping multiple modules, pinning dependency versions, and supporting development/production swaps. Import maps must be declared before any `<script type="module">` elements and only one import map per document is allowed.',
  codeExample: '<script type="importmap">\n{\n  "imports": {\n    "react": "https://esm.sh/react@18.3.1",\n    "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",\n    "lodash/": "https://esm.sh/lodash-es@4.17.21/",\n    "@app/": "/src/modules/"\n  },\n  "scopes": {\n    "/admin/": {\n      "react": "https://esm.sh/react@18.3.1?dev"\n    }\n  }\n}\n</script>\n\n<script type="module">\n  // Bare specifiers now work without a bundler\n  import React from \'react\';\n  import { createRoot } from \'react-dom/client\';\n  import { debounce } from \'lodash/debounce\';\n  import { auth } from \'@app/auth\';\n</script>',
  followUp: 'How do import maps interact with `<link rel="modulepreload">`?',
  keyTakeaway: 'Import maps enable bare module specifiers in the browser by mapping package names to URLs, eliminating the need for a bundler in simple setups.',
},
{
  id: 98,
  title: 'What is the `is` attribute for customized built-in elements?',
  difficulty: 'hard',
  topic: 'modern-apis',
  subtopic: 'custom-elements',
  answer: 'The `is` attribute creates "customized built-in elements" ‚Äî custom elements that extend native HTML elements rather than the generic `HTMLElement`. By extending a specific element class (e.g., `HTMLButtonElement`) and registering with `{ extends: "button" }`, the custom element inherits all native behaviors including accessibility semantics, form participation, and built-in functionality. Usage in HTML is `<button is="fancy-button">` rather than `<fancy-button>`. This preserves progressive enhancement: if JavaScript fails to load, the element still works as a regular `<button>`. However, Safari does not support customized built-in elements and has stated it will not implement them, limiting cross-browser adoption.',
  codeExample: 'class FancyButton extends HTMLButtonElement {\n  connectedCallback() {\n    this.addEventListener(\'click\', this.handleClick);\n    this.style.background = \'linear-gradient(135deg, #667eea, #764ba2)\';\n    this.style.color = \'white\';\n    this.style.border = \'none\';\n    this.style.borderRadius = \'8px\';\n    this.style.padding = \'8px 16px\';\n  }\n\n  disconnectedCallback() {\n    this.removeEventListener(\'click\', this.handleClick);\n  }\n\n  handleClick() {\n    this.animate([{ transform: \'scale(0.95)\' }, { transform: \'scale(1)\' }],\n      { duration: 150 });\n  }\n}\n\ncustomElements.define(\'fancy-button\', FancyButton, { extends: \'button\' });\n\n// HTML usage:\n// <button is="fancy-button" type="submit">Submit</button>\n// Falls back to a regular button if JS fails',
  followUp: 'Why does Safari refuse to implement customized built-in elements and what is the alternative?',
  keyTakeaway: 'The `is` attribute extends native elements with custom behavior while preserving built-in semantics and progressive enhancement, but lacks Safari support.',
},
{
  id: 99,
  title: 'How does the HTML Sanitizer API work?',
  difficulty: 'hard',
  topic: 'modern-apis',
  subtopic: 'sanitizer-api',
  answer: 'The HTML Sanitizer API is a browser-native API for safely sanitizing untrusted HTML strings to prevent XSS attacks. It provides `Element.setHTML(input, options)` which parses and sanitizes HTML before inserting it into the DOM, replacing the dangerous pattern of setting `innerHTML` with untrusted content. The sanitizer removes dangerous elements like `<script>`, event handler attributes like `onclick`, and potentially harmful URLs in `href` and `src`. You can customize the sanitizer configuration with `allowElements`, `blockElements`, `dropElements`, `allowAttributes`, and `dropAttributes` to control exactly which HTML features are permitted. This is safer than library-based sanitization because it leverages the browser\'s own HTML parser.',
  codeExample: '// Basic usage with setHTML\nconst userContent = \'<p>Hello</p><script>alert("xss")</script><img onerror="alert(1)" src="x">\';\nconst el = document.getElementById(\'output\');\n\n// Sanitizes automatically ‚Äî scripts and event handlers removed\nel.setHTML(userContent);\n// Result: <p>Hello</p><img src="x">\n\n// Custom configuration\nel.setHTML(userContent, {\n  sanitizer: {\n    allowElements: [\'p\', \'b\', \'i\', \'em\', \'strong\', \'a\'],\n    allowAttributes: {\n      href: [\'a\'],\n      class: [\'*\'],\n    },\n    // URLs with javascript: protocol are blocked by default\n  }\n});\n\n// Before Sanitizer API, the risky pattern was:\n// el.innerHTML = userContent; // DANGEROUS ‚Äî never do this',
  followUp: 'How does the Sanitizer API compare to libraries like DOMPurify?',
  keyTakeaway: 'The Sanitizer API provides browser-native XSS protection via `setHTML()`, safely parsing untrusted HTML by stripping scripts and dangerous attributes.',
},
{
  id: 100,
  title: 'What is the `blocking="render"` attribute and how does it affect page loading?',
  difficulty: 'hard',
  topic: 'modern-apis',
  subtopic: 'render-blocking',
  answer: 'The `blocking="render"` attribute explicitly marks a resource as render-blocking, preventing the browser from rendering any content until that resource has been fetched and processed. It can be applied to `<link>`, `<script>`, and `<style>` elements. While stylesheets are already render-blocking by default, this attribute is useful for explicitly blocking render on async scripts, module scripts, or body-level stylesheets that must be applied before first paint to avoid a flash of unstyled content (FOUC). It gives developers declarative control over the rendering pipeline. Conversely, understanding render-blocking behavior is essential for performance: unnecessary render-blocking resources delay First Contentful Paint (FCP), so this attribute should be used sparingly.',
  codeExample: '<!-- Stylesheet is render-blocking by default -->\n<link rel="stylesheet" href="critical.css" />\n\n<!-- Explicitly render-block a module script -->\n<script type="module" blocking="render" src="theme-init.js"></script>\n\n<!-- Render-block a body-level stylesheet -->\n<body>\n  <style blocking="render">\n    /* Critical above-the-fold styles that must apply before paint */\n    :root { --theme-bg: #1a1a2e; }\n    body { background: var(--theme-bg); }\n  </style>\n\n  <!-- This content won\'t render until the above style is processed -->\n  <main>Content here</main>\n\n  <!-- Non-render-blocking async script -->\n  <script async src="analytics.js"></script>\n</body>',
  followUp: 'How does `blocking="render"` interact with `<link rel="preload">` and the browser\'s speculative parser?',
  keyTakeaway: '`blocking="render"` gives declarative control over which resources must be processed before first paint, useful for preventing FOUC but requiring careful use to avoid harming FCP.',
},
]

export function filterHTMLQuestions(
  questions: HTMLInterviewQuestion[],
  difficulty: 'all' | 'easy' | 'medium' | 'hard',
  topic: string,
): HTMLInterviewQuestion[] {
  return questions.filter((q) => {
    if (difficulty !== 'all' && q.difficulty !== difficulty) return false
    if (topic !== 'all' && q.topic !== topic) return false
    return true
  })
}
